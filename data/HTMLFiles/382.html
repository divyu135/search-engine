<!DOCTYPE html><html class="client-nojs" lang="en" dir="ltr"><head><meta charset="UTF-8"/><title>LR parser - Wikipedia</title><script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":!1,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"bac963c7-0b88-42e9-98c8-47d0577158f0","wgCSPNonce":!1,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":!1,"wgNamespaceNumber":0,"wgPageName":"LR_parser","wgTitle":"LR parser","wgCurRevisionId":982082121,"wgRevisionId":982082121,"wgArticleId":18030,"wgIsArticle":!0,"wgIsRedirect":!1,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["CS1 maint: ref=harv","Articles with short description","Short description is different from Wikidata","All articles with unsourced statements","Articles with unsourced statements from September 2019","Articles with unsourced statements from June 2012","Parsing algorithms"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"LR_parser","wgRelevantArticleId":18030,"wgIsProbablyEditable":!0,"wgRelevantPageIsProbablyEditable":!0,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMediaViewerOnClick":!0,"wgMediaViewerEnabledByDefault":!0,"wgPopupsReferencePreviews":!1,"wgPopupsConflictsWithNavPopupGadget":!1,"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgMFDisplayWikibaseDescriptions":{"search":!0,"nearby":!0,"watchlist":!0,"tagline":!1},"wgWMESchemaEditAttemptStepOversample":!1,"wgULSCurrentAutonym":"English","wgNoticeProject":"wikipedia","wgCentralAuthMobileDomain":!1,"wgEditSubmitButtonLabelPublish":!0,"wgULSPosition":"interlanguage","wgWikibaseItemId":"Q1756442"};RLSTATE={"ext.globalCssJs.user.styles":"ready","site.styles":"ready","noscript":"ready","user.styles":"ready","ext.globalCssJs.user":"ready","user":"ready","user.options":"loading","ext.cite.styles":"ready","ext.math.styles":"ready","skins.vector.styles.legacy":"ready","jquery.makeCollapsible.styles":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.uls.interlanguage":"ready","ext.wikimediaBadges":"ready","wikibase.client.init":"ready"};RLPAGEMODULES=["ext.cite.ux-enhancements","ext.math.scripts","site","mediawiki.page.ready","jquery.makeCollapsible","mediawiki.toc","skins.vector.legacy.js","ext.gadget.ReferenceTooltips","ext.gadget.charinsert","ext.gadget.extra-toolbar-buttons","ext.gadget.refToolbar","ext.gadget.switcher","ext.centralauth.centralautologin","mmv.head","mmv.bootstrap.autostart","ext.popups","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.eventLogging","ext.wikimediaEvents","ext.navigationTiming","ext.uls.compactlinks","ext.uls.interface","ext.cx.eventlogging.campaigns","ext.quicksurveys.init","ext.centralNotice.geoIP","ext.centralNotice.startUp"];</script><script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@1hzgi",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});});});</script><link rel="stylesheet" href="/w/load.php?lang=en&amp;modules=ext.cite.styles%7Cext.math.styles%7Cext.uls.interlanguage%7Cext.visualEditor.desktopArticleTarget.noscript%7Cext.wikimediaBadges%7Cjquery.makeCollapsible.styles%7Cskins.vector.styles.legacy%7Cwikibase.client.init&amp;only=styles&amp;skin=vector"/><script async="" src="/w/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script><meta name="ResourceLoaderDynamicStyles" content=""/><link rel="stylesheet" href="/w/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/><meta name="generator" content="MediaWiki 1.36.0-wmf.18"/><meta name="referrer" content="origin"/><meta name="referrer" content="origin-when-crossorigin"/><meta name="referrer" content="origin-when-cross-origin"/><link rel="preconnect" href="//upload.wikimedia.org"/><link rel="alternate" media="only screen and (max-width: 720px)" href="//en.m.wikipedia.org/wiki/LR_parser"/><link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=LR_parser&amp;action=edit"/><link rel="edit" title="Edit this page" href="/w/index.php?title=LR_parser&amp;action=edit"/><link rel="apple-touch-icon" href="/static/apple-touch/wikipedia.png"/><link rel="shortcut icon" href="/static/favicon/wikipedia.ico"/><link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)"/><link rel="EditURI" type="application/rsd+xml" href="//en.wikipedia.org/w/api.php?action=rsd"/><link rel="license" href="//creativecommons.org/licenses/by-sa/3.0/"/><link rel="canonical" href="https://en.wikipedia.org/wiki/LR_parser"/><link rel="dns-prefetch" href="//login.wikimedia.org"/><link rel="dns-prefetch" href="//meta.wikimedia.org" /></head><body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject mw-editable page-LR_parser rootpage-LR_parser skin-vector action-view skin-vector-legacy"><div id="mw-page-base" class="noprint"></div><div id="mw-head-base" class="noprint"></div><div id="content" class="mw-body" role="main">	<a id="top"></a>	<div id="siteNotice" class="mw-body-content"><!-- CentralNotice --></div>	<div class="mw-indicators mw-body-content">	</div>	<h1 id="firstHeading" class="firstHeading" lang="en">LR parser</h1>	<div id="bodyContent" class="mw-body-content">		<div id="siteSub" class="noprint">From Wikipedia, the free encyclopedia</div>		<div id="contentSub"></div>		<div id="contentSub2"></div>				<div id="jump-to-nav"></div>		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>		<a class="mw-jump-link" href="#searchInput">Jump to search</a>		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div class="shortdescription nomobile noexcerpt noprint searchaux" style="display:none">type of parser in computer science</div><p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>LR parsers</b> are a type of <a href="/wiki/Bottom-up_parsing" title="Bottom-up parsing">bottom-up parser</a> that analyses <a href="/wiki/Deterministic_context-free_language" title="Deterministic context-free language">deterministic context-free languages</a> in linear time.<sup id="cite_ref-Knuth_1965_1-0" class="reference"><a href="#cite_note-Knuth_1965-1">&#91;1&#93;</a></sup> There are several variants of LR parsers: <a href="/wiki/SLR_parser" class="mw-redirect" title="SLR parser"><b>SLR</b> parsers</a>, <a href="/wiki/LALR_parser" title="LALR parser"><b>LALR</b> parsers</a>, <a href="/wiki/Canonical_LR_parser" title="Canonical LR parser"><b>Canonical LR(1)</b> parsers</a>, <a href="/wiki/Canonical_LR_parser" title="Canonical LR parser"><b>Minimal LR(1)</b> parsers</a>, <a href="/wiki/Generalized_LR_parser" class="mw-redirect" title="Generalized LR parser"><b>GLR</b> parsers</a>. LR parsers can be generated by a <a href="/wiki/Parser_generator" class="mw-redirect" title="Parser generator">parser generator</a> from a <a href="/wiki/Formal_grammar" title="Formal grammar">formal grammar</a> defining the syntax of the language to be parsed. They are widely used for the processing of <a href="/wiki/Computer_language" title="Computer language">computer languages</a>.</p><p>An <b>LR</b> parser (<b>L</b>eft-to-right, <b>R</b>ightmost derivation in reverse) reads input text from left to right without backing up (this is true for most parsers), and produces a <a href="/wiki/Rightmost_derivation" class="mw-redirect" title="Rightmost derivation">rightmost derivation</a> in reverse: it does a <a href="/wiki/Bottom-up_parsing" title="Bottom-up parsing">bottom-up parse</a> – not a <a href="/wiki/Top-down_parsing" title="Top-down parsing">top-down LL parse</a> or ad-hoc parse. The name LR is often followed by a numeric qualifier, as in <b>LR(1)</b> or sometimes <b>LR(<i>k</i>)</b>. To avoid <a href="/wiki/Backtracking" title="Backtracking">backtracking</a> or guessing, the LR parser is allowed to peek ahead at <i>k</i> <a href="/wiki/Parsing#Lookahead" title="Parsing">lookahead</a> input <a href="/wiki/Symbol_(formal)" title="Symbol (formal)">symbols</a> before deciding how to parse earlier symbols. Typically <i>k</i> is 1 and is not mentioned. The name LR is often preceded by other qualifiers, as in <b>SLR</b> and <b>LALR</b>.  The <b>LR(<i>k</i>)</b> condition for a grammar was suggested by Knuth to stand for "translatable from left to right with bound <i>k</i>."<sup id="cite_ref-Knuth_1965_1-1" class="reference"><a href="#cite_note-Knuth_1965-1">&#91;1&#93;</a></sup></p><p>LR parsers are deterministic; they produce a single correct parse without guesswork or backtracking, in linear time.  This is ideal for computer languages, but LR parsers are not suited for human languages which need more flexible but inevitably slower methods.  Some methods which can parse arbitrary context-free languages (e.g., <a href="/wiki/CYK_algorithm" title="CYK algorithm">Cocke–Younger–Kasami</a>, <a href="/wiki/Earley_parser" title="Earley parser">Earley</a>, <a href="/wiki/GLR_parser" title="GLR parser">GLR</a>) have worst-case performance of O(<var style="padding-right: 1px;">n</var><sup>3</sup>) time.  Other methods which backtrack or yield multiple parses may even take exponential time when they guess badly.<sup id="cite_ref-AhoUllman_1972_2-0" class="reference"><a href="#cite_note-AhoUllman_1972-2">&#91;2&#93;</a></sup></p><p>The above properties of <b>L</b>, <b>R</b>, and <i><b>k</b></i> are actually shared by all <a href="/wiki/Shift-reduce_parser" title="Shift-reduce parser">shift-reduce parsers</a>, including <a href="/wiki/Simple_precedence_parser" title="Simple precedence parser">precedence parsers</a>. But by convention, the LR name stands for the form of parsing invented by <a href="/wiki/Donald_Knuth" title="Donald Knuth">Donald Knuth</a>, and excludes the earlier, less powerful precedence methods (for example <a href="/wiki/Operator-precedence_parser" title="Operator-precedence parser">Operator-precedence parser</a>).<sup id="cite_ref-Knuth_1965_1-2" class="reference"><a href="#cite_note-Knuth_1965-1">&#91;1&#93;</a></sup>LR parsers can handle a larger range of languages and grammars than precedence parsers or top-down <a href="/wiki/LL_parsing" class="mw-redirect" title="LL parsing">LL parsing</a>.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3">&#91;3&#93;</a></sup> This is because the LR parser waits until it has seen an entire instance of some grammar pattern before committing to what it has found. An LL parser has to decide or guess what it is seeing much sooner, when it has only seen the leftmost input symbol of that pattern.</p><div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div><ul><li class="toclevel-1 tocsection-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a><ul><li class="toclevel-2 tocsection-2"><a href="#Bottom-up_parse_tree_for_example_A*2_+_1"><span class="tocnumber">1.1</span> <span class="toctext">Bottom-up parse tree for example <span> A*2 + 1 </span></span></a></li><li class="toclevel-2 tocsection-3"><a href="#Shift_and_reduce_actions"><span class="tocnumber">1.2</span> <span class="toctext">Shift and reduce actions</span></a></li><li class="toclevel-2 tocsection-4"><a href="#Bottom-up_parse_stack"><span class="tocnumber">1.3</span> <span class="toctext">Bottom-up parse stack</span></a></li><li class="toclevel-2 tocsection-5"><a href="#Bottom-up_parse_steps_for_example_A*2_+_1"><span class="tocnumber">1.4</span> <span class="toctext">Bottom-up parse steps for example A*2 + 1</span></a></li><li class="toclevel-2 tocsection-6"><a href="#LR_parse_steps_for_example_A*2_+_1"><span class="tocnumber">1.5</span> <span class="toctext">LR parse steps for example A*2 + 1</span></a></li><li class="toclevel-2 tocsection-7"><a href="#Grammar_for_the_example_A*2_+_1"><span class="tocnumber">1.6</span> <span class="toctext">Grammar for the example A*2 + 1</span></a></li><li class="toclevel-2 tocsection-8"><a href="#Parse_table_for_the_example_grammar"><span class="tocnumber">1.7</span> <span class="toctext">Parse table for the example grammar</span></a></li><li class="toclevel-2 tocsection-9"><a href="#LR_parser_loop"><span class="tocnumber">1.8</span> <span class="toctext">LR parser loop</span></a></li></ul></li><li class="toclevel-1 tocsection-10"><a href="#LR_generator_analysis"><span class="tocnumber">2</span> <span class="toctext">LR generator analysis</span></a><ul><li class="toclevel-2 tocsection-11"><a href="#LR_states"><span class="tocnumber">2.1</span> <span class="toctext">LR states</span></a></li><li class="toclevel-2 tocsection-12"><a href="#Finite_state_machine"><span class="tocnumber">2.2</span> <span class="toctext">Finite state machine</span></a></li><li class="toclevel-2 tocsection-13"><a href="#Lookahead_sets"><span class="tocnumber">2.3</span> <span class="toctext">Lookahead sets</span></a></li><li class="toclevel-2 tocsection-14"><a href="#Syntax_error_recovery"><span class="tocnumber">2.4</span> <span class="toctext">Syntax error recovery</span></a></li><li class="toclevel-2 tocsection-15"><a href="#Variants_of_LR_parsers"><span class="tocnumber">2.5</span> <span class="toctext">Variants of LR parsers</span></a></li><li class="toclevel-2 tocsection-16"><a href="#Theory"><span class="tocnumber">2.6</span> <span class="toctext">Theory</span></a></li></ul></li><li class="toclevel-1 tocsection-17"><a href="#Additional_example_1+1"><span class="tocnumber">3</span> <span class="toctext">Additional example 1+1</span></a><ul><li class="toclevel-2 tocsection-18"><a href="#Action_and_goto_tables"><span class="tocnumber">3.1</span> <span class="toctext">Action and goto tables</span></a></li><li class="toclevel-2 tocsection-19"><a href="#Parsing_steps"><span class="tocnumber">3.2</span> <span class="toctext">Parsing steps</span></a></li><li class="toclevel-2 tocsection-20"><a href="#Walkthrough"><span class="tocnumber">3.3</span> <span class="toctext">Walkthrough</span></a></li></ul></li><li class="toclevel-1 tocsection-21"><a href="#Constructing_LR(0)_parsing_tables"><span class="tocnumber">4</span> <span class="toctext">Constructing LR(0) parsing tables</span></a><ul><li class="toclevel-2 tocsection-22"><a href="#Items"><span class="tocnumber">4.1</span> <span class="toctext">Items</span></a></li><li class="toclevel-2 tocsection-23"><a href="#Item_sets"><span class="tocnumber">4.2</span> <span class="toctext">Item sets</span></a></li><li class="toclevel-2 tocsection-24"><a href="#Extension_of_Item_Set_by_expansion_of_non-terminals"><span class="tocnumber">4.3</span> <span class="toctext">Extension of Item Set by expansion of non-terminals</span></a></li><li class="toclevel-2 tocsection-25"><a href="#Closure_of_item_sets"><span class="tocnumber">4.4</span> <span class="toctext">Closure of item sets</span></a></li><li class="toclevel-2 tocsection-26"><a href="#Augmented_grammar"><span class="tocnumber">4.5</span> <span class="toctext">Augmented grammar</span></a></li></ul></li><li class="toclevel-1 tocsection-27"><a href="#Table_construction"><span class="tocnumber">5</span> <span class="toctext">Table construction</span></a><ul><li class="toclevel-2 tocsection-28"><a href="#Finding_the_reachable_item_sets_and_the_transitions_between_them"><span class="tocnumber">5.1</span> <span class="toctext">Finding the reachable item sets and the transitions between them</span></a></li><li class="toclevel-2 tocsection-29"><a href="#Constructing_the_action_and_goto_tables"><span class="tocnumber">5.2</span> <span class="toctext">Constructing the action and goto tables</span></a><ul><li class="toclevel-3 tocsection-30"><a href="#A_note_about_LR(0)_versus_SLR_and_LALR_parsing"><span class="tocnumber">5.2.1</span> <span class="toctext">A note about LR(0) versus SLR and LALR parsing</span></a></li></ul></li><li class="toclevel-2 tocsection-31"><a href="#Conflicts_in_the_constructed_tables"><span class="tocnumber">5.3</span> <span class="toctext">Conflicts in the constructed tables</span></a></li></ul></li><li class="toclevel-1 tocsection-32"><a href="#See_also"><span class="tocnumber">6</span> <span class="toctext">See also</span></a></li><li class="toclevel-1 tocsection-33"><a href="#References"><span class="tocnumber">7</span> <span class="toctext">References</span></a></li><li class="toclevel-1 tocsection-34"><a href="#Further_reading"><span class="tocnumber">8</span> <span class="toctext">Further reading</span></a></li><li class="toclevel-1 tocsection-35"><a href="#External_links"><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li></ul></div><h2><span class="mw-headline" id="Overview">Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=1" title="Edit section: Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2><h3><span id="Bottom-up_parse_tree_for_example_A.2A2_.2B_1"></span><span class="mw-headline" id="Bottom-up_parse_tree_for_example_A*2_+_1">Bottom-up parse tree for example <span class="nowrap"> A*2 + 1 </span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=2" title="Edit section: Bottom-up parse tree for example A*2 + 1">edit</a><span class="mw-editsection-bracket">]</span></span></h3><div class="thumb tright"><div class="thumbinner" style="width:214px;"><a href="/wiki/File:Shift-Reduce_Parse_Steps_for_A*2%2B1.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/en/thumb/5/5f/Shift-Reduce_Parse_Steps_for_A%2A2%2B1.svg/212px-Shift-Reduce_Parse_Steps_for_A%2A2%2B1.svg.png" decoding="async" width="212" height="200" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/en/thumb/5/5f/Shift-Reduce_Parse_Steps_for_A%2A2%2B1.svg/317px-Shift-Reduce_Parse_Steps_for_A%2A2%2B1.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/5/5f/Shift-Reduce_Parse_Steps_for_A%2A2%2B1.svg/423px-Shift-Reduce_Parse_Steps_for_A%2A2%2B1.svg.png 2x" data-file-width="512" data-file-height="484" /></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Shift-Reduce_Parse_Steps_for_A*2%2B1.svg" class="internal" title="Enlarge"></a></div>Bottom-up parse tree built in numbered steps</div></div></div><p>An LR parser scans and parses the input text in one forward pass over the text.  The parser builds up the <a href="/wiki/Parse_tree" title="Parse tree">parse tree</a> incrementally, bottom up, and left to right, without guessing or backtracking.  At every point in this pass, the parser has accumulated a list of subtrees or phrases of the input text that have been already parsed.  Those subtrees are not yet joined together because the parser has not yet reached the right end of the syntax pattern that will combine them.</p><p>At step 6 in an example parse, only "A*2" has been parsed, incompletely.  Only the shaded lower-left corner of the parse tree exists.  None of the parse tree nodes numbered 7 and above exist yet.  Nodes 3, 4, and 6 are the roots of isolated subtrees for variable A, operator *, and number 2, respectively.  These three root nodes are temporarily held in a parse stack.  The remaining unparsed portion of the input stream is "+ 1".</p><h3><span class="mw-headline" id="Shift_and_reduce_actions">Shift and reduce actions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=3" title="Edit section: Shift and reduce actions">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>As with other shift-reduce parsers, an LR parser works by doing some combination of Shift steps and Reduce steps.  </p><ul><li>A <b>Shift</b> step advances in the input stream by one symbol.  That shifted symbol becomes a new single-node parse tree.</li><li>A <b>Reduce</b> step applies a completed grammar rule to some of the recent parse trees, joining them together as one tree with a new root symbol.</li></ul><p>If the input has no syntax errors, the parser continues with these steps until all of the input has been consumed and all of the parse trees have been reduced to a single tree representing an entire legal input.</p><p>LR parsers differ from other shift-reduce parsers in how they decide when to reduce, and how to pick between rules with similar endings.  But the final decisions and the sequence of shift or reduce steps are the same.</p><p>Much of the LR parser's efficiency is from being deterministic. To avoid guessing, the LR parser often looks ahead (rightwards) at the next scanned symbol, before deciding what to do with previously scanned symbols.  The lexical scanner works one or more symbols ahead of the parser.  The <b>lookahead</b> symbols are the 'right-hand context' for the parsing decision.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4">&#91;4&#93;</a></sup></p><h3><span class="mw-headline" id="Bottom-up_parse_stack">Bottom-up parse stack</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=4" title="Edit section: Bottom-up parse stack">edit</a><span class="mw-editsection-bracket">]</span></span></h3><div class="thumb tright"><div class="thumbinner" style="width:379px;"><a href="/wiki/File:Bottom-Up_Parser.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/en/thumb/d/db/Bottom-Up_Parser.svg/377px-Bottom-Up_Parser.svg.png" decoding="async" width="377" height="250" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/en/thumb/d/db/Bottom-Up_Parser.svg/565px-Bottom-Up_Parser.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/d/db/Bottom-Up_Parser.svg/753px-Bottom-Up_Parser.svg.png 2x" data-file-width="512" data-file-height="340" /></a>  <div class="thumbcaption"><div class="magnify"><a href="/wiki/File:Bottom-Up_Parser.svg" class="internal" title="Enlarge"></a></div>Bottom-Up Parser at step 6</div></div></div><p>Like other shift-reduce parsers, an LR parser lazily waits until it has scanned and parsed all parts of some construct before committing to what the combined construct is.  The parser then acts immediately on the combination instead of waiting any further.  In the parse tree example, the phrase A gets reduced to Value and then to Products in steps 1-3 as soon as lookahead * is seen, rather than waiting any later to organize those parts of the parse tree.  The decisions for how to handle A are based only on what the parser and scanner have already seen, without considering things that appear much later to the right.</p><p>Reductions reorganize the most recently parsed things, immediately to the left of the lookahead symbol.  So the list of already-parsed things acts like a <a href="/wiki/Stack_(abstract_data_type)" title="Stack (abstract data type)">stack</a>.  This <b>parse stack</b> grows rightwards.  The base or bottom of the stack is on the left and holds the leftmost, oldest parse fragment.  Every reduction step acts only on the rightmost, newest parse fragments.  (This accumulative parse stack is very unlike the predictive, leftward-growing parse stack used by <a href="/wiki/Top-down_parser" class="mw-redirect" title="Top-down parser">top-down parsers</a>.)</p><h3><span id="Bottom-up_parse_steps_for_example_A.2A2_.2B_1"></span><span class="mw-headline" id="Bottom-up_parse_steps_for_example_A*2_+_1">Bottom-up parse steps for example A*2 + 1</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=5" title="Edit section: Bottom-up parse steps for example A*2 + 1">edit</a><span class="mw-editsection-bracket">]</span></span></h3><table class="wikitable"><tbody><tr><th><small>Step</small></th><th><small>Parse Stack</small></th><th><small>Unparsed</small></th><th><small>Shift/Reduce</small></th></tr><tr><td>0</td><td><i>empty</i></td><td align="right">A*2 + 1</td><td>shift</td></tr><tr><td>1</td><td><i>id</i></td><td align="right">*2 + 1</td><td>Value → <i>id</i></td></tr><tr><td>2</td><td>Value</td><td align="right">*2 + 1</td><td>Products → Value</td></tr><tr><td>3</td><td>Products</td><td align="right">*2 + 1</td><td>shift</td></tr><tr><td>4</td><td>Products *</td><td align="right">2 + 1</td><td>shift</td></tr><tr><td>5</td><td>Products * <i>int</i></td><td align="right">+ 1</td><td>Value → <i>int</i></td></tr><tr><td>6</td><td>Products * Value</td><td align="right">+ 1</td><td>Products → Products * Value</td></tr><tr><td>7</td><td>Products</td><td align="right">+ 1</td><td>Sums → Products</td></tr><tr><td>8</td><td>Sums</td><td align="right">+ 1</td><td>shift</td></tr><tr><td>9</td><td>Sums +</td><td align="right">1</td><td>shift</td></tr><tr><td>10</td><td>Sums + <i>int</i></td><td><i>eof</i></td><td>Value → <i>int</i></td></tr><tr><td>11</td><td>Sums + Value</td><td><i>eof</i></td><td>Products → Value</td></tr><tr><td>12</td><td>Sums + Products</td><td><i>eof</i></td><td>Sums → Sums + Products</td></tr><tr><td>13</td><td>Sums</td><td><i>eof</i></td><td>done</td></tr></tbody></table><p>Step 6 applies a grammar rule with multiple parts:</p><dl><dd>Products → Products * Value</dd></dl><p>This matches the stack top holding the parsed phrases "... Products * Value".  The reduce step replaces this instance of the rule's right hand side, "Products * Value" by the rule's left hand side symbol, here a larger Products.  If the parser builds complete parse trees, the three trees for inner Products, *, and Value are combined by a new tree root for Products.  Otherwise, <a href="/wiki/Semantics#Programming_languages" title="Semantics">semantic</a> details from the inner Products and Value are output to some later compiler pass, or are combined and saved in the new Products symbol.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5">&#91;5&#93;</a></sup></p><h3><span id="LR_parse_steps_for_example_A.2A2_.2B_1"></span><span class="mw-headline" id="LR_parse_steps_for_example_A*2_+_1">LR parse steps for example A*2 + 1</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=6" title="Edit section: LR parse steps for example A*2 + 1">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>In LR parsers, the shift and reduce decisions are potentially based on the entire stack of everything that has been previously parsed, not just on a single, topmost stack symbol. If done in an unclever way, that could lead to very slow parsers that get slower and slower for longer inputs. LR parsers do this with constant speed, by summarizing all the relevant left context information into a single number called the LR(0) <b>parser state</b>. For each grammar and LR analysis method, there is a fixed (finite) number of such states. Besides holding the already-parsed symbols, the parse stack also remembers the state numbers reached by everything up to those points.</p><p>At every parse step, the entire input text is divided into a stack of previously parsed phrases, and a current lookahead symbol, and the remaining unscanned text.  The parser's next action is determined by its current LR(0) <span style="color:#928">state number</span> (rightmost on the stack) and the lookahead symbol. In the steps below, all the black details are exactly the same as in other non-LR shift-reduce parsers. LR parser stacks add the state information in purple, summarizing the black phrases to their left on the stack and what syntax possibilities to expect next.  Users of an LR parser can usually ignore state information.  These states are explained in a later section.</p><table class="wikitable"><tbody><tr><th><small><br />Step</small></th><th><small>Parse Stack<br /><sub><span style="color:#928">state</span></sub> [Symbol<sub><span style="color:#928">state</span></sub>]* </small></th><th><small>Look<br />Ahead</small></th><th><small><br />Unscanned</small></th><th><small>Parser<br />Action</small></th><th><small><br />Grammar Rule</small></th><th><small>Next<br />State</small></th></tr><tr><td>0</td><td><p><sub><span style="color:#928">0</span></sub></p></td><td><i>id</i></td><td align="right">*2 + 1</td><td>shift</td><td></td><td><span style="color:#928">9</span></td></tr><tr><td>1</td><td><p><sub><span style="color:#928">0</span></sub> <i>id</i><sub><span style="color:#928">9</span></sub> </p></td><td>*</td><td align="right">2 + 1</td><td>reduce</td><td>Value → <i>id</i></td><td><span style="color:#928">7</span></td></tr><tr><td>2</td><td><p><sub><span style="color:#928">0</span></sub> Value<sub><span style="color:#928">7</span></sub></p></td><td>*</td><td align="right">2 + 1</td><td>reduce</td><td>Products → Value</td><td><span style="color:#928">4</span></td></tr><tr><td>3</td><td><p><sub><span style="color:#928">0</span></sub> Products<sub><span style="color:#928">4</span></sub></p></td><td>*</td><td align="right">2 + 1</td><td>shift</td><td></td><td><span style="color:#928">5</span></td></tr><tr><td>4</td><td><p><sub><span style="color:#928">0</span></sub> Products<sub><span style="color:#928">4</span></sub> *<sub><span style="color:#928">5</span></sub> </p></td><td><i>int</i></td><td align="right">+ 1</td><td>shift</td><td></td><td><span style="color:#928">8</span></td></tr><tr><td>5</td><td><p><sub><span style="color:#928">0</span></sub> Products<sub><span style="color:#928">4</span></sub> *<sub><span style="color:#928">5</span></sub><i>int</i><sub><span style="color:#928">8</span></sub> </p></td><td>+</td><td align="right">1</td><td>reduce</td><td>Value → <i>int</i></td><td><span style="color:#928">6</span></td></tr><tr><td>6</td><td><p><sub><span style="color:#928">0</span></sub> Products<sub><span style="color:#928">4</span></sub> *<sub><span style="color:#928">5</span></sub>Value<sub><span style="color:#928">6</span></sub></p></td><td>+</td><td align="right">1</td><td>reduce</td><td>Products → Products * Value</td><td><span style="color:#928">4</span></td></tr><tr><td>7</td><td><p><sub><span style="color:#928">0</span></sub> Products<sub><span style="color:#928">4</span></sub> </p></td><td>+</td><td align="right">1</td><td>reduce</td><td>Sums → Products</td><td><span style="color:#928">1</span></td></tr><tr><td>8</td><td><p><sub><span style="color:#928">0</span></sub> Sums<sub><span style="color:#928">1</span></sub> </p></td><td>+</td><td align="right">1</td><td>shift</td><td></td><td><span style="color:#928">2</span></td></tr><tr><td>9</td><td><p><sub><span style="color:#928">0</span></sub> Sums<sub><span style="color:#928">1</span></sub> +<sub><span style="color:#928">2</span></sub>  </p></td><td><i>int</i></td><td align="right"><i>eof</i></td><td>shift</td><td></td><td><span style="color:#928">8</span></td></tr><tr><td>10</td><td><p><sub><span style="color:#928">0</span></sub> Sums<sub><span style="color:#928">1</span></sub> +<sub><span style="color:#928">2</span></sub> <i>int</i><sub><span style="color:#928">8</span></sub></p></td><td><i>eof</i></td><td></td><td>reduce</td><td>Value → <i>int</i></td><td><span style="color:#928">7</span></td></tr><tr><td>11</td><td><p><sub><span style="color:#928">0</span></sub> Sums<sub><span style="color:#928">1</span></sub> +<sub><span style="color:#928">2</span></sub>  Value<sub><span style="color:#928">7</span></sub> </p></td><td><i>eof</i></td><td></td><td>reduce</td><td>Products → Value</td><td><span style="color:#928">3</span></td></tr><tr><td>12</td><td><p><sub><span style="color:#928">0</span></sub> Sums<sub><span style="color:#928">1</span></sub> +<sub><span style="color:#928">2</span></sub> Products<sub><span style="color:#928">3</span></sub></p></td><td><i>eof</i></td><td></td><td>reduce</td><td>Sums → Sums + Products</td><td><span style="color:#928">1</span></td></tr><tr><td>13</td><td><p><sub><span style="color:#928">0</span></sub> Sums<sub><span style="color:#928">1</span></sub> </p></td><td><i>eof</i></td><td></td><td>done</td><td></td><td></td></tr></tbody></table><p>At initial step 0, the input stream "A*2 + 1" is divided into</p><ul><li>an empty section on the parse stack,</li><li>lookahead text "A" scanned as an <i>id</i> symbol, and</li><li>the remaining unscanned text "*2 + 1".</li></ul><p>The parse stack begins by holding only initial state 0.  When state 0 sees the lookahead <i>id</i>, it knows to shift that <i>id</i> onto the stack, and scan the next input symbol <b>*</b>, and advance to state 9.</p><hr style="width: 550px;" /><p>At step 4, the total input stream "A*2 + 1" is currently divided into </p><ul><li>the parsed section "A&#160;*" with 2 stacked phrases Products and <b>*</b>,</li><li>lookahead text "2" scanned as an <i>int</i> symbol, and</li><li>the remaining unscanned text " + 1".</li></ul><p>The states corresponding to the stacked phrases are 0, 4, and 5.  The current, rightmost state on the stack is state 5.  When state 5 sees the lookahead <i>int</i>, it knows to shift that <i>int</i> onto the stack as its own phrase, and scan the next input symbol <b>+</b>, and advance to state 8.</p><hr style="width: 550px;" /><p>At step 12, all of the input stream has been consumed but only partially organized.  The current state is 3.  When state 3 sees the lookahead <i>eof</i>, it knows to apply the completed grammar rule</p><dl><dd><dl><dd>Sums → Sums + Products</dd></dl></dd></dl><p>by combining the stack's rightmost three phrases for Sums, <b>+</b>, and Products into one thing.  State 3 itself doesn't know what the next state should be.  This is found by going back to state 0, just to the left of the phrase being reduced.  When state 0 sees this new completed instance of a Sums, it advances to state 1 (again).  This consulting of older states is why they are kept on the stack, instead of keeping only the current state.</p><h3><span id="Grammar_for_the_example_A.2A2_.2B_1"></span><span class="mw-headline" id="Grammar_for_the_example_A*2_+_1">Grammar for the example A*2 + 1</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=7" title="Edit section: Grammar for the example A*2 + 1">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>LR parsers are constructed from a grammar that formally defines the syntax of the input language as a set of patterns.  The grammar doesn't cover all language rules, such as the size of numbers, or the consistent use of names and their definitions in the context of the whole program.  LR parsers use a <a href="/wiki/Context-free_grammar" title="Context-free grammar">context-free grammar</a> that deals just with local patterns of symbols.</p><p>The example grammar used here is a tiny subset of the Java or C language:</p><dl><dd><dl><dd>r0: Goal → Sums <i>eof</i></dd><dd>r1: Sums → Sums + Products</dd><dd>r2: Sums → Products</dd><dd>r3: Products → Products * Value</dd><dd>r4: Products → Value</dd><dd>r5: Value → <i>int</i></dd><dd>r6: Value → <i>id</i></dd></dl></dd></dl><p>The grammar's <a href="/wiki/Terminal_symbol" class="mw-redirect" title="Terminal symbol">terminal symbols</a> are the multi-character symbols or 'tokens' found in the input stream by a <a href="/wiki/Lexical_analysis" title="Lexical analysis">lexical scanner</a>.  Here these include <b>+</b> <b>*</b> and <i>int</i> for any integer constant, and <i>id</i> for any identifier name, and <i>eof</i> for end of input file.  The grammar doesn't care what the <i>int</i> values or <i>id</i> spellings are, nor does it care about blanks or line breaks.  The grammar uses these terminal symbols but does not define them.  They are always leaf nodes (at the bottom bushy end) of the parse tree.</p><p>The capitalized terms like Sums are <a href="/wiki/Nonterminal_symbol" class="mw-redirect" title="Nonterminal symbol">nonterminal symbols</a>.  These are names for concepts or patterns in the language. They are defined in the grammar and never occur themselves in the input stream.  They are always internal nodes (above the bottom) of the parse tree. They only happen as a result of the parser applying some grammar rule.  Some nonterminals are defined with two or more rules; these are alternative patterns.  Rules can refer back to themselves, which are called <i>recursive</i>.  This grammar uses recursive rules to handle repeated math operators.  Grammars for complete languages use recursive rules to handle lists, parenthesized expressions, and nested statements.</p><p>Any given computer language can be described by several different grammars.  An LR(1) parser can handle many but not all common grammars.  It is usually possible to manually modify a grammar so that it fits the limitations of LR(1) parsing and the generator tool.</p><p>The grammar for an LR parser must be <a href="/wiki/Ambiguous_grammar" title="Ambiguous grammar">unambiguous</a> itself, or must be augmented by tie-breaking precedence rules.  This means there is only one correct way to apply the grammar to a given legal example of the language, resulting in a unique parse tree with just one meaning, and a unique sequence of shift/reduce actions for that example.  LR parsing is not a useful technique for human languages with ambiguous grammars that depend on the interplay of words.  Human languages are better handled by parsers like <a href="/wiki/Generalized_LR_parser" class="mw-redirect" title="Generalized LR parser">Generalized LR parser</a>, the <a href="/wiki/Earley_parser" title="Earley parser">Earley parser</a>, or the <a href="/wiki/CYK_algorithm" title="CYK algorithm">CYK algorithm</a> that can simultaneously compute all possible parse trees in one pass.</p><h3><span class="mw-headline" id="Parse_table_for_the_example_grammar">Parse table for the example grammar</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=8" title="Edit section: Parse table for the example grammar">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>Most LR parsers are table driven. The parser's program code is a simple generic loop that is the same for all grammars and languages. The knowledge of the grammar and its syntactic implications are encoded into unchanging data tables called <b>parse tables</b> (or <b>parsing tables</b>). Entries in a table show whether to shift or reduce (and by which grammar rule), for every legal combination of parser state and lookahead symbol.  The parse tables also tell how to compute the next state, given just a current state and a next symbol.</p><p>The parse tables are much larger than the grammar.  LR tables are hard to accurately compute by hand for big grammars.  So they are mechanically derived from the grammar by some <a href="/wiki/Parser_generator" class="mw-redirect" title="Parser generator">parser generator</a> tool like <a href="/wiki/GNU_Bison" title="GNU Bison">Bison</a>.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6">&#91;6&#93;</a></sup></p><p>Depending on how the states and parsing table are generated, the resulting parser is called either a <a href="/wiki/Simple_LR_parser" title="Simple LR parser"><b>SLR</b> (simple LR) parser</a>, <a href="/wiki/LALR_parser" title="LALR parser"><b>LALR</b> (look-ahead LR) parser</a>, or <a href="/wiki/Canonical_LR_parser" title="Canonical LR parser">canonical LR parser</a>. LALR parsers handle more grammars than SLR parsers. Canonical LR parsers handle even more grammars, but use many more states and much larger tables.  The example grammar is SLR.</p><p>LR parse tables are two-dimensional.  Each current LR(0) parser state has its own row.  Each possible next symbol has its own column.  Some combinations of state and next symbol are not possible for valid input streams.  These blank cells trigger syntax error messages.</p><p>The <b>Action</b> left half of the table has columns for lookahead terminal symbols.  These cells determine whether the next parser action is shift (to state <i>n</i>), or reduce (by grammar rule <b>r</b><sub>n</sub>).</p><p>The <b>Goto</b> right half of the table has columns for nonterminal symbols.  These cells show which state to advance to, after some reduction's Left Hand Side has created an expected new instance of that symbol.  This is like a shift action but for nonterminals; the lookahead terminal symbol is unchanged.</p><p>The table column "Current Rules" documents the meaning and syntax possibilities for each state, as worked out by the parser generator.  It is not included in the actual tables used at parsing time.  The <big><span style="color:#f7f">•</span></big> (pink dot) marker shows where the parser is now, within some partially recognized grammar rules.  The things to the left of <big><span style="color:#f7f">•</span></big> have been parsed, and the things to the right are expected soon.  A state has several such current rules if the parser has not yet narrowed possibilities down to a single rule.</p><table class="wikitable"><tbody><tr><th>Curr</th><th></th><th colspan="5">Lookahead</th><th></th><th colspan="3">LHS Goto</th></tr><tr><th>State</th><th>Current Rules</th><th><i>int</i></th><th><i>id</i></th><th>*  &#160;</th><th>+ &#160;</th><th><i>eof</i></th><th></th><th>Sums</th><th>Products</th><th>Value</th></tr><tr><td>0</td><td>Goal → <big><span style="color:#f7f">•</span></big> Sums <i>eof</i></td><td>8</td><td>9</td><td></td><td></td><td></td><td></td><td>1</td><td>4</td><td>7</td></tr><tr><td>1</td><td>Goal → Sums <big><span style="color:#f7f">•</span></big> <i>eof</i> <br /> Sums → Sums <big><span style="color:#f7f">•</span></big> + Products</td><td></td><td></td><td></td><td><br />2</td><td>done<br />&#160;</td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td>Sums → Sums + <big><span style="color:#f7f">•</span></big> Products</td><td>8</td><td>9</td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>7</td></tr><tr><td>3</td><td>Sums → Sums + Products <big><span style="color:#f7f">•</span></big> <br /> Products → Products <big><span style="color:#f7f">•</span></big> * Value</td><td></td><td></td><td><br />5</td><td>r1 <br />&#160;</td><td>r1 <br />&#160;</td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td>Sums → Products <big><span style="color:#f7f">•</span></big> <br /> Products → Products <big><span style="color:#f7f">•</span></big> * Value</td><td></td><td></td><td><br />5</td><td>r2 <br />&#160;</td><td>r2 <br />&#160;</td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>Products → Products * <big><span style="color:#f7f">•</span></big> Value</td><td>8</td><td>9</td><td></td><td></td><td></td><td></td><td></td><td></td><td>6</td></tr><tr><td>6</td><td>Products → Products * Value <big><span style="color:#f7f">•</span></big></td><td></td><td></td><td>r3</td><td>r3</td><td>r3</td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>Products → Value <big><span style="color:#f7f">•</span></big></td><td></td><td></td><td>r4</td><td>r4</td><td>r4</td><td></td><td></td><td></td><td></td></tr><tr><td>8</td><td>Value → <i>int</i> <big><span style="color:#f7f">•</span></big></td><td></td><td></td><td>r5</td><td>r5</td><td>r5</td><td></td><td></td><td></td><td></td></tr><tr><td>9</td><td>Value → <i>id</i> <big><span style="color:#f7f">•</span></big></td><td></td><td></td><td>r6</td><td>r6</td><td>r6</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>In state 2 above, the parser has just found and shifted-in the <b>+</b> of grammar rule</p><dl><dd><dl><dd>r1: Sums → Sums + <big><span style="color:#f7f">•</span></big> Products</dd></dl></dd></dl><p>The next expected phrase is Products.  Products begins with terminal symbols <i>int</i> or <i>id</i>.  If the lookahead is either of those, the parser shifts them in and advances to state 8 or 9, respectively.  When a Products has been found, the parser advances to state 3 to accumulate the complete list of summands and find the end of rule r0.  A Products can also begin with nonterminal  Value.  For any other lookahead or nonterminal, the parser announces a syntax error.</p><hr style="width: 550px;" /><p>In state 3, the parser has just found a Products phrase, that could be from two possible grammar rules:</p><dl><dd><dl><dd>r1: Sums → Sums + Products <big><span style="color:#f7f">•</span></big></dd><dd>r3: Products → Products <big><span style="color:#f7f">•</span></big> * Value</dd></dl></dd></dl><p>The choice between r1 and r3 can't be decided just from looking backwards at prior phrases.  The parser has to check the lookahead symbol to tell what to do.  If the lookahead is <b>*</b>, it is in rule 3, so the parser shifts in the <b>*</b> and advances to state 5.  If the lookahead is <i>eof</i>, it is at the end of rule 1 and rule 0, so the parser is done.</p><hr style="width: 550px;" /><p>In state 9 above, all the non-blank, non-error cells are for the same reduction r6.  Some parsers save time and table space by not checking the lookahead symbol in these simple cases.  Syntax errors are then detected somewhat later, after some harmless reductions, but still before the next shift action or parser decision.</p><p>Individual table cells must not hold multiple, alternative actions, otherwise the parser would be nondeterministic with guesswork and backtracking.  If the grammar is not LR(1), some cells will have shift/reduce conflicts between a possible shift action and reduce action, or reduce/reduce conflicts between multiple grammar rules.  LR(k) parsers resolve these conflicts (where possible) by checking additional lookahead symbols beyond the first.</p><h3><span class="mw-headline" id="LR_parser_loop">LR parser loop</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=9" title="Edit section: LR parser loop">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>The LR parser begins with a nearly empty parse stack containing just the start state 0, and with the lookahead holding the input stream's first scanned symbol.  The parser then repeats the following loop step until done, or stuck on a syntax error:</p><p>The topmost state on the parse stack is some state <i>s</i>, and the current lookahead is some terminal symbol <i>t</i>.  Look up the next parser action from row <i>s</i> and column <i>t</i> of the Lookahead Action table.  That action is either Shift, Reduce, Done, or Error:</p><ul><li>Shift <i>n</i>:</li></ul><dl><dd><dl><dd>Shift the matched terminal <i>t</i> onto the parse stack and scan the next input symbol into the lookahead buffer.</dd><dd>Push next state <i>n</i> onto the parse stack as the new current state.</dd></dl></dd></dl><ul><li>Reduce r<sub>m</sub>:  Apply grammar rule r<sub>m</sub>: Lhs → S<sub>1</sub> S<sub>2</sub> ... S<sub>L</sub></li></ul><dl><dd><dl><dd>Remove the matched topmost L symbols (and parse trees and associated state numbers) from the parse stack.</dd><dd>This exposes a prior state <i>p</i> that was expecting an instance of the Lhs symbol.</dd><dd>Join the L parse trees together as one parse tree with new root symbol Lhs.</dd><dd>Lookup the next state <i>n</i> from row <i>p</i> and column <i>Lhs</i> of the LHS Goto table.</dd><dd>Push the symbol and tree for Lhs onto the parse stack.</dd><dd>Push next state <i>n</i> onto the parse stack as the new current state.</dd><dd>The lookahead and input stream remain unchanged.</dd></dl></dd></dl><ul><li>Done: Lookahead <i>t</i> is the <i>eof</i> marker.  End of parsing. If the state stack contains just the start state report success. Otherwise, report a syntax error.</li><li>Error: Report a syntax error.  The parser ends, or attempts some recovery.</li></ul><p>LR parser stack usually stores just the LR(0) automaton states, as the grammar symbols may be derived from them (in the automaton, all input transitions to some state are marked with the same symbol, which is the symbol associated with this state). Moreover, these symbols are almost never needed as the state is all that matters when making the parsing decision.<sup id="cite_ref-Compilers_2006_7-0" class="reference"><a href="#cite_note-Compilers_2006-7">&#91;7&#93;</a></sup></p><h2><span class="mw-headline" id="LR_generator_analysis">LR generator analysis</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=10" title="Edit section: LR generator analysis">edit</a><span class="mw-editsection-bracket">]</span></span></h2><p>This section of the article can be skipped by most users of LR parser generators.</p><h3><span class="mw-headline" id="LR_states">LR states</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=11" title="Edit section: LR states">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>State 2 in the example parse table is for the partially parsed rule </p><dl><dd><dl><dd>r1: Sums → Sums + <big><span style="color:#f7f">•</span></big> Products</dd></dl></dd></dl><p>This shows how the parser got here, by seeing Sums then <b>+</b> while looking for a larger Sums.  The <big><span style="color:#f7f">•</span></big> marker has advanced beyond the beginning of the rule.  It also shows how the parser expects to eventually complete the rule, by next finding a complete Products.  But more details are needed on how to parse all the parts of that Products.</p><p>The partially parsed rules for a state are called its "core LR(0) items".  The parser generator adds additional rules or items for all the possible next steps in building up the expected Products:</p><dl><dd><dl><dd>r3: Products → <big><span style="color:#f7f">•</span></big> Products * Value</dd><dd>r4: Products → <big><span style="color:#f7f">•</span></big> Value</dd><dd>r5: Value → <big><span style="color:#f7f">•</span></big> <i>int</i></dd><dd>r6: Value → <big><span style="color:#f7f">•</span></big> <i>id</i></dd></dl></dd></dl><p>The <big><span style="color:#f7f">•</span></big> marker is at the beginning of each of these added rules; the parser has not yet confirmed and parsed any part of them.  These additional items are called the "closure" of the core items. For each nonterminal symbol immediately following a <big><span style="color:#f7f">•</span></big>, the generator adds the rules defining that symbol.  This adds more <big><span style="color:#f7f">•</span></big> markers, and possibly different follower symbols.  This closure process continues until all follower symbols have been expanded.  The follower nonterminals for state 2 begins with Products.  Value is then added by closure. The follower terminals are <i>int</i> and <i>id</i>.</p><p>The kernel and closure items together show all possible legal ways to proceed from the current state to future states and complete phrases.  If a follower symbol appears in only one item, it leads to a next state containing only one core item with the <big><span style="color:#f7f">•</span></big> marker advanced.  So <i>int</i> leads to next state 8 with core</p><dl><dd><dl><dd>r5: Value → <i>int</i> <big><span style="color:#f7f">•</span></big></dd></dl></dd></dl><p>If the same follower symbol appears in several items, the parser cannot yet tell which rule applies here.  So that symbol leads to a next state that shows all remaining possibilities, again with the <big><span style="color:#f7f">•</span></big> marker advanced.  Products appears in both r1 and r3.  So Products leads to next state 3 with core</p><dl><dd><dl><dd>r1: Sums → Sums + Products <big><span style="color:#f7f">•</span></big></dd><dd>r3: Products → Products <big><span style="color:#f7f">•</span></big> * Value</dd></dl></dd></dl><p>In words, that means if the parser has seen a single Products, it might be done, or it might still have even more things to multiply together. All the core items have the same symbol preceding the <big><span style="color:#f7f">•</span></big> marker; all transitions into this state are always with that same symbol.</p><p>Some transitions will be to cores and states that have been enumerated already.  Other transitions lead to new states.  The generator starts with the grammar's goal rule.  From there it keeps exploring known states and transitions until all needed states have been found.</p><p>These states are called "LR(0)" states because they use a lookahead of <i>k</i>=0, i.e. no lookahead.  The only checking of input symbols occurs when the symbol is shifted in.  Checking of lookaheads for reductions is done separately by the parse table, not by the enumerated states themselves.</p><h3><span class="mw-headline" id="Finite_state_machine">Finite state machine</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=12" title="Edit section: Finite state machine">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>The parse table describes all possible LR(0) states and their transitions.  They form a <a href="/wiki/Finite_state_automaton" class="mw-redirect" title="Finite state automaton">finite state machine</a> (FSM).  An FSM is a simple engine for parsing simple unnested languages, without using a stack.  In this LR application, the FSM's modified "input language" has both terminal and nonterminal symbols, and covers any partially parsed stack snapshot of the full LR parse.</p><p>Recall step 5 of the Parse Steps Example:</p><table class="wikitable"><tbody><tr><th><small><br />Step</small></th><th><small>Parse Stack<br /><sub><span style="color:#928">state</span></sub> Symbol <sub><span style="color:#928">state</span></sub> ...</small></th><th><small>Look<br />Ahead</small></th><th><small><br />Unscanned</small></th></tr><tr><td>5</td><td><p><sub><span style="color:#928">0</span></sub> Products<sub><span style="color:#928">4</span></sub> *<sub><span style="color:#928">5</span></sub><i>int</i><sub><span style="color:#928">8</span></sub> </p></td><td>+</td><td align="right">1</td></tr></tbody></table><p>The parse stack shows a series of state transitions, from the start state 0, to state 4 and then on to 5 and current state 8.  The symbols on the parse stack are the shift or goto symbols for those transitions.  Another way to view this, is that the finite state machine can scan the stream "Products&#160;*&#160;<i>int</i>&#160;+&#160;1" (without using yet another stack) and find the leftmost complete phrase that should be reduced next.  And that is indeed its job!</p><p>How can a mere FSM do this when the original unparsed language has nesting and recursion and definitely requires an analyzer with a stack?  The trick is that everything to the left of the stack top has already been fully reduced.  This eliminates all the loops and nesting from those phrases.  The FSM can ignore all the older beginnings of phrases, and track just the newest phrases that might be completed next.  The obscure name for this in LR theory is "viable prefix."</p><h3><span class="mw-headline" id="Lookahead_sets">Lookahead sets</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=13" title="Edit section: Lookahead sets">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>The states and transitions give all the needed information for the parse table's shift actions and goto actions.  The generator also needs to calculate the expected lookahead sets for each reduce action.</p><p>In <b>SLR</b> parsers, these lookahead sets are determined directly from the grammar, without considering the individual states and transitions.  For each nonterminal S, the SLR generator works out Follows(S), the set of all the terminal symbols which can immediately follow some occurrence of S.  In the parse table, each reduction to S uses Follow(S) as its LR(1) lookahead set.  Such follow sets are also used by generators for LL top-down parsers.  A grammar that has no shift/reduce or reduce/reduce conflicts when using Follow sets is called an SLR grammar.</p><p><b>LALR</b> parsers have the same states as SLR parsers, but use a more complicated, more precise way of working out the minimum necessary reduction lookaheads for each individual state.  Depending on the details of the grammar, this may turn out to be the same as the Follow set computed by SLR parser generators, or it may turn out to be a subset of the SLR lookaheads.  Some grammars are okay for LALR parser generators but not for SLR parser generators.  This happens when the grammar has spurious shift/reduce or reduce/reduce conflicts using Follow sets, but no conflicts when using the exact sets computed by the LALR generator.  The grammar is then called LALR(1) but not SLR.</p><p>An SLR or LALR parser avoids having duplicate states.  But this minimization is not necessary, and can sometimes create unnecessary lookahead conflicts.  <b>Canonical LR</b> parsers use duplicated (or "split") states to better remember the left and right context of a nonterminal's use. Each occurrence of a symbol S in the grammar can be treated independently with its own lookahead set, to help resolve reduction conflicts.  This handles a few more grammars.  Unfortunately, this greatly magnifies the size of the parse tables if done for all parts of the grammar.  This splitting of states can also be done manually and selectively with any SLR or LALR parser, by making two or more named copies of some nonterminals.  A grammar that is conflict-free for a canonical LR generator but has conflicts in an LALR generator is called LR(1) but not LALR(1), and not SLR.</p><p>SLR, LALR, and canonical LR parsers make exactly the same shift and reduce decisions when the input stream is correct language.  When the input has a syntax error, the LALR parser may do some additional (harmless) reductions before detecting the error than would the canonical LR parser.  And the SLR parser may do even more.  This happens because the SLR and LALR parsers are using a generous superset approximation to the true, minimal lookahead symbols for that particular state.</p><h3><span class="mw-headline" id="Syntax_error_recovery">Syntax error recovery</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=14" title="Edit section: Syntax error recovery">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>LR parsers can generate somewhat helpful error messages for the first syntax error in a program, by simply enumerating all the terminal symbols that could have appeared next instead of the unexpected bad lookahead symbol.  But this does not help the parser work out how to parse the remainder of the input program to look for further, independent errors.  If the parser recovers badly from the first error, it is very likely to mis-parse everything else and produce a cascade of unhelpful spurious error messages.</p><p>In the <a href="/wiki/Yacc" title="Yacc">yacc</a> and bison parser generators, the parser has an ad hoc mechanism to abandon the current statement, discard some parsed phrases and lookahead tokens surrounding the error, and resynchronize the parse at some reliable statement-level delimiter like semicolons or braces.  This often works well for allowing the parser and compiler to look over the rest of the program.</p><p>Many syntactic coding errors are simple typos or omissions of a trivial symbol.  Some LR parsers attempt to detect and automatically repair these common cases.  The parser enumerates every possible single-symbol insertion, deletion, or substitution at the error point.  The compiler does a trial parse with each change to see if it worked okay.  (This requires backtracking to snapshots of the parse stack and input stream, normally unneeded by the parser.)  Some best repair is picked.  This gives a very helpful error message and resynchronizes the parse well.  However, the repair is not trustworthy enough to permanently modify the input file.  Repair of syntax errors is easiest to do consistently in parsers (like LR) that have parse tables and an explicit data stack.</p><h3><span class="mw-headline" id="Variants_of_LR_parsers">Variants of LR parsers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=15" title="Edit section: Variants of LR parsers">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>The LR parser generator decides what should happen for each combination of parser state and lookahead symbol.  These decisions are usually turned into read-only data tables that drive a generic parser loop that is grammar- and state-independent.  But there are also other ways to turn those decisions into an active parser.</p><p>Some LR parser generators create separate tailored program code for each state, rather than a parse table.  These parsers can run several times faster than the generic parser loop in table-driven parsers.  The fastest parsers use generated assembler code.</p><p>In the <a href="/wiki/Recursive_ascent_parser" title="Recursive ascent parser">recursive ascent parser</a> variation, the explicit parse stack structure is also replaced by the implicit stack used by subroutine calls.  Reductions terminate several levels of subroutine calls, which is clumsy in most languages.  So recursive ascent parsers are generally slower, less obvious, and harder to hand-modify than <a href="/wiki/Recursive_descent_parser" title="Recursive descent parser">recursive descent parsers</a>.</p><p>Another variation replaces the parse table by pattern-matching rules in non-procedural languages such as <a href="/wiki/Prolog" title="Prolog">Prolog</a>.</p><p><b>GLR</b> <a href="/wiki/Generalized_LR_parser" class="mw-redirect" title="Generalized LR parser">Generalized LR parsers</a> use LR bottom-up techniques to find all possible parses of input text, not just one correct parse.   This is essential for ambiguous grammars such as used for human languages.  The multiple valid parse trees are computed simultaneously, without backtracking.  GLR is sometimes helpful for computer languages that are not easily described by a conflict-free LALR(1) grammar.</p><p><b>LC</b> <a href="/wiki/Left_corner_parser" title="Left corner parser">Left corner parsers</a> use LR bottom-up techniques for recognizing the left end of alternative grammar rules.  When the alternatives have been narrowed down to a single possible rule, the parser then switches to top-down LL(1) techniques for parsing the rest of that rule.  LC parsers have smaller parse tables than LALR parsers and better error diagnostics.  There are no widely used generators for deterministic LC parsers.  Multiple-parse LC parsers are helpful with human languages with very large grammars.</p><h3><span class="mw-headline" id="Theory">Theory</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=16" title="Edit section: Theory">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>LR parsers were invented by <a href="/wiki/Donald_Knuth" title="Donald Knuth">Donald Knuth</a> in 1965 as an efficient generalization of <a href="/wiki/Simple_precedence_parser" title="Simple precedence parser">precedence parsers</a>.  Knuth proved that LR parsers were the most general-purpose parsers possible that would still be efficient in the worst cases.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">&#91;<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (September 2019)">citation needed</span></a></i>&#93;</sup>  </p><dl><dd>"LR(<i>k</i>) grammars can be efficiently parsed with an execution time essentially proportional to the length of the string."<sup id="cite_ref-8" class="reference"><a href="#cite_note-8">&#91;8&#93;</a></sup></dd><dd>For every <i>k</i>≥1, "a language can be generated by an LR(<i>k</i>) grammar if and only if it is deterministic [and context-free], if and only if it can be generated by an LR(1) grammar."<sup id="cite_ref-9" class="reference"><a href="#cite_note-9">&#91;9&#93;</a></sup></dd></dl><p>In other words, if a language was reasonable enough to allow an efficient one-pass parser, it could be described by an LR(<i>k</i>) grammar.  And that grammar could always be mechanically transformed into an equivalent (but larger) LR(1) grammar.  So an LR(1) parsing method was, in theory, powerful enough to handle any reasonable language.  In practice, the natural grammars for many programming languages are close to being LR(1).<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">&#91;<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (June 2012)">citation needed</span></a></i>&#93;</sup></p><p>The canonical LR parsers described by Knuth had too many states and very big parse tables that were impractically large for the limited memory of computers of that era.  LR parsing became practical when <a href="/w/index.php?title=Frank_DeRemer&amp;action=edit&amp;redlink=1" class="new" title="Frank DeRemer (page does not exist)">Frank DeRemer</a> invented <a href="/wiki/Simple_LR_parser" title="Simple LR parser">SLR</a> and <a href="/wiki/LALR" class="mw-redirect" title="LALR">LALR</a> parsers with much fewer states.<sup id="cite_ref-10" class="reference"><a href="#cite_note-10">&#91;10&#93;</a></sup><sup id="cite_ref-11" class="reference"><a href="#cite_note-11">&#91;11&#93;</a></sup></p><p>For full details on LR theory and how LR parsers are derived from grammars, see <i>The Theory of Parsing, Translation, and Compiling, Volume 1</i> (Aho and Ullman).<sup id="cite_ref-Compilers_2006_7-1" class="reference"><a href="#cite_note-Compilers_2006-7">&#91;7&#93;</a></sup><sup id="cite_ref-AhoUllman_1972_2-1" class="reference"><a href="#cite_note-AhoUllman_1972-2">&#91;2&#93;</a></sup></p><p><a href="/wiki/Earley_parser" title="Earley parser">Earley parsers</a> apply the techniques and <big><span style="color:#f7f">•</span></big> notation of LR parsers to the task of generating all possible parses for ambiguous grammars such as for human languages.</p><p>While LR(<i>k</i>) grammars have equal generative power for all <i>k</i>≥1, the case of LR(0) grammars is slightly different.A language <i>L</i> is said to have the <i>prefix property</i> if no word in <i>L</i> is a <a href="/wiki/Prefix_(formal_languages)" class="mw-redirect" title="Prefix (formal languages)">proper prefix</a> of another word in <i>L</i>.<sup id="cite_ref-12" class="reference"><a href="#cite_note-12">&#91;12&#93;</a></sup>A language <i>L</i> has an LR(0) grammar if and only if <i>L</i> is a <a href="/wiki/Deterministic_context-free_language" title="Deterministic context-free language">deterministic context-free language</a> with the prefix property.<sup id="cite_ref-13" class="reference"><a href="#cite_note-13">&#91;13&#93;</a></sup>As a consequence, a language <i>L</i> is deterministic context-free if and only if <a href="/wiki/Concatenation#Concatenation_of_sets_of_strings" title="Concatenation"><i>L</i>$</a> has an LR(0) grammar, where "$" is not a symbol of <i>L</i>’s <a href="/wiki/Alphabet_(formal_languages)" title="Alphabet (formal languages)">alphabet</a>.<sup id="cite_ref-14" class="reference"><a href="#cite_note-14">&#91;14&#93;</a></sup></p><h2><span id="Additional_example_1.2B1"></span><span class="mw-headline" id="Additional_example_1+1">Additional example 1+1</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=17" title="Edit section: Additional example 1+1">edit</a><span class="mw-editsection-bracket">]</span></span></h2><div class="thumb tright"><div class="thumbinner" style="width:327px;"><a href="/wiki/File:LR_Parser.png" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/2/2b/LR_Parser.png" decoding="async" width="325" height="278" class="thumbimage" data-file-width="325" data-file-height="278" /></a>  <div class="thumbcaption">Bottom-up parse of 1+1</div></div></div><p>This example of LR parsing uses the following small grammar with goal symbol E:</p><dl><dd>(1)   E → E * B</dd><dd>(2)   E → E + B</dd><dd>(3)   E → B</dd><dd>(4)   B → 0</dd><dd>(5)   B → 1</dd></dl><p>to parse the following input:</p><dl><dd><b>1 + 1</b></dd></dl><h3><span class="mw-headline" id="Action_and_goto_tables">Action and goto tables</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=18" title="Edit section: Action and goto tables">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>The two LR(0) parsing tables for this grammar look as follows:</p><table class="wikitable"><tbody><tr style="text-align:center; background:#e0e0e0;"><td><i><b>state</b></i></td><td colspan="5"><i><b>action</b></i></td><td colspan="2"><i><b>goto</b></i></td></tr><tr style="text-align:center;"><td style="width:12%;">&#160;</td><td style="width:11%; background:#d0e0ff;"><b>*</b></td><td style="width:11%; background:#d0e0ff;"><b>+</b></td><td style="width:11%; background:#d0e0ff;"><b>0</b></td><td style="width:11%; background:#d0e0ff;"><b>1</b></td><td style="width:11%; background:#d0e0ff;"><b>$</b></td><td style="width:11%; background:#c0e0d0;"><b>E</b></td><td style="width:11%; background:#c0e0d0;"><b>B</b></td></tr><tr style="text-align:center;"><td><b>0</b></td><td>&#160;</td><td>&#160;</td><td>s1</td><td>s2</td><td>&#160;</td><td>3</td><td>4</td></tr><tr style="text-align:center;"><td><b>1</b></td><td>r4</td><td>r4</td><td>r4</td><td>r4</td><td>r4</td><td>&#160;</td><td>&#160;</td></tr><tr style="text-align:center;"><td><b>2</b></td><td>r5</td><td>r5</td><td>r5</td><td>r5</td><td>r5</td><td>&#160;</td><td>&#160;</td></tr><tr style="text-align:center;"><td><b>3</b></td><td>s5</td><td>s6</td><td>&#160;</td><td>&#160;</td><td>acc</td><td>&#160;</td><td>&#160;</td></tr><tr style="text-align:center;"><td><b>4</b></td><td>r3</td><td>r3</td><td>r3</td><td>r3</td><td>r3</td><td>&#160;</td><td>&#160;</td></tr><tr style="text-align:center;"><td><b>5</b></td><td>&#160;</td><td>&#160;</td><td>s1</td><td>s2</td><td>&#160;</td><td>&#160;</td><td>7</td></tr><tr style="text-align:center;"><td><b>6</b></td><td>&#160;</td><td>&#160;</td><td>s1</td><td>s2</td><td>&#160;</td><td>&#160;</td><td>8</td></tr><tr style="text-align:center;"><td><b>7</b></td><td>r1</td><td>r1</td><td>r1</td><td>r1</td><td>r1</td><td>&#160;</td><td>&#160;</td></tr><tr style="text-align:center;"><td><b>8</b></td><td>r2</td><td>r2</td><td>r2</td><td>r2</td><td>r2</td><td>&#160;</td><td>&#160;</td></tr></tbody></table><p>The <b>action table</b> is indexed by a state of the parser and a terminal (including a special terminal $ that indicates the end of the input stream) and contains three types of actions:</p><ul><li><i>shift</i>, which is written as 's<i>n</i>&#39; and indicates that the next state is <i>n</i></li><li><i>reduce</i>, which is written as 'r<i>m</i>&#39; and indicates that a reduction with grammar rule <i>m</i> should be performed</li><li><i>accept</i>, which is written as 'acc' and indicates that the parser accepts the string in the input stream.</li></ul><p>The <b>goto table</b> is indexed by a state of the parser and a nonterminal and simply indicates what the next state of the parser will be if it has recognized a certain nonterminal. This table is important to find out the next state after every reduction. After a reduction, the next state is found by looking up the <b>goto table</b> entry for top of the stack (i.e. current state) and the reduced rule's LHS (i.e. non-terminal).</p><h3><span class="mw-headline" id="Parsing_steps">Parsing steps</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=19" title="Edit section: Parsing steps">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>The table below illustrates each step in the process. Here the state refers to the element at the top of the stack (the right-most element), and the next action is determined by referring to the action table above. A $ is appended to the input string to denote the end of the stream.</p><table class="wikitable"><tbody><tr><th>State</th><th>Input stream</th><th>Output stream</th><th>Stack</th><th>Next action</th></tr><tr><td>0</td><td>1+1$</td><td></td><td>[0]</td><td>Shift 2</td></tr><tr><td>2</td><td>+1$</td><td></td><td>[0,2]</td><td>Reduce 5</td></tr><tr><td>4</td><td>+1$</td><td>5</td><td>[0,4]</td><td>Reduce 3</td></tr><tr><td>3</td><td>+1$</td><td>5,3</td><td>[0,3]</td><td>Shift 6</td></tr><tr><td>6</td><td>1$</td><td>5,3</td><td>[0,3,6]</td><td>Shift 2</td></tr><tr><td>2</td><td>$</td><td>5,3</td><td>[0,3,6,2]</td><td>Reduce 5</td></tr><tr><td>8</td><td>$</td><td>5,3,5</td><td>[0,3,6,8]</td><td>Reduce 2</td></tr><tr><td>3</td><td>$</td><td>5,3,5,2</td><td>[0,3]</td><td>Accept</td></tr></tbody></table><h3><span class="mw-headline" id="Walkthrough">Walkthrough</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=20" title="Edit section: Walkthrough">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>The parser starts out with the stack containing just the initial state ('0'):</p><dl><dd>[<b>0</b>]</dd></dl><p>The first symbol from the input string that the parser sees is '1'. To find the next action (shift, reduce, accept or error), the action table is indexed with the current state (the "current state" is just whatever is on the top of the stack), which in this case is 0, and the current input symbol, which is '1'. The action table specifies a shift to state 2, and so state 2 is pushed onto the stack (again, all the state information is in the stack, so "shifting to state 2" is the same as pushing 2 onto the stack). The resulting stack is</p><dl><dd>[<b>0</b> '1' <b>2</b>]</dd></dl><p>where the top of the stack is 2. For the sake of explanation the symbol (e.g., '1', B) is shown that caused the transition to the next state, although strictly speaking it is not part of the stack.</p><p>In state 2, the action table says to reduce with grammar rule 5 (regardless of what terminal the parser sees on the input stream), which means that the parser has just recognized the right-hand side of rule 5. In this case, the parser writes 5 to the output stream, pops one state from the stack (since the right-hand side of the rule has one symbol), and pushes on the stack the state from the cell in the goto table for state 0 and B, i.e., state 4. The resulting stack is:</p><dl><dd>[<b>0</b> B <b>4</b>]</dd></dl><p>However, in state 4, the action table says the parser should now reduce with rule 3. So it writes 3 to the output stream, pops one state from the stack, and finds the new state in the goto table for state 0 and E, which is state 3. The resulting stack:</p><dl><dd>[<b>0</b> E <b>3</b>]</dd></dl><p>The next terminal that the parser sees is a '+' and according to the action table it should then go to state 6:</p><dl><dd>[<b>0</b> E <b>3</b> '+' <b>6</b>]</dd></dl><p>The resulting stack can be interpreted as the history of a <a href="/wiki/Finite_state_automaton" class="mw-redirect" title="Finite state automaton">finite state automaton</a> that has just read a nonterminal E followed by a terminal '+'. The transition table of this automaton is defined by the shift actions in the action table and the goto actions in the goto table.</p><p>The next terminal is now '1' and this means that the parser performs a shift and go to state 2:</p><dl><dd>[<b>0</b> E <b>3</b> '+' <b>6</b> '1' <b>2</b>]</dd></dl><p>Just as the previous '1' this one is reduced to B giving the following stack:</p><dl><dd>[<b>0</b> E <b>3</b> '+' <b>6</b> B <b>8</b>]</dd></dl><p>The stack corresponds with a list of states of a finite automaton that has read a nonterminal E, followed by a '+' and then a nonterminal B. In state 8 the parser always performs a reduce with rule 2. The top 3 states on the stack correspond with the 3 symbols in the right-hand side of rule 2. This time we pop 3 elements off of the stack (since the right-hand side of the rule has 3 symbols) and look up the goto state for E and 0, thus pushing state 3 back onto the stack</p><dl><dd>[<b>0</b> E <b>3</b>]</dd></dl><p>Finally, the parser reads a '$' (end of input symbol) from the input stream, which means that according to the action table (the current state is 3) the parser accepts the input string. The rule numbers that will then have been written to the output stream will be [5, 3, 5, 2] which is indeed a <a href="/wiki/Rightmost_derivation" class="mw-redirect" title="Rightmost derivation">rightmost derivation</a> of the string "1 + 1" in reverse.</p><h2><span id="Constructing_LR.280.29_parsing_tables"></span><span class="mw-headline" id="Constructing_LR(0)_parsing_tables">Constructing LR(0) parsing tables</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=21" title="Edit section: Constructing LR(0) parsing tables">edit</a><span class="mw-editsection-bracket">]</span></span></h2><h3><span class="mw-headline" id="Items">Items</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=22" title="Edit section: Items">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>The construction of these parsing tables is based on the notion of <i>LR(0) items</i> (simply called <i>items</i> here) which are grammar rules with a special dot added somewhere in the right-hand side. For example, the rule E → E + B has the following four corresponding items:</p><dl><dd>E → <big><span style="color:#f7f">•</span></big> E + B</dd><dd>E → E <big><span style="color:#f7f">•</span></big> + B</dd><dd>E → E + <big><span style="color:#f7f">•</span></big> B</dd><dd>E → E + B <big><span style="color:#f7f">•</span></big></dd></dl><p>Rules of the form <i>A</i> → ε have only a single item <i>A</i> → <big><span style="color:#f7f">•</span></big>. The item E → E <big><span style="color:#f7f">•</span></big> + B, for example, indicates that the parser has recognized a string corresponding with E on the input stream and now expects to read a '+' followed by another string corresponding with B.</p><h3><span class="mw-headline" id="Item_sets">Item sets</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=23" title="Edit section: Item sets">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>It is usually not possible to characterize the state of the parser with a single item because it may not know in advance which rule it is going to use for reduction. For example, if there is also a rule E → E * B then the items E → E <big><span style="color:#f7f">•</span></big> + B and E → E <big><span style="color:#f7f">•</span></big> * B will both apply after a string corresponding with E has been read. Therefore, it is convenient to characterize the state of the parser by a set of items, in this case the set { E → E <big><span style="color:#f7f">•</span></big> + B, E → E <big><span style="color:#f7f">•</span></big> * B }.</p><h3><span class="mw-headline" id="Extension_of_Item_Set_by_expansion_of_non-terminals">Extension of Item Set by expansion of non-terminals</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=24" title="Edit section: Extension of Item Set by expansion of non-terminals">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>An item with a dot before a nonterminal, such as E → E + <big><span style="color:#f7f">•</span></big> B, indicates that the parser expects to parse the nonterminal B next.  To ensure the item set contains all possible rules the parser may be in the midst of parsing, it must include all items describing how B itself will be parsed.  This means that if there are rules such as B → 1 and B → 0 then the item set must also include the items B → <big><span style="color:#f7f">•</span></big> 1 and B → <big><span style="color:#f7f">•</span></big> 0. In general this can be formulated as follows:</p><dl><dd>If there is an item of the form <i>A</i> → <i>v</i> <big><span style="color:#f7f">•</span></big> <i>Bw</i> in an item set and in the grammar there is a rule of the form <i>B</i> → <i>w' </i> then the item <i>B</i> → <big><span style="color:#f7f">•</span></big> <i>w' </i> should also be in the item set.</dd></dl><h3><span class="mw-headline" id="Closure_of_item_sets">Closure of item sets</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=25" title="Edit section: Closure of item sets">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>Thus, any set of items can be extended by recursively adding all the appropriate items until all nonterminals preceded by dots are accounted for. The minimal extension is called the <i>closure</i> of an item set and written as <b>clos</b>(<i>I</i>) where <i>I</i> is an item set. It is these closed item sets that are taken as the states of the parser, although only the ones that are actually reachable from the begin state will be included in the tables.</p><h3><span class="mw-headline" id="Augmented_grammar">Augmented grammar</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=26" title="Edit section: Augmented grammar">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>Before the transitions between the different states are determined, the grammar is augmented with an extra rule</p><dl><dd>(0) S → E eof</dd></dl><p>where S is a new start symbol and E the old start symbol. The parser will use this rule for reduction exactly when it has accepted the whole input string.</p><p>For this example, the same grammar as above is augmented thus:</p><dl><dd>(0) S → E eof</dd><dd>(1) E → E * B</dd><dd>(2) E → E + B</dd><dd>(3) E → B</dd><dd>(4) B → 0</dd><dd>(5) B → 1</dd></dl><p>It is for this augmented grammar that the item sets and the transitions between them will be determined.</p><h2><span class="mw-headline" id="Table_construction">Table construction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=27" title="Edit section: Table construction">edit</a><span class="mw-editsection-bracket">]</span></span></h2><h3><span class="mw-headline" id="Finding_the_reachable_item_sets_and_the_transitions_between_them">Finding the reachable item sets and the transitions between them</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=28" title="Edit section: Finding the reachable item sets and the transitions between them">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>The first step of constructing the tables consists of determining the transitions between the closed item sets. These transitions will be determined as if we are considering a finite automaton that can read terminals as well as nonterminals. The begin state of this automaton is always the closure of the first item of the added rule: S → <big><span style="color:#f7f">•</span></big> E:</p><dl><dd><b>Item set 0</b></dd><dd>S → <big><span style="color:#f7f">•</span></big> E eof</dd><dd><b>+</b> E → <big><span style="color:#f7f">•</span></big> E * B</dd><dd><b>+</b> E → <big><span style="color:#f7f">•</span></big> E + B</dd><dd><b>+</b> E → <big><span style="color:#f7f">•</span></big> B</dd><dd><b>+</b> B → <big><span style="color:#f7f">•</span></big> 0</dd><dd><b>+</b> B → <big><span style="color:#f7f">•</span></big> 1</dd></dl><p>The <a href="/wiki/Boldface" class="mw-redirect" title="Boldface">boldfaced</a> "<b>+</b>" in front of an item indicates the items that were added for the closure (not to be confused with the mathematical '+' operator which is a terminal). The original items without a "<b>+</b>" are called the <i>kernel</i> of the item set.</p><p>Starting at the begin state (S0), all of the states that can be reached from this state are now determined. The possible transitions for an item set can be found by looking at the symbols (terminals and nonterminals) found following the dots; in the case of item set 0 those symbols are the terminals '0' and '1' and the nonterminals E and B. To find the item set that each symbol <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\textstyle x\in \{0,1,E,B\}}">  <semantics>    <mrow class="MJX-TeXAtom-ORD">      <mstyle displaystyle="false" scriptlevel="0">        <mi>x</mi>        <mo>&#x2208;<!-- ∈ --></mo>        <mo fence="false" stretchy="false">{</mo>        <mn>0</mn>        <mo>,</mo>        <mn>1</mn>        <mo>,</mo>        <mi>E</mi>        <mo>,</mo>        <mi>B</mi>        <mo fence="false" stretchy="false">}</mo>      </mstyle>    </mrow>    <annotation encoding="application/x-tex">{\textstyle x\in \{0,1,E,B\}}</annotation>  </semantics></math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ff417be1e2937f56fd61b045e3faea6ff39d9e3e" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:15.462ex; height:2.843ex;" alt="{\textstyle x\in \{0,1,E,B\}}"/></span>leads to,  the following procedure is followed for each of the symbols:</p><ol><li>Take the subset, <i>S</i>, of all items in the current item set where there is a dot in front of the symbol of interest, <i>x</i>.</li><li>For each item in <i>S</i>, move the dot to the right of <i>x</i>.</li><li>Close the resulting set of items.</li></ol><p>For the terminal '0' (i.e. where x = '0') this results in:</p><dl><dd><b>Item set 1</b></dd><dd>B → 0 <big><span style="color:#f7f">•</span></big></dd></dl><p>and for the terminal '1' (i.e. where x = '1') this results in:</p><dl><dd><b>Item set 2</b></dd><dd>B → 1 <big><span style="color:#f7f">•</span></big></dd></dl><p>and for the nonterminal E (i.e. where x = E) this results in:</p><dl><dd><b>Item set 3</b></dd><dd>S → E <big><span style="color:#f7f">•</span></big> eof</dd><dd>E → E <big><span style="color:#f7f">•</span></big> * B</dd><dd>E → E <big><span style="color:#f7f">•</span></big> + B</dd></dl><p>and for the nonterminal B (i.e. where x = B) this results in:</p><dl><dd><b>Item set 4</b></dd><dd>E → B <big><span style="color:#f7f">•</span></big></dd></dl><p>The closure does not add new items in all cases - in the new sets above, for example, there are no nonterminals following the dot.</p><p>Above procedure is continued until no more new item sets are found. For the item sets 1, 2, and 4 there will be no transitions since the dot is not in front of any symbol. For item set 3 though, we have dots in front of terminals '*' and '+'. For symbol <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\textstyle x={\texttt {*}}}">  <semantics>    <mrow class="MJX-TeXAtom-ORD">      <mstyle displaystyle="false" scriptlevel="0">        <mi>x</mi>        <mo>=</mo>        <mrow class="MJX-TeXAtom-ORD">          <mrow class="MJX-TeXAtom-ORD">            <mtext mathvariant="monospace">*</mtext>          </mrow>        </mrow>      </mstyle>    </mrow>    <annotation encoding="application/x-tex">{\textstyle x={\texttt {*}}}</annotation>  </semantics></math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/da489c020c898d8f3053e33bd608d5cfcb8036b7" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.338ex; width:5.649ex; height:1.843ex;" alt="{\textstyle x={\texttt {*}}}"/></span>the transition goes to:</p><dl><dd><b>Item set 5</b></dd><dd>E → E * <big><span style="color:#f7f">•</span></big> B</dd><dd><b>+</b> B → <big><span style="color:#f7f">•</span></big> 0</dd><dd><b>+</b> B → <big><span style="color:#f7f">•</span></big> 1</dd></dl><p>and for  <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\textstyle x={\texttt {+}}}">  <semantics>    <mrow class="MJX-TeXAtom-ORD">      <mstyle displaystyle="false" scriptlevel="0">        <mi>x</mi>        <mo>=</mo>        <mrow class="MJX-TeXAtom-ORD">          <mrow class="MJX-TeXAtom-ORD">            <mtext mathvariant="monospace">+</mtext>          </mrow>        </mrow>      </mstyle>    </mrow>    <annotation encoding="application/x-tex">{\textstyle x={\texttt {+}}}</annotation>  </semantics></math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/12f5fc106b34b143f31e62cdf7017c4fcd045dbf" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.338ex; width:5.649ex; height:1.843ex;" alt="{\textstyle x={\texttt {+}}}"/></span>the transition goes to:</p><dl><dd><b>Item set 6</b></dd><dd>E → E + <big><span style="color:#f7f">•</span></big> B</dd><dd><b>+</b> B → <big><span style="color:#f7f">•</span></big> 0</dd><dd><b>+</b> B → <big><span style="color:#f7f">•</span></big> 1</dd></dl><p>Now, the third iteration begins.</p><p>For item set 5, the terminals '0' and '1' and the nonterminal B must be considered, but the resulting closed item sets are equal to already found item sets 1 and 2, respectively. For the nonterminal B, the transition goes to:</p><dl><dd><b>Item set 7</b></dd><dd>E → E * B <big><span style="color:#f7f">•</span></big></dd></dl><p>For item set 6, the terminal '0' and '1' and the nonterminal B must be considered, but as before, the resulting item sets for the terminals are equal to the already found item sets 1 and 2. For the nonterminal B the transition goes to:</p><dl><dd><b>Item set 8</b></dd><dd>E → E + B <big><span style="color:#f7f">•</span></big></dd></dl><p>These final item sets 7 and 8 have no symbols beyond their dots so no more new item sets are added, so the item generating procedure is complete. The finite automaton, with item sets as its states is shown below.</p><p>The transition table for the automaton now looks as follows:</p><table class="wikitable" style="text-align:center"><tbody><tr style="background:#e0e0d0;"><th style="background:#d0e0ff; width:28%;">Item Set</th><th style="width:12%;">*</th><th style="width:12%;">+</th><th style="width:12%;">0</th><th style="width:12%;">1</th><th style="width:12%;">E</th><th style="width:12%;">B</th></tr><tr><th>0</th><td>&#160;</td><td>&#160;</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><th>1</th><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td></tr><tr><th>2</th><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td></tr><tr><th>3</th><td>5</td><td>6</td><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td></tr><tr><th>4</th><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td></tr><tr><th>5</th><td>&#160;</td><td>&#160;</td><td>1</td><td>2</td><td>&#160;</td><td>7</td></tr><tr><th>6</th><td>&#160;</td><td>&#160;</td><td>1</td><td>2</td><td>&#160;</td><td>8</td></tr><tr><th>7</th><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td></tr><tr><th>8</th><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td></tr></tbody></table><h3><span class="mw-headline" id="Constructing_the_action_and_goto_tables">Constructing the action and goto tables</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=29" title="Edit section: Constructing the action and goto tables">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>From this table and the found item sets, the action and goto table are constructed as follows:</p><ol><li>The columns for nonterminals are copied to the goto table.</li><li>The columns for the terminals are copied to the action table as shift actions.</li><li>An extra column for '$' (end of input) is added to the action table that contains <i>acc</i> for every item set that contains an item of the form S → w <big><span style="color:#f7f">•</span></big> eof.</li><li>If an item set <i>i</i> contains an item of the form <i>A</i> → <i>w</i> <big><span style="color:#f7f">•</span></big> and <i>A</i> → <i>w</i> is rule <i>m</i> with <i>m</i> &gt; 0 then the row for state <i>i</i> in the action table is completely filled with the reduce action r<i>m</i>.</li></ol><p>The reader may verify that this results indeed in the action and goto table that were presented earlier on.</p><h4><span id="A_note_about_LR.280.29_versus_SLR_and_LALR_parsing"></span><span class="mw-headline" id="A_note_about_LR(0)_versus_SLR_and_LALR_parsing">A note about LR(0) versus SLR and LALR parsing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=30" title="Edit section: A note about LR(0) versus SLR and LALR parsing">edit</a><span class="mw-editsection-bracket">]</span></span></h4><p>Only step 4 of the above procedure produces reduce actions, and so all reduce actions must occupy an entire table row, causing the reduction to occur regardless of the next symbol in the input stream.  This is why these are LR(0) parse tables: they don't do any lookahead (that is, they look ahead zero symbols) before deciding which reduction to perform.  A grammar that needs lookahead to disambiguate reductions would require a parse table row containing different reduce actions in different columns, and the above procedure is not capable of creating such rows.</p><p>Refinements to the <b>LR</b>(0) table construction procedure (such as <a href="/wiki/Simple_LR_parser" title="Simple LR parser">SLR</a> and <a href="/wiki/LALR_parser" title="LALR parser">LALR</a>) are capable of constructing reduce actions that do not occupy entire rows.  Therefore, they are capable of parsing more grammars than LR(0) parsers.</p><h3><span class="mw-headline" id="Conflicts_in_the_constructed_tables">Conflicts in the constructed tables</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=31" title="Edit section: Conflicts in the constructed tables">edit</a><span class="mw-editsection-bracket">]</span></span></h3><p>The automaton is constructed in such a way that it is guaranteed to be deterministic. However, when reduce actions are added to the action table it can happen that the same cell is filled with a reduce action and a shift action (a <i>shift-reduce conflict</i>) or with two different reduce actions (a <i>reduce-reduce conflict</i>). However, it  can be shown that when this happens the grammar is not an LR(0) grammar. A classic real-world example of a shift-reduce conflict is the <a href="/wiki/Dangling_else" title="Dangling else">dangling else</a> problem.</p><p>A small example of a non-LR(0) grammar with a shift-reduce conflict is:</p><dl><dd>(1) E → 1 E</dd><dd>(2) E → 1</dd></dl><p>One of the item sets found is:</p><dl><dd><b>Item set 1</b></dd><dd>E → 1 <big><span style="color:#f7f">•</span></big> E</dd><dd>E → 1 <big><span style="color:#f7f">•</span></big></dd><dd><b>+</b> E → <big><span style="color:#f7f">•</span></big> 1 E</dd><dd><b>+</b> E → <big><span style="color:#f7f">•</span></big> 1</dd></dl><p>There is a shift-reduce conflict in this item set: when constructing the action table according to the rules above,  the cell for  [item set 1, terminal '1'] contains <b>s1</b> (shift to state 1) <b>and r2</b> (reduce with grammar rule 2).</p><p>A small example of a non-LR(0) grammar with a reduce-reduce conflict is:</p><dl><dd>(1) E → A 1</dd><dd>(2) E → B 2</dd><dd>(3) A → 1</dd><dd>(4) B → 1</dd></dl><p>In this case the following item set is obtained:</p><dl><dd><b>Item set 1</b></dd><dd>A → 1 <big><span style="color:#f7f">•</span></big></dd><dd>B → 1 <big><span style="color:#f7f">•</span></big></dd></dl><p>There is a reduce-reduce conflict in this item set because in the cells in the action table for this item set there will be both a reduce action for rule 3 and one for rule 4.</p><p>Both examples above can be solved by letting the parser use the follow set (see <a href="/wiki/LL_parser" title="LL parser">LL parser</a>) of a nonterminal <i>A</i> to decide if it is going to use one of <i>A</i>s rules for a reduction; it will only use the rule <i>A</i> → <i>w</i> for a reduction if the next symbol on the input stream is in the follow set of <i>A</i>. This solution results in so-called <a href="/wiki/Simple_LR_parser" title="Simple LR parser">Simple LR parsers</a>.</p><h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=32" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2><ul><li><a href="/wiki/Canonical_LR_parser" title="Canonical LR parser">Canonical LR parser</a></li><li><a href="/wiki/SLR_grammar" title="SLR grammar">Simple LR</a></li><li><a href="/wiki/LALR_parser" title="LALR parser">Look-Ahead LR</a></li><li><a href="/wiki/GLR_parser" title="GLR parser">Generalized LR</a></li></ul><h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=33" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2><div class="reflist columns references-column-width" style="-moz-column-width: 33em; -webkit-column-width: 33em; column-width: 33em; list-style-type: decimal;"><ol class="references"><li id="cite_note-Knuth_1965-1"><span class="mw-cite-backlink">^ <a href="#cite_ref-Knuth_1965_1-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Knuth_1965_1-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Knuth_1965_1-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text"><cite id="CITEREFKnuth1965" class="citation journal cs1"><a href="/wiki/Donald_Knuth" title="Donald Knuth">Knuth, D. E.</a> (July 1965). <a rel="nofollow" class="external text" href="https://web.archive.org/web/20120315152151/http://www.cs.dartmouth.edu/~mckeeman/cs48/mxcom/doc/knuth65.pdf">"On the translation of languages from left to right"</a> <span class="cs1-format">(PDF)</span>. <i>Information and Control</i>. <b>8</b> (6): 607–639. <a href="/wiki/Doi_(identifier)" class="mw-redirect" title="Doi (identifier)">doi</a>:<a rel="nofollow" class="external text" href="https://doi.org/10.1016%2FS0019-9958%2865%2990426-2">10.1016/S0019-9958(65)90426-2</a>. Archived from <a rel="nofollow" class="external text" href="http://www.cs.dartmouth.edu/~mckeeman/cs48/mxcom/doc/knuth65.pdf">the original</a> <span class="cs1-format">(PDF)</span> on 15 March 2012<span class="reference-accessdate">. Retrieved <span class="nowrap">29 May</span> 2011</span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Information+and+Control&amp;rft.atitle=On+the+translation+of+languages+from+left+to+right&amp;rft.volume=8&amp;rft.issue=6&amp;rft.pages=607-639&amp;rft.date=1965-07&amp;rft_id=info%3Adoi%2F10.1016%2FS0019-9958%2865%2990426-2&amp;rft.aulast=Knuth&amp;rft.aufirst=D.+E.&amp;rft_id=http%3A%2F%2Fwww.cs.dartmouth.edu%2F~mckeeman%2Fcs48%2Fmxcom%2Fdoc%2Fknuth65.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALR+parser" class="Z3988"></span><span class="cs1-maint citation-comment">CS1 maint: ref=harv (<a href="/wiki/Category:CS1_maint:_ref%3Dharv" title="Category:CS1 maint: ref=harv">link</a>)</span><style data-mw-deduplicate="TemplateStyles:r982806391">.mw-parser-output cite.citation{font-style:inherit}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration{color:#555}.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration span{border-bottom:1px dotted;cursor:help}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output code.cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;font-size:100%}.mw-parser-output .cs1-visible-error{font-size:100%}.mw-parser-output .cs1-maint{display:none;color:#33aa33;margin-left:0.3em}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}</style></span></li><li id="cite_note-AhoUllman_1972-2"><span class="mw-cite-backlink">^ <a href="#cite_ref-AhoUllman_1972_2-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-AhoUllman_1972_2-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><cite id="CITEREFAhoUllman1972" class="citation book cs1"><a href="/wiki/Alfred_Aho" title="Alfred Aho">Aho, Alfred V.</a>; <a href="/wiki/Jeffrey_Ullman" title="Jeffrey Ullman">Ullman, Jeffrey D.</a> (1972). <a rel="nofollow" class="external text" href="https://archive.org/details/theoryofparsingt00ahoa"><i>The Theory of Parsing, Translation, and Compiling (Volume 1: Parsing.)</i></a> (Repr. ed.). <a href="/wiki/Englewood_Cliffs,_NJ" class="mw-redirect" title="Englewood Cliffs, NJ">Englewood Cliffs, NJ</a>: <a href="/wiki/Prentice_Hall" title="Prentice Hall">Prentice Hall</a>. <a href="/wiki/ISBN_(identifier)" class="mw-redirect" title="ISBN (identifier)">ISBN</a>&#160;<a href="/wiki/Special:BookSources/978-0139145568" title="Special:BookSources/978-0139145568"><bdi>978-0139145568</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=The+Theory+of+Parsing%2C+Translation%2C+and+Compiling+%28Volume+1%3A+Parsing.%29&amp;rft.place=Englewood+Cliffs%2C+NJ&amp;rft.edition=Repr.&amp;rft.pub=Prentice+Hall&amp;rft.date=1972&amp;rft.isbn=978-0139145568&amp;rft.aulast=Aho&amp;rft.aufirst=Alfred+V.&amp;rft.au=Ullman%2C+Jeffrey+D.&amp;rft_id=https%3A%2F%2Farchive.org%2Fdetails%2Ftheoryofparsingt00ahoa&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALR+parser" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r982806391"/></span></li><li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="https://cs.stackexchange.com/q/43">Language theoretic comparison of LL and LR grammars</a></span></li><li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">Engineering a Compiler (2nd edition), by Keith Cooper and Linda Torczon, <a href="/wiki/Morgan_Kaufmann" class="mw-redirect" title="Morgan Kaufmann">Morgan Kaufmann</a> 2011.</span></li><li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text">Crafting and Compiler, by Charles Fischer, Ron Cytron, and Richard LeBlanc, Addison Wesley 2009.</span></li><li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text">Flex &amp; Bison: Text Processing Tools, by John Levine, O'Reilly Media 2009.</span></li><li id="cite_note-Compilers_2006-7"><span class="mw-cite-backlink">^ <a href="#cite_ref-Compilers_2006_7-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Compilers_2006_7-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">Compilers: Principles, Techniques, and Tools (2nd Edition), by Alfred Aho, Monica Lam, Ravi Sethi, and Jeffrey Ullman, Prentice Hall 2006.</span></li><li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text">Knuth (1965), p.638</span></li><li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text">Knuth (1965), p.635. Knuth didn't mention the restriction <i>k</i>≥1 there, but it is required by his theorems he referred to, viz. on p.629 and p.630. Similarly, the restriction to <a href="/wiki/Context-free_language" title="Context-free language">context-free languages</a> is tacitly understood from the context.</span></li><li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text">Practical Translators for LR(k) Languages, by Frank DeRemer, MIT PhD dissertation 1969.</span></li><li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text">Simple LR(k) Grammars, by Frank DeRemer, Comm. ACM 14:7 1971.</span></li><li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text"><cite id="CITEREFHopcroftUllman1979" class="citation book cs1">Hopcroft, John E.; Ullman, Jeffrey D. (1979). <a rel="nofollow" class="external text" href="https://archive.org/details/introductiontoau00hopc"><i>Introduction to Automata Theory, Languages, and Computation</i></a>. Addison-Wesley. <a href="/wiki/ISBN_(identifier)" class="mw-redirect" title="ISBN (identifier)">ISBN</a>&#160;<a href="/wiki/Special:BookSources/0-201-02988-X" title="Special:BookSources/0-201-02988-X"><bdi>0-201-02988-X</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Introduction+to+Automata+Theory%2C+Languages%2C+and+Computation&amp;rft.pub=Addison-Wesley&amp;rft.date=1979&amp;rft.isbn=0-201-02988-X&amp;rft.aulast=Hopcroft&amp;rft.aufirst=John+E.&amp;rft.au=Ullman%2C+Jeffrey+D.&amp;rft_id=https%3A%2F%2Farchive.org%2Fdetails%2Fintroductiontoau00hopc&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALR+parser" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r982806391"/> Here: Exercise 5.8, p.121.</span></li><li id="cite_note-13"><span class="mw-cite-backlink"><b><a href="#cite_ref-13">^</a></b></span> <span class="reference-text">Hopcroft, Ullman (1979), Theorem 10.12, p.260</span></li><li id="cite_note-14"><span class="mw-cite-backlink"><b><a href="#cite_ref-14">^</a></b></span> <span class="reference-text">Hopcroft, Ullman (1979), Corollary p.260</span></li></ol></div><h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=34" title="Edit section: Further reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2><ul><li>Chapman, Nigel P., <a rel="nofollow" class="external text" href="https://books.google.com/books?id=nEA9AAAAIAAJ&amp;printsec=frontcover"><i>LR Parsing: Theory and Practice</i></a>, <a href="/wiki/Cambridge_University_Press" title="Cambridge University Press">Cambridge University Press</a>, 1987. <link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r982806391"/><a href="/wiki/ISBN_(identifier)" class="mw-redirect" title="ISBN (identifier)">ISBN</a>&#160;<a href="/wiki/Special:BookSources/0-521-30413-X" title="Special:BookSources/0-521-30413-X">0-521-30413-X</a></li><li>Pager, D., A Practical General Method for Constructing LR(k) Parsers. Acta Informatica 7, 249 - 268 (1977)</li><li>"Compiler Construction: Principles and Practice" by Kenneth C. Louden. <link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r982806391"/><a href="/wiki/ISBN_(identifier)" class="mw-redirect" title="ISBN (identifier)">ISBN</a>&#160;<a href="/wiki/Special:BookSources/0-534-939724" title="Special:BookSources/0-534-939724">0-534-939724</a></li></ul><h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=LR_parser&amp;action=edit&amp;section=35" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2><ul><li><a rel="nofollow" class="external text" href="http://dickgrune.com/Books/PTAPG_1st_Edition/">dickgrune.com</a>, Parsing Techniques - A Practical Guide 1st Ed. web page of book includes downloadable pdf.</li><li><a rel="nofollow" class="external text" href="http://www.supereasyfree.com/software/simulators/compilers/principles-techniques-and-tools/parsing-simulator/parsing-simulator.php">Parsing Simulator</a> This simulator is used to generate parsing tables LR and to resolve the exercises of the book</li><li><a rel="nofollow" class="external text" href="http://www.cs.uic.edu/~spopuri/cparser.html">Internals of an LALR(1) parser generated by GNU Bison</a> - Implementation issues</li><li><a rel="nofollow" class="external text" href="http://www.cs.grinnell.edu/~rebelsky/Courses/CS362/2004S/Outlines/outline.20.html">Course notes on LR parsing</a></li><li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20150924022736/http://www.gobosoft.com/eiffel/gobo/geyacc/algorithm.html">Shift-reduce and Reduce-reduce conflicts in an LALR parser</a></li><li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20120205044802/http://www.cs.uky.edu/~lewis/essays/compilers/bu-parse.html">A LR parser example</a></li><li><a rel="nofollow" class="external text" href="http://david.tribble.com/text/lrk_parsing.html">Practical LR(k) Parser Construction</a></li><li><a rel="nofollow" class="external text" href="http://david.tribble.com/text/honalee.html">The Honalee LR(k) Algorithm</a></li></ul><div role="navigation" class="navbox" aria-labelledby="Parsing_algorithms" style="padding:3px"><table class="nowraplinks mw-collapsible autocollapse navbox-inner" style="border-spacing:0;background:transparent;color:inherit"><tbody><tr><th scope="col" class="navbox-title" colspan="2"><div class="plainlinks hlist navbar mini"><ul><li class="nv-view"><a href="/wiki/Template:Parsers" title="Template:Parsers"><abbr title="View this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">v</abbr></a></li><li class="nv-talk"><a href="/wiki/Template_talk:Parsers" title="Template talk:Parsers"><abbr title="Discuss this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">t</abbr></a></li><li class="nv-edit"><a class="external text" href="https://en.wikipedia.org/w/index.php?title=Template:Parsers&amp;action=edit"><abbr title="Edit this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">e</abbr></a></li></ul></div><div id="Parsing_algorithms" style="font-size:114%;margin:0 4em"><a href="/wiki/Parsing" title="Parsing">Parsing algorithms</a></div></th></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Top-down_parsing" title="Top-down parsing">Top-down</a></th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em"><ul><li><a href="/wiki/LL_parser" title="LL parser">LL</a></li><li><a href="/wiki/Recursive_descent_parser" title="Recursive descent parser">Recursive descent</a><ul><li><a href="/wiki/Tail_recursive_parser" title="Tail recursive parser">Tail recursive</a></li><li><a href="/wiki/Pratt_parser" class="mw-redirect" title="Pratt parser">Pratt parser</a></li></ul></li></ul></div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Bottom-up_parsing" title="Bottom-up parsing">Bottom-up</a></th><td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em"><ul><li>Precedence<ul><li><a href="/wiki/Simple_precedence_parser" title="Simple precedence parser">Simple</a></li><li><a href="/wiki/Operator-precedence_parser" title="Operator-precedence parser">Operator</a><ul><li><a href="/wiki/Shunting-yard_algorithm" title="Shunting-yard algorithm">Shunting-yard</a></li></ul></li></ul></li><li>Bounded-context</li><li><a class="mw-selflink selflink">LR</a><ul><li><a href="/wiki/Simple_LR_parser" title="Simple LR parser">Simple</a></li><li><a href="/wiki/LALR_parser" title="LALR parser">Look-ahead</a></li><li><a href="/wiki/Canonical_LR_parser" title="Canonical LR parser">Canonical</a></li><li><a href="/wiki/GLR_parser" title="GLR parser">Generalized</a></li></ul></li><li><a href="/wiki/CYK_algorithm" title="CYK algorithm">CYK</a></li><li><a href="/wiki/Recursive_ascent_parser" title="Recursive ascent parser">Recursive ascent</a></li><li><a href="/wiki/Shift-reduce_parser" title="Shift-reduce parser">Shift-reduce</a></li></ul></div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%">Mixed, other</th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em"><ul><li><a href="/wiki/Parser_combinator" title="Parser combinator">Combinator</a></li><li><a href="/wiki/Chart_parser" title="Chart parser">Chart</a></li><li><a href="/wiki/Earley_parser" title="Earley parser">Earley</a></li></ul></div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%">Related topics</th><td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em"><ul><li><a href="/wiki/Parsing_expression_grammar" title="Parsing expression grammar">PEG</a></li><li><a href="/wiki/Definite_clause_grammar" title="Definite clause grammar">Definite clause grammar</a></li><li><a href="/wiki/Deterministic_parsing" title="Deterministic parsing">Deterministic parsing</a></li><li><a href="/wiki/Dynamic_programming" title="Dynamic programming">Dynamic programming</a></li><li><a href="/wiki/Memoization" title="Memoization">Memoization</a></li><li><a href="/wiki/Compiler-compiler" title="Compiler-compiler">Parser generator</a><ul><li><a href="/wiki/LALR_parser_generator" title="LALR parser generator">LALR</a></li></ul></li><li><a href="/wiki/Parse_tree" title="Parse tree">Parse tree</a></li><li><a href="/wiki/Abstract_syntax_tree" title="Abstract syntax tree">AST</a></li><li><a href="/wiki/Scannerless_parsing" title="Scannerless parsing">Scannerless parsing</a></li><li><a href="/wiki/History_of_compiler_construction" title="History of compiler construction">History of compiler construction</a></li><li><a href="/wiki/Comparison_of_parser_generators" title="Comparison of parser generators">Comparison of parser generators</a></li></ul></div></td></tr></tbody></table></div><!-- NewPP limit reportParsed by mw1330Cached time: 20201128073525Cache expiry: 2592000Dynamic content: falseComplications: [vary‐revision‐sha1]CPU time usage: 0.508 secondsReal time usage: 0.661 secondsPreprocessor visited node count: 2812/1000000Post‐expand include size: 29245/2097152 bytesTemplate argument size: 3501/2097152 bytesHighest expansion depth: 14/40Expensive parser function count: 2/500Unstrip recursion depth: 1/20Unstrip post‐expand size: 19146/5000000 bytesLua time usage: 0.171/10.000 secondsLua memory usage: 3775823/52428800 bytesNumber of Wikibase entities loaded: 0/400--><!--Transclusion expansion time report (%,ms,calls,template)100.00%  443.137      1 -total 35.81%  158.689      1 Template:Reflist 26.68%  118.238      1 Template:Cite_journal 18.15%   80.427      1 Template:Short_description 16.01%   70.954      2 Template:Citation_needed 13.69%   60.666      2 Template:ISBN 13.03%   57.735      2 Template:Fix  9.49%   42.032      1 Template:Pagetype  6.92%   30.653      4 Template:Category_handler  5.40%   23.919      2 Template:Catalog_lookup_link--><!-- Saved in parser cache with key enwiki:pcache:idhash:18030-0!canonical!math=5 and timestamp 20201128073524 and revision id 982082121. Serialized with PHP. --></div><noscript><img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" /></noscript><div class="printfooter">Retrieved from "<a dir="ltr" href="https://en.wikipedia.org/w/index.php?title=LR_parser&amp;oldid=982082121">https://en.wikipedia.org/w/index.php?title=LR_parser&amp;oldid=982082121</a>"</div></div>		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/wiki/Help:Category" title="Help:Category">Categories</a>: <ul><li><a href="/wiki/Category:Parsing_algorithms" title="Category:Parsing algorithms">Parsing algorithms</a></li></ul></div><div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul><li><a href="/wiki/Category:CS1_maint:_ref%3Dharv" title="Category:CS1 maint: ref=harv">CS1 maint: ref=harv</a></li><li><a href="/wiki/Category:Articles_with_short_description" title="Category:Articles with short description">Articles with short description</a></li><li><a href="/wiki/Category:Short_description_is_different_from_Wikidata" title="Category:Short description is different from Wikidata">Short description is different from Wikidata</a></li><li><a href="/wiki/Category:All_articles_with_unsourced_statements" title="Category:All articles with unsourced statements">All articles with unsourced statements</a></li><li><a href="/wiki/Category:Articles_with_unsourced_statements_from_September_2019" title="Category:Articles with unsourced statements from September 2019">Articles with unsourced statements from September 2019</a></li><li><a href="/wiki/Category:Articles_with_unsourced_statements_from_June_2012" title="Category:Articles with unsourced statements from June 2012">Articles with unsourced statements from June 2012</a></li></ul></div></div>	</div></div><div id='mw-data-after-content'>	<div class="read-more-container"></div></div><div id="mw-navigation">	<h2>Navigation menu</h2>	<div id="mw-head">		<!-- Please do not use role attribute as CSS selector, it is deprecated. --><nav id="p-personal" class="mw-portlet mw-portlet-personal vector-menu" aria-labelledby="p-personal-label" role="navigation" 	 >	<h3 id="p-personal-label">		<span>Personal tools</span>	</h3>	<div class="vector-menu-content">		<ul class="vector-menu-content-list"><li id="pt-anonuserpage">Not logged in</li><li id="pt-anontalk"><a href="/wiki/Special:MyTalk" title="Discussion about edits from this IP address [n]" accesskey="n">Talk</a></li><li id="pt-anoncontribs"><a href="/wiki/Special:MyContributions" title="A list of edits made from this IP address [y]" accesskey="y">Contributions</a></li><li id="pt-createaccount"><a href="/w/index.php?title=Special:CreateAccount&amp;returnto=LR+parser" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li><li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=LR+parser" title="You&#039;re encouraged to log in; however, it&#039;s not mandatory. [o]" accesskey="o">Log in</a></li></ul>			</div></nav>		<div id="left-navigation">			<!-- Please do not use role attribute as CSS selector, it is deprecated. --><nav id="p-namespaces" class="mw-portlet mw-portlet-namespaces vector-menu vector-menu-tabs" aria-labelledby="p-namespaces-label" role="navigation" 	 >	<h3 id="p-namespaces-label">		<span>Namespaces</span>	</h3>	<div class="vector-menu-content">		<ul class="vector-menu-content-list"><li id="ca-nstab-main" class="selected"><a href="/wiki/LR_parser" title="View the content page [c]" accesskey="c">Article</a></li><li id="ca-talk"><a href="/wiki/Talk:LR_parser" rel="discussion" title="Discuss improvements to the content page [t]" accesskey="t">Talk</a></li></ul>			</div></nav>			<!-- Please do not use role attribute as CSS selector, it is deprecated. --><nav id="p-variants" class="mw-portlet mw-portlet-variants emptyPortlet vector-menu vector-menu-dropdown" aria-labelledby="p-variants-label" role="navigation" 	 >	<input type="checkbox" class="vector-menu-checkbox" aria-labelledby="p-variants-label" />	<h3 id="p-variants-label">		<span>Variants</span>	</h3>	<div class="vector-menu-content">		<ul class="vector-menu-content-list"></ul>			</div></nav>		</div>		<div id="right-navigation">			<!-- Please do not use role attribute as CSS selector, it is deprecated. --><nav id="p-views" class="mw-portlet mw-portlet-views vector-menu vector-menu-tabs" aria-labelledby="p-views-label" role="navigation" 	 >	<h3 id="p-views-label">		<span>Views</span>	</h3>	<div class="vector-menu-content">		<ul class="vector-menu-content-list"><li id="ca-view" class="selected"><a href="/wiki/LR_parser">Read</a></li><li id="ca-edit"><a href="/w/index.php?title=LR_parser&amp;action=edit" title="Edit this page [e]" accesskey="e">Edit</a></li><li id="ca-history"><a href="/w/index.php?title=LR_parser&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></li></ul>			</div></nav>			<!-- Please do not use role attribute as CSS selector, it is deprecated. --><nav id="p-cactions" class="mw-portlet mw-portlet-cactions emptyPortlet vector-menu vector-menu-dropdown" aria-labelledby="p-cactions-label" role="navigation" 	 >	<input type="checkbox" class="vector-menu-checkbox" aria-labelledby="p-cactions-label" />	<h3 id="p-cactions-label">		<span>More</span>	</h3>	<div class="vector-menu-content">		<ul class="vector-menu-content-list"></ul>			</div></nav>			<div id="p-search" role="search">	<h3 >		<label for="searchInput">Search</label>	</h3>	<form action="/w/index.php" id="searchform">		<div id="simpleSearch" data-search-loc="header-navigation">			<input type="search" name="search" placeholder="Search Wikipedia" autocapitalize="sentences" title="Search Wikipedia [f]" accesskey="f" id="searchInput"/>			<input type="hidden" name="title" value="Special:Search">			<input type="submit" name="fulltext" value="Search" title="Search Wikipedia for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/>			<input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>		</div>	</form></div>		</div>	</div>	<div id="mw-panel">	<div id="p-logo" role="banner">		<a  title="Visit the main page" class="mw-wiki-logo" href="/wiki/Main_Page"></a>	</div>	<!-- Please do not use role attribute as CSS selector, it is deprecated. --><nav id="p-navigation" class="mw-portlet mw-portlet-navigation vector-menu vector-menu-portal portal portal-first" aria-labelledby="p-navigation-label" role="navigation" 	 >	<h3 id="p-navigation-label">		<span>Navigation</span>	</h3>	<div class="vector-menu-content">		<ul class="vector-menu-content-list"><li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li><li id="n-contents"><a href="/wiki/Wikipedia:Contents" title="Guides to browsing Wikipedia">Contents</a></li><li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Articles related to current events">Current events</a></li><li id="n-randompage"><a href="/wiki/Special:Random" title="Visit a randomly selected article [x]" accesskey="x">Random article</a></li><li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Learn about Wikipedia and how it works">About Wikipedia</a></li><li id="n-contactpage"><a href="//en.wikipedia.org/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact us</a></li><li id="n-sitesupport"><a href="https://donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&amp;utm_medium=sidebar&amp;utm_campaign=C13_en.wikipedia.org&amp;uselang=en" title="Support us by donating to the Wikimedia Foundation">Donate</a></li></ul>			</div></nav>	<!-- Please do not use role attribute as CSS selector, it is deprecated. --><nav id="p-interaction" class="mw-portlet mw-portlet-interaction vector-menu vector-menu-portal portal" aria-labelledby="p-interaction-label" role="navigation" 	 >	<h3 id="p-interaction-label">		<span>Contribute</span>	</h3>	<div class="vector-menu-content">		<ul class="vector-menu-content-list"><li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li><li id="n-introduction"><a href="/wiki/Help:Introduction" title="Learn how to edit Wikipedia">Learn to edit</a></li><li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="The hub for editors">Community portal</a></li><li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes to Wikipedia [r]" accesskey="r">Recent changes</a></li><li id="n-upload"><a href="/wiki/Wikipedia:File_Upload_Wizard" title="Add images or other media for use on Wikipedia">Upload file</a></li></ul>			</div></nav><!-- Please do not use role attribute as CSS selector, it is deprecated. --><nav id="p-tb" class="mw-portlet mw-portlet-tb vector-menu vector-menu-portal portal" aria-labelledby="p-tb-label" role="navigation" 	 >	<h3 id="p-tb-label">		<span>Tools</span>	</h3>	<div class="vector-menu-content">		<ul class="vector-menu-content-list"><li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/LR_parser" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/LR_parser" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-upload"><a href="/wiki/Wikipedia:File_Upload_Wizard" title="Upload files [u]" accesskey="u">Upload file</a></li><li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-permalink"><a href="/w/index.php?title=LR_parser&amp;oldid=982082121" title="Permanent link to this revision of this page">Permanent link</a></li><li id="t-info"><a href="/w/index.php?title=LR_parser&amp;action=info" title="More information about this page">Page information</a></li><li id="t-cite"><a href="/w/index.php?title=Special:CiteThisPage&amp;page=LR_parser&amp;id=982082121&amp;wpFormIdentifier=titleform" title="Information on how to cite this page">Cite this page</a></li><li id="t-wikibase"><a href="https://www.wikidata.org/wiki/Special:EntityPage/Q1756442" title="Structured data on this page hosted by Wikidata [g]" accesskey="g">Wikidata item</a></li></ul>			</div></nav><!-- Please do not use role attribute as CSS selector, it is deprecated. --><nav id="p-coll-print_export" class="mw-portlet mw-portlet-coll-print_export vector-menu vector-menu-portal portal" aria-labelledby="p-coll-print_export-label" role="navigation" 	 >	<h3 id="p-coll-print_export-label">		<span>Print/export</span>	</h3>	<div class="vector-menu-content">		<ul class="vector-menu-content-list"><li id="coll-download-as-rl"><a href="/w/index.php?title=Special:DownloadAsPdf&amp;page=LR_parser&amp;action=show-download-screen" title="Download this page as a PDF file">Download as PDF</a></li><li id="t-print"><a href="/w/index.php?title=LR_parser&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</a></li></ul>			</div></nav>	<!-- Please do not use role attribute as CSS selector, it is deprecated. --><nav id="p-lang" class="mw-portlet mw-portlet-lang vector-menu vector-menu-portal portal" aria-labelledby="p-lang-label" role="navigation" 	 >	<h3 id="p-lang-label">		<span>Languages</span>	</h3>	<div class="vector-menu-content">		<ul class="vector-menu-content-list"><li class="interlanguage-link interwiki-ar"><a href="https://ar.wikipedia.org/wiki/%D9%85%D8%AC%D8%B2%D8%A6_%D9%8A%D8%B3%D8%A7%D8%B1_%D9%8A%D9%85%D9%8A%D9%86" title="مجزئ يسار يمين – Arabic" lang="ar" hreflang="ar" class="interlanguage-link-target">العربية</a></li><li class="interlanguage-link interwiki-cs"><a href="https://cs.wikipedia.org/wiki/LR_syntaktick%C3%BD_analyz%C3%A1tor" title="LR syntaktický analyzátor – Czech" lang="cs" hreflang="cs" class="interlanguage-link-target">Čeština</a></li><li class="interlanguage-link interwiki-de"><a href="https://de.wikipedia.org/wiki/LR-Parser" title="LR-Parser – German" lang="de" hreflang="de" class="interlanguage-link-target">Deutsch</a></li><li class="interlanguage-link interwiki-es"><a href="https://es.wikipedia.org/wiki/Analizador_sint%C3%A1ctico_LR" title="Analizador sintáctico LR – Spanish" lang="es" hreflang="es" class="interlanguage-link-target">Español</a></li><li class="interlanguage-link interwiki-fa"><a href="https://fa.wikipedia.org/wiki/%D8%AA%D8%AC%D8%B2%DB%8C%D9%87%E2%80%8C%DA%A9%D9%86%D9%86%D8%AF%D9%87_%D8%A7%D9%84%E2%80%8C%D8%A2%D8%B1" title="تجزیه‌کننده ال‌آر – Persian" lang="fa" hreflang="fa" class="interlanguage-link-target">فارسی</a></li><li class="interlanguage-link interwiki-fr"><a href="https://fr.wikipedia.org/wiki/Analyseur_LR" title="Analyseur LR – French" lang="fr" hreflang="fr" class="interlanguage-link-target">Français</a></li><li class="interlanguage-link interwiki-it"><a href="https://it.wikipedia.org/wiki/Parser_LR" title="Parser LR – Italian" lang="it" hreflang="it" class="interlanguage-link-target">Italiano</a></li><li class="interlanguage-link interwiki-ja"><a href="https://ja.wikipedia.org/wiki/LR%E6%B3%95" title="LR法 – Japanese" lang="ja" hreflang="ja" class="interlanguage-link-target">日本語</a></li><li class="interlanguage-link interwiki-no"><a href="https://no.wikipedia.org/wiki/LR-parser" title="LR-parser – Norwegian Bokmål" lang="nb" hreflang="nb" class="interlanguage-link-target">Norsk bokmål</a></li><li class="interlanguage-link interwiki-pl"><a href="https://pl.wikipedia.org/wiki/Parser_LR" title="Parser LR – Polish" lang="pl" hreflang="pl" class="interlanguage-link-target">Polski</a></li><li class="interlanguage-link interwiki-pt"><a href="https://pt.wikipedia.org/wiki/Analisador_sint%C3%A1tico_LR" title="Analisador sintático LR – Portuguese" lang="pt" hreflang="pt" class="interlanguage-link-target">Português</a></li><li class="interlanguage-link interwiki-ru"><a href="https://ru.wikipedia.org/wiki/LR-%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80" title="LR-анализатор – Russian" lang="ru" hreflang="ru" class="interlanguage-link-target">Русский</a></li><li class="interlanguage-link interwiki-zh"><a href="https://zh.wikipedia.org/wiki/LR%E5%89%96%E6%9E%90%E5%99%A8" title="LR剖析器 – Chinese" lang="zh" hreflang="zh" class="interlanguage-link-target">中文</a></li></ul>		<div class="after-portlet after-portlet-lang"><span class="wb-langlinks-edit wb-langlinks-link"><a href="https://www.wikidata.org/wiki/Special:EntityPage/Q1756442#sitelinks-wikipedia" title="Edit interlanguage links" class="wbc-editpage">Edit links</a></span></div>	</div></nav></div></div><footer id="footer" class="mw-footer" role="contentinfo" >	<ul id="footer-info" >	<li id="footer-info-lastmod"> This page was last edited on 6 October 2020, at 02:16<span class="anonymous-show">&#160;(UTC)</span>.</li>	<li id="footer-info-copyright">Text is available under the <a rel="license" href="//en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License">Creative Commons Attribution-ShareAlike License</a><a rel="license" href="//creativecommons.org/licenses/by-sa/3.0/" style="display:none;"></a>;additional terms may apply.  By using this site, you agree to the <a href="//foundation.wikimedia.org/wiki/Terms_of_Use">Terms of Use</a> and <a href="//foundation.wikimedia.org/wiki/Privacy_policy">Privacy Policy</a>. Wikipedia® is a registered trademark of the <a href="//www.wikimediafoundation.org/">Wikimedia Foundation, Inc.</a>, a non-profit organization.</li></ul>	<ul id="footer-places" >	<li id="footer-places-privacy"><a href="https://foundation.wikimedia.org/wiki/Privacy_policy" class="extiw" title="wmf:Privacy policy">Privacy policy</a></li>	<li id="footer-places-about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>	<li id="footer-places-disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>	<li id="footer-places-contact"><a href="//en.wikipedia.org/wiki/Wikipedia:Contact_us">Contact Wikipedia</a></li>	<li id="footer-places-mobileview"><a href="//en.m.wikipedia.org/w/index.php?title=LR_parser&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>	<li id="footer-places-developers"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute">Developers</a></li>	<li id="footer-places-statslink"><a href="https://stats.wikimedia.org/#/en.wikipedia.org">Statistics</a></li>	<li id="footer-places-cookiestatement"><a href="https://foundation.wikimedia.org/wiki/Cookie_statement">Cookie statement</a></li></ul>	<ul id="footer-icons" class="noprint">	<li id="footer-copyrightico"><a href="https://wikimediafoundation.org/"><img src="/static/images/footer/wikimedia-button.png" srcset="/static/images/footer/wikimedia-button-1.5x.png 1.5x, /static/images/footer/wikimedia-button-2x.png 2x" width="88" height="31" alt="Wikimedia Foundation" loading="lazy" /></a></li>	<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="/static/images/footer/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/static/images/footer/poweredby_mediawiki_132x47.png 1.5x, /static/images/footer/poweredby_mediawiki_176x62.png 2x" width="88" height="31" loading="lazy"/></a></li></ul>	<div style="clear: both;"></div></footer><script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.508","walltime":"0.661","ppvisitednodes":{"value":2812,"limit":1000000},"postexpandincludesize":{"value":29245,"limit":2097152},"templateargumentsize":{"value":3501,"limit":2097152},"expansiondepth":{"value":14,"limit":40},"expensivefunctioncount":{"value":2,"limit":500},"unstrip-depth":{"value":1,"limit":20},"unstrip-size":{"value":19146,"limit":5000000},"entityaccesscount":{"value":0,"limit":400},"timingprofile":["100.00%  443.137      1 -total"," 35.81%  158.689      1 Template:Reflist"," 26.68%  118.238      1 Template:Cite_journal"," 18.15%   80.427      1 Template:Short_description"," 16.01%   70.954      2 Template:Citation_needed"," 13.69%   60.666      2 Template:ISBN"," 13.03%   57.735      2 Template:Fix","  9.49%   42.032      1 Template:Pagetype","  6.92%   30.653      4 Template:Category_handler","  5.40%   23.919      2 Template:Catalog_lookup_link"]},"scribunto":{"limitreport-timeusage":{"value":"0.171","limit":"10.000"},"limitreport-memusage":{"value":3775823,"limit":52428800}},"cachereport":{"origin":"mw1330","timestamp":"20201128073525","ttl":2592000,"transientcontent":false}}});});</script><script type="application/ld+json">{"@context":"https:\/\/schema.org","@type":"Article","name":"LR parser","url":"https:\/\/en.wikipedia.org\/wiki\/LR_parser","sameAs":"http:\/\/www.wikidata.org\/entity\/Q1756442","mainEntity":"http:\/\/www.wikidata.org\/entity\/Q1756442","author":{"@type":"Organization","name":"Contributors to Wikimedia projects"},"publisher":{"@type":"Organization","name":"Wikimedia Foundation, Inc.","logo":{"@type":"ImageObject","url":"https:\/\/www.wikimedia.org\/static\/images\/wmf-hor-googpub.png"}},"datePublished":"2001-08-22T14:47:56Z","dateModified":"2020-10-06T02:16:14Z","headline":"type of parser"}</script><script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":159,"wgHostname":"mw1409"});});</script></body></html>