Non-uniform memory access - Wikipedia Non-uniform memory access From Wikipedia, the free encyclopedia (Redirected from Non-Uniform Memory Access) Jump to navigation Jump to search For other people or places with the same name as this abbreviation, see Numa. HP Z820 with two CPUS and NUMA Non-Uniform Memory Access (NUMA) is a computer memory design used in multiprocessing, where the memory access time depends on the memory location relative to the processor. Under NUMA, a processor can access its own local memory faster than non-local memory (memory local to another processor or memory shared between processors). The benefits of NUMA are limited to particular workloads, notably on servers where the data is often associated strongly with certain tasks or users.[1] NUMA architectures logically follow in scaling from symmetric multiprocessing (SMP) architectures. They were developed commercially during the 1990s by Unisys, Convex Computer (later Hewlett-Packard), Honeywell Information Systems Italy (HISI) (later Groupe Bull), Silicon Graphics (later Silicon Graphics International), Sequent Computer Systems (later IBM), Data General (later EMC), and Digital (later Compaq, then HP, now HPE). Techniques developed by these companies later featured in a variety of Unix-like operating systems, and to an extent in Windows NT. The first commercial implementation of a NUMA-based Unix system was the Symmetrical Multi Processing XPS-100 family of servers, designed by Dan Gielan of VAST Corporation for Honeywell Information Systems Italy. Contents 1 Basic concept 2 Cache coherent NUMA (ccNUMA) 3 NUMA vs. cluster computing 4 Software support 5 See also 6 References 7 External links Basic concept[edit] One possible architecture of a NUMA system. The processors connect to the bus or crossbar by connections of varying thickness/number. This shows that different CPUs have different access priorities to memory based on their relative location. Modern CPUs operate considerably faster than the main memory they use. In the early days of computing and data processing, the CPU generally ran slower than its own memory. The performance lines of processors and memory crossed in the 1960s with the advent of the first supercomputers. Since then, CPUs increasingly have found themselves "starved for data" and having to stall while waiting for data to arrive from memory. Many supercomputer designs of the 1980s and 1990s focused on providing high-speed memory access as opposed to faster processors, allowing the computers to work on large data sets at speeds other systems could not approach. Limiting the number of memory accesses provided the key to extracting high performance from a modern computer. For commodity processors, this meant installing an ever-increasing amount of high-speed cache memory and using increasingly sophisticated algorithms to avoid cache misses. But the dramatic increase in size of the operating systems and of the applications run on them has generally overwhelmed these cache-processing improvements. Multi-processor systems without NUMA make the problem considerably worse. Now a system can starve several processors at the same time, notably because only one processor can access the computer's memory at a time.[2] NUMA attempts to address this problem by providing separate memory for each processor, avoiding the performance hit when several processors attempt to address the same memory. For problems involving spread data (common for servers and similar applications), NUMA can improve the performance over a single shared memory by a factor of roughly the number of processors (or separate memory banks).[3] Another approach to addressing this problem, used mainly in non-NUMA systems, is the multi-channel memory architecture, in which a linear increase in the number of memory channels increases the memory access concurrency linearly.[4] Of course, not all data ends up confined to a single task, which means that more than one processor may require the same data. To handle these cases, NUMA systems include additional hardware or software to move data between memory banks. This operation slows the processors attached to those banks, so the overall speed increase due to NUMA depends heavily on the nature of the running tasks.[3] AMD implemented NUMA with its Opteron processor (2003), using HyperTransport. Intel announced NUMA compatibility for its x86 and Itanium servers in late 2007 with its Nehalem and Tukwila CPUs.[5] Both Intel CPU families share a common chipset; the interconnection is called Intel Quick Path Interconnect (QPI).[6] Cache coherent NUMA (ccNUMA)[edit] Topology of a ccNUMA Bulldozer server extracted using hwloc's lstopo tool. Further information: Cache memory § Directory-based cache coherence – message-passing Nearly all CPU architectures use a small amount of very fast non-shared memory known as cache to exploit locality of reference in memory accesses. With NUMA, maintaining cache coherence across shared memory has a significant overhead. Although simpler to design and build, non-cache-coherent NUMA systems become prohibitively complex to program in the standard von Neumann architecture programming model.[7] Typically, ccNUMA uses inter-processor communication between cache controllers to keep a consistent memory image when more than one cache stores the same memory location. For this reason, ccNUMA may perform poorly when multiple processors attempt to access the same memory area in rapid succession. Support for NUMA in operating systems attempts to reduce the frequency of this kind of access by allocating processors and memory in NUMA-friendly ways and by avoiding scheduling and locking algorithms that make NUMA-unfriendly accesses necessary.[8] Alternatively, cache coherency protocols such as the MESIF protocol attempt to reduce the communication required to maintain cache coherency. Scalable Coherent Interface (SCI) is an IEEE standard defining a directory-based cache coherency protocol to avoid scalability limitations found in earlier multiprocessor systems. For example, SCI is used as the basis for the NumaConnect technology.[9][10] As of 2011, ccNUMA systems are multiprocessor systems based on the AMD Opteron processor, which can be implemented without external logic, and the Intel Itanium processor, which requires the chipset to support NUMA. Examples of ccNUMA-enabled chipsets are the SGI Shub (Super hub), the Intel E8870, the HP sx2000 (used in the Integrity and Superdome servers), and those found in NEC Itanium-based systems. Earlier ccNUMA systems such as those from Silicon Graphics were based on MIPS processors and the DEC Alpha 21364 (EV7) processor. NUMA vs. cluster computing[edit] One can view NUMA as a tightly coupled form of cluster computing. The addition of virtual memory paging to a cluster architecture can allow the implementation of NUMA entirely in software. However, the inter-node latency of software-based NUMA remains several orders of magnitude greater (slower) than that of hardware-based NUMA.[1] Software support[edit] Since NUMA largely influences memory access performance, certain software optimizations are needed to allow scheduling threads and processes close to their in-memory data. Silicon Graphics IRIX support for ccNUMA architecture over 1240 CPU with Origin server series. Microsoft Windows 7 and Windows Server 2008 R2 added support for NUMA architecture over 64 logical cores.[11] Java 7 added support for NUMA-aware memory allocator and garbage collector.[12] Version 2.5 of the Linux kernel already contained basic NUMA support,[13] which was further improved in subsequent kernel releases. Version 3.8 of the Linux kernel brought a new NUMA foundation that allowed development of more efficient NUMA policies in later kernel releases.[14][15] Version 3.13 of the Linux kernel brought numerous policies that aim at putting a process near its memory, together with the handling of cases such as having memory pages shared between processes, or the use of transparent huge pages; new sysctl settings allow NUMA balancing to be enabled or disabled, as well as the configuration of various NUMA memory balancing parameters.[16][17][18] OpenSolaris models NUMA architecture with lgroups. FreeBSD added support for NUMA architecture in version 9.0[19]. See also[edit] Uniform memory access (UMA) Cache-only memory architecture (COMA) Scratchpad memory (SPM) Partitioned global address space HiperDispatch References[edit] ^ a b Nakul Manchanda; Karan Anand (2010-05-04). "Non-Uniform Memory Access (NUMA)" (PDF). New York University. Archived from the original (PDF) on 2013-12-28. Retrieved 2014-01-27. ^ Sergey Blagodurov; Sergey Zhuravlev; Mohammad Dashti; Alexandra Fedorov (2011-05-02). "A Case for NUMA-aware Contention Management on Multicore Systems" (PDF). Simon Fraser University. Retrieved 2014-01-27. ^ a b Zoltan Majo; Thomas R. Gross (2011). "Memory System Performance in a NUMA Multicore Multiprocessor" (PDF). ACM. Archived from the original (PDF) on 2013-06-12. Retrieved 2014-01-27. ^ "Intel Dual-Channel DDR Memory Architecture White Paper" (PDF) (Rev. 1.0 ed.). Infineon Technologies North America and Kingston Technology. September 2003. Archived from the original (PDF, 1021 KB) on 2011-09-29. Retrieved 2007-09-06. ^ Intel Corp. (2008). Intel QuickPath Architecture [White paper]. Retrieved from http://www.intel.com/pressroom/archive/reference/whitepaper_QuickPath.pdf ^ Intel Corporation. (September 18th, 2007). Gelsinger Speaks To Intel And High-Tech Industry's Rapid Technology Caden[Press release]. Retrieved from http://www.intel.com/pressroom/archive/releases/2007/20070918corp_b.htm ^ "ccNUMA: Cache Coherent Non-Uniform Memory Access". slideshare.net. 2014. Retrieved 2014-01-27. ^ Per Stenstromt; Truman Joe; Anoop Gupta (2002). "Comparative Performance Evaluation of Cache-Coherent NUMA and COMA Architectures" (PDF). ACM. Retrieved 2014-01-27. ^ David B. Gustavson (September 1991). "The Scalable Coherent Interface and Related Standards Projects" (PDF). SLAC Publication 5656. Stanford Linear Accelerator Center. Retrieved January 27, 2014. ^ "The NumaChip enables cache coherent low cost shared memory". Numascale.com. Archived from the original on 2014-01-22. Retrieved 2014-01-27. ^ NUMA Support (MSDN) ^ Java HotSpot™ Virtual Machine Performance Enhancements ^ "Linux Scalability Effort: NUMA Group Homepage". sourceforge.net. 2002-11-20. Retrieved 2014-02-06. ^ "Linux kernel 3.8, Section 1.8. Automatic NUMA balancing". kernelnewbies.org. 2013-02-08. Retrieved 2014-02-06. ^ Jonathan Corbet (2012-11-14). "NUMA in a hurry". LWN.net. Retrieved 2014-02-06. ^ "Linux kernel 3.13, Section 1.6. Improved performance in NUMA systems". kernelnewbies.org. 2014-01-19. Retrieved 2014-02-06. ^ "Linux kernel documentation: Documentation/sysctl/kernel.txt". kernel.org. Retrieved 2014-02-06. ^ Jonathan Corbet (2013-10-01). "NUMA scheduling progress". LWN.net. Retrieved 2014-02-06. ^ "numa(4)". www.freebsd.org. Retrieved 2020-12-03. This article is based on material taken from the Free On-line Dictionary of Computing prior to 1 November 2008 and incorporated under the "relicensing" terms of the GFDL, version 1.3 or later. External links[edit] NUMA FAQ Page-based distributed shared memory OpenSolaris NUMA Project Introduction video for the Alpha EV7 system architecture More videos related to EV7 systems: CPU, IO, etc NUMA optimization in Windows Applications NUMA Support in Linux at SGI Intel Tukwila Intel QPI (CSI) explained current Itanium NUMA systems v t e Parallel computing General Distributed computing Parallel computing Massively parallel Cloud computing High-performance computing Multiprocessing Manycore processor GPGPU Computer network Systolic array Levels Bit Instruction Thread Task Data Memory Loop Pipeline Multithreading Temporal Simultaneous (SMT) Speculative (SpMT) Preemptive Cooperative Clustered Multi-Thread (CMT) Hardware scout Theory PRAM model PEM Model Analysis of parallel algorithms Amdahl's law Gustafson's law Cost efficiency Karp–Flatt metric Slowdown Speedup Elements Process Thread Fiber Instruction window Array data structure Coordination Multiprocessing Memory coherency Cache coherency Cache invalidation Barrier Synchronization Application checkpointing Programming Stream processing Dataflow programming Models Implicit parallelism Explicit parallelism Concurrency Non-blocking algorithm Hardware Flynn's taxonomy SISD SIMD SIMT MISD MIMD Dataflow architecture Pipelined processor Superscalar processor Vector processor Multiprocessor symmetric asymmetric Memory shared distributed distributed shared UMA NUMA COMA Massively parallel computer Computer cluster Grid computer Hardware acceleration APIs Ateji PX Boost Chapel HPX Charm++ Cilk Coarray Fortran CUDA Dryad C++ AMP Global Arrays GPUOpen MPI OpenMP OpenCL OpenHMPP OpenACC Parallel Extensions PVM POSIX Threads RaftLib UPC TBB ZPL Problems Automatic parallelization Deadlock Deterministic algorithm Embarrassingly parallel Parallel slowdown Race condition Software lockout Scalability Starvation Category: Parallel computing Retrieved from "https://en.wikipedia.org/w/index.php?title=Non-uniform_memory_access&oldid=992084425" Categories: Parallel computing Computer memory Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages العربية Català Čeština Deutsch Español فارسی Français 한국어 Italiano Magyar Македонски Nederlands 日本語 Polski Português Русский Svenska Türkçe Українська Tiếng Việt 中文 Edit links This page was last edited on 3 December 2020, at 12:05 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement