Miranda (programming language) - Wikipedia Miranda (programming language) From Wikipedia, the free encyclopedia Jump to navigation Jump to search This article includes a list of general references, but it remains largely unverified because it lacks sufficient corresponding inline citations. Please help to improve this article by introducing more precise citations. (September 2016) (Learn how and when to remove this template message) Miranda Paradigm lazy, functional, declarative Designed by David Turner Developer Research Software Ltd First appeared 1985 (1985) Typing discipline strong, static Website miranda.org.uk Major implementations Miranda Influenced by KRC, ML, SASL, Hope Influenced Clean, Haskell, Orwell Miranda is a lazy, purely functional programming language designed by David Turner as a successor to his earlier programming languages SASL and KRC, using some concepts from ML and Hope. It was produced by Research Software Ltd. of England (which holds a trademark on the name Miranda) and was the first purely functional language to be commercially supported.[citation needed] Miranda was first released in 1985, as a fast interpreter in C for Unix-flavour operating systems, with subsequent releases in 1987 and 1989. Miranda had a strong influence on the later Haskell programming language.[1] Contents 1 Overview 2 Sample code 3 References 4 External links Overview[edit] Miranda is a lazy, purely functional programming language. That is, it lacks side effects and imperative programming features. A Miranda program (called a script) is a set of equations that define various mathematical functions and algebraic data types. The word set is important here: the order of the equations is, in general, irrelevant, and there is no need to define an entity prior to its use. Since the parsing algorithm makes intelligent use of layout (indentation), there is rarely a need for bracketing statements and no statement terminators are required. This feature, inspired by ISWIM, is also used in occam and Haskell and was later popularized by Python. Commentary is introduced into regular scripts by the characters || and continue to the end of the same line. An alternative commenting convention affects an entire source code file, known as a "literate script", in which every line is considered a comment unless it starts with a > sign. Miranda's basic data types are char, num and bool. A character string is simply a list of char, while num is silently converted between two underlying forms: arbitrary-precision integers (a.k.a. bignums) by default, and regular floating point values as required. Tuples are sequences of elements of potentially mixed types, analogous to records in Pascal-like languages, and are written delimited with parentheses:   this_employee = ("Folland, Mary", 10560, False, 35) The list instead is the most commonly used data structure in Miranda. It is written delimited by square brackets and with comma-separated elements, all of which must be of the same type:   week_days = ["Mon","Tue","Wed","Thur","Fri"] List concatenation is ++, subtraction is --, construction is :, sizing is # and indexing is !, so:   days = week_days ++ ["Sat","Sun"]  days = "Nil":days  days!0 ⇒ "Nil"  days = days -- ["Nil"]  #days ⇒ 7 There are several list-building shortcuts: .. is used for lists whose elements form an arithmetic series, with the possibility for specifying an increment other than 1:   fac n   = product [1..n]  odd_sum = sum [1,3..100] More general and powerful list-building facilities are provided by "list comprehensions" (previously known as "ZF expressions"), which come in two main forms: an expression applied to a series of terms, e.g.:   squares = [ n * n | n <- [1..] ] (which is read: list of n squared where n is taken from the list of all positive integers) and a series where each term is a function of the previous one, e.g.:   powers_of_2 = [ n | n <- 1, 2*n .. ] As these two examples imply, Miranda allows for lists with an infinite number of elements, of which the simplest is the list of all positive integers: [1..] The notation for function application is simply juxtaposition, as in sin x. In Miranda, as in most other purely functional languages, functions are first-class citizens, which is to say that they can be passed as parameters to other functions, returned as results, or included as elements of data structures. What is more, a function requiring two or more parameters may be "partially parameterised", or curried, by supplying fewer than the full number of parameters. This gives another function which, given the remaining parameters, will return a result. For example:   add a b = a + b  increment = add 1 is a roundabout way of creating a function "increment" which adds one to its argument. In reality, add 4 7 takes the two-parameter function add, applies it to 4 obtaining a single-parameter function that adds four to its argument, then applies that to 7. Any function taking two parameters can be turned into an infix operator (for example, given the definition of the add function above, the term $add is in every way equivalent to the + operator) and every infix operator taking two parameters can be turned into a corresponding function.Thus:   increment = (+) 1 is the briefest way to create a function that adds one to its argument. Similarly, in   half = (/ 2)  reciprocal = (1 /) two single-parameter functions are generated. The interpreter understands in each case which of the divide operator's two parameters is being supplied, giving functions which respectively divide a number by two and return its reciprocal. Although Miranda is a strongly typed programming language, it does not insist on explicit type declarations. If a function's type is not explicitly declared, the interpreter infers it from the type of its parameters and how they are used within the function. In addition to the basic types (char, num, bool), it includes an "anything" type where the type of a parameter does not matter, as in the list-reversing function:   rev [] = []  rev (a:x) = rev x ++ [a] which can be applied to a list of any data type, for which the explicit function type declaration would be:   rev :: [*] -> [*] Finally, it has mechanisms for creating and managing program modules whose internal functions are invisible to programs calling those modules. Sample code[edit] The following Miranda script determines the set of all subsets of a set of numbers  subsets []     = [[]] subsets (x:xs) = [[x] ++ y | y <- ys] ++ ys                  where ys = subsets xs and this is a literate script for a function primeswhich gives the list of all prime numbers > || The infinite list of all prime numbers.The list of potential prime numbers starts as all integers from 2 onwards;as each prime is returned, all the following numbers that can exactly bedivided by it are filtered out of the list of candidates.> primes = sieve [2..]> sieve (p:x) = p : sieve [n | n <- x; n mod p ~= 0] Here, we have some more examples max2 :: num -> num -> nummax2 a b = a, if a>b         = b, otherwisemax3 :: num -> num -> num -> nummax3 a b c = max2 (max2 a b) (max2 a c)multiply :: num -> num -> nummultiply 0 b = 0multiply a b = a + (multiply (a-1) b)fak :: num -> numfak 0 = 1fak 1 = 1fak n = n * (fak n-1)itemnumber::[*]->numitemnumber [] = 0itemnumber (a:x) = 1 + itemnumber xweekday::= Mo|Tu|We|Th|Fr|Sa|SuisWorkDay :: weekday -> boolisWorkDay Sa = FalseisWorkDay Su = FalseisWorkDay anyday = Truetree * ::= E| N (tree *) * (tree *)nodecount :: tree * -> numnodecount E = 0nodecount (N l w r) = nodecount l + 1 + nodecount remptycount :: tree * -> numemptycount E = 1emptycount (N l w r) = emptycount l + emptycount rtreeExample = N ( N (N E 1 E) 3 (N E 4 E)) 5 (N (N E 6 E) 8 (N E 9 E))weekdayTree = N ( N (N E Mo E) Tu (N E We E)) Th (N (N E Fr E) Sa (N E Su))insert :: * -> stree * -> stree *insert x E = N E x Einsert x (N l w E) = N l w xinsert x (N E w r) = N x w rinsert x (N l w r) = insert x l , if x <w                   = insert x r , otherwiselist2searchtree :: [*] -> tree *list2searchtree [] = Elist2searchtree [x] = N E x Elist2searchtree (x:xs) = insert x (list2searchtree xs)maxel :: tree * -> *maxel E = error "empty"maxel (N l w E) = wmaxel (N l w r) = maxel rminel :: tree * -> *minel E = error "empty"minel (N E w r) = wminel (N l w r) = minel l||Traversing: going through values of tree, putting them in listpreorder,inorder,postorder :: tree * -> [*]inorder E = []inorder N l w r = inorder l ++ [w] ++ inorder rpreorder E = []preorder N l w r = [w] ++ preorder l ++ preorder rpostorder E = []postorder N l w r = postorder l ++ postorder r ++ [w]height :: tree * -> numheight E = 0height (N l w r) = 1 + max2 (height l) (height r)amount :: num -> numamount x = x ,if x >= 0amount x = x*(-1), otherwiseand :: bool -> bool -> booland True True = Trueand x y = False|| A AVL-Tree is a tree where the difference between the child nodes is not higher than 1|| i still have to test thisisAvl :: tree * -> boolisAvl E = TrueisAvl (N l w r) = and (isAvl l) (isAvl r), if amount ((nodecount l) - (nodecount r)) < 2                = False, otherwise                                                delete :: * -> tree * -> tree *delete x E = Edelete x (N E x E) = Edelete x (N E x r) = N E (minel r) (delete (minel r) r)delete x (N l x r) = N (delete (maxel l) l) (maxel l) rdelete x (N l w r) = N (delete x l) w (delete x r) References[edit] ^ Hudak, Paul; Hughes, John (2007). "A History of Haskell: being lazy with class". External links[edit] Official website Authority control BNF: cb13328566r (data) LCCN: sh94005695 Retrieved from "https://en.wikipedia.org/w/index.php?title=Miranda_(programming_language)&oldid=986721444" Categories: Declarative programming languages Functional languages History of computing in the United Kingdom Hidden categories: Articles lacking in-text citations from September 2016 All articles lacking in-text citations All articles with unsourced statements Articles with unsourced statements from November 2016 Wikipedia articles with BNF identifiers Wikipedia articles with LCCN identifiers Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages Aragonés Български Čeština Deutsch Ελληνικά Español فارسی Galego 한국어 Italiano 日本語 Português Română Русский Simple English Svenska Тоҷикӣ 中文 Edit links This page was last edited on 2 November 2020, at 16:28 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement