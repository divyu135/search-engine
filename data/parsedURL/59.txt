64-bit computing - Wikipedia 64-bit computing From Wikipedia, the free encyclopedia (Redirected from 64-bit) Jump to navigation Jump to search Use of processors that have a word size of 64 bits "64-bit" redirects here. For 64-bit images in computer graphics, see Deep color. Computer architecture bit widths Bit 1 4 8 12 16 18 24 26 28 30 31 32 36 40 45 48 60 64 128 256 512 bit slicing Application 8 16 32 64 Binary floating-point precision 16 (×½) 24 32 (×1) 40 64 (×2) 80 128 (×4) 256 (×8) Decimal floating point precision 32 64 128 v t e In computer architecture, 64-bit integers, memory addresses, or other data units are those that are 64 bits (8 octets) wide. Also, 64-bit CPU and ALU architectures are those that are based on registers, address buses, or data buses of that size. 64-bit microcomputers are computers in which 64-bit microprocessors are the norm. From the software perspective, 64-bit computing means the use of code with 64-bit virtual memory addresses. However, not all 64-bit instruction sets support full 64-bit virtual memory addresses; x86-64 and ARMv8, for example, support only 48 bits of virtual address, with the remaining 16 bits of the virtual address required to be all 0's or all 1's, and several 64-bit instruction sets support fewer than 64 bits of physical memory address. The term 64-bit describes a generation of computers in which 64-bit processors are the norm. 64 bits is a word size that defines certain classes of computer architecture, buses, memory, and CPUs and, by extension, the software that runs on them. 64-bit CPUs have been used in supercomputers since the 1970s (Cray-1, 1975) and in reduced instruction set computing (RISC) based workstations and servers since the early 1990s, notably the MIPS R4000, R8000, and R10000, the DEC Alpha, the Sun UltraSPARC, and the IBM RS64 and POWER3 and later POWER microprocessors. In 2003, 64-bit CPUs were introduced to the (formerly 32-bit) mainstream personal computer market in the form of x86-64 processors and the PowerPC G5, and were introduced in 2012[1] into the ARM architecture targeting smartphones and tablet computers, first sold on September 20, 2013, in the iPhone 5S powered by the ARMv8-A Apple A7 system on a chip (SoC). A 64-bit register can hold any of 264 (over 18 quintillion or 1.8×1019) different values. The range of integer values that can be stored in 64 bits depends on the integer representation used. With the two most common representations, the range is 0 through 18,446,744,073,709,551,615 (264 − 1) for representation as an (unsigned) binary number, and −9,223,372,036,854,775,808 (−263) through 9,223,372,036,854,775,807 (263 − 1) for representation as two's complement. Hence, a processor with 64-bit memory addresses can directly access 264 bytes (=16 exabytes) of byte-addressable memory. With no further qualification, a 64-bit computer architecture generally has integer and addressing processor registers that are 64 bits wide, allowing direct support for 64-bit data types and addresses. However, a CPU might have external data buses or address buses with different sizes from the registers, even larger (the 32-bit Pentium had a 64-bit data bus, for instance).[2] The term may also refer to the size of low-level data types, such as 64-bit floating-point numbers. Contents 1 Architectural implications 2 History 3 Limits of processors 4 64-bit data timeline 5 64-bit address timeline 6 64-bit operating system timeline 7 64-bit applications 7.1 32-bit vs 64-bit 7.2 Pros and cons 7.3 Software availability 8 64-bit data models 9 Current 64-bit architectures 10 See also 11 Notes 12 References 13 External links Architectural implications[edit] Processor registers are typically divided into several groups: integer, floating-point, single-instruction-multiple-data (SIMD), control, and often special registers for address arithmetic which may have various uses and names such as address, index, or base registers. However, in modern designs, these functions are often performed by more general purpose integer registers. In most processors, only integer or address-registers can be used to address data in memory; the other types of registers cannot. The size of these registers therefore normally limits the amount of directly addressable memory, even if there are registers, such as floating-point registers, that are wider. Most high performance 32-bit and 64-bit processors (some notable exceptions are older or embedded ARM architecture (ARM) and 32-bit MIPS architecture (MIPS) CPUs) have integrated floating point hardware, which is often, but not always, based on 64-bit units of data. For example, although the x86/x87 architecture has instructions able to load and store 64-bit (and 32-bit) floating-point values in memory, the internal floating point data and register format is 80 bits wide, while the general-purpose registers are 32 bits wide. In contrast, the 64-bit Alpha family uses a 64-bit floating-point data and register format, and 64-bit integer registers. History[edit] Many computer instruction sets are designed so that a single integer register can store the memory address to any location in the computer's physical or virtual memory. Therefore, the total number of addresses to memory is often determined by the width of these registers. The IBM System/360 of the 1960s was an early 32-bit computer; it had 32-bit integer registers, although it only used the low order 24 bits of a word for addresses, resulting in a 16 MiB [16 × 10242 bytes] address space. 32-bit superminicomputers, such as the DEC VAX, became common in the 1970s, and 32-bit microprocessors, such as the Motorola 68000 family and the 32-bit members of the x86 family starting with the Intel 80386, appeared in the mid-1980s, making 32 bits something of a de facto consensus as a convenient register size. A 32-bit address register meant that 232 addresses, or 4 GiB of random-access memory (RAM), could be referenced. When these architectures were devised, 4 GB of memory was so far beyond the typical amounts (4 MB) in installations, that this was considered to be enough headroom for addressing. 4.29 billion addresses were considered an appropriate size to work with for another important reason: 4.29 billion integers are enough to assign unique references to most entities in applications like databases. Some supercomputer architectures of the 1970s and 1980s, such as the Cray-1,[3] used registers up to 64 bits wide, and supported 64-bit integer arithmetic, although they did not support 64-bit addressing. In the mid-1980s, Intel i860[4] development began culminating in a (too late[5] for Windows NT) 1989 release; the i860 had 32-bit integer registers and 32-bit addressing, so it was not a fully 64-bit processor, although its graphics unit supported 64-bit integer arithmetic.[6] However, 32 bits remained the norm until the early 1990s, when the continual reductions in the cost of memory led to installations with amounts of RAM approaching 4 GB, and the use of virtual memory spaces exceeding the 4 GB ceiling became desirable for handling certain types of problems. In response, MIPS and DEC developed 64-bit microprocessor architectures, initially for high-end workstation and server machines. By the mid-1990s, HAL Computer Systems, Sun Microsystems, IBM, Silicon Graphics, and Hewlett Packard had developed 64-bit architectures for their workstation and server systems. A notable exception to this trend were mainframes from IBM, which then used 32-bit data and 31-bit address sizes; the IBM mainframes did not include 64-bit processors until 2000. During the 1990s, several low-cost 64-bit microprocessors were used in consumer electronics and embedded applications. Notably, the Nintendo 64[7] and the PlayStation 2 had 64-bit microprocessors before their introduction in personal computers. High-end printers, network equipment, and industrial computers, also used 64-bit microprocessors, such as the Quantum Effect Devices R5000.[citation needed] 64-bit computing started to trickle down to the personal computer desktop from 2003 onward, when some models in Apple's Macintosh lines switched to PowerPC 970 processors (termed G5 by Apple), and AMD released its first 64-bit x86-64 processor. Limits of processors[edit] This section needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed. (January 2010) (Learn how and when to remove this template message) In principle, a 64-bit microprocessor can address 16 EiBs (16 × 10246 = 264 = 18,446,744,073,709,551,616 bytes, or about 18.4 exabytes) of memory. However, not all instruction sets, and not all processors implementing those instruction sets, support a full 64-bit virtual or physical address space. The x86-64 architecture (as of 2016[update]) allows 48 bits for virtual memory and, for any given processor, up to 52 bits for physical memory.[8][9] These limits allow memory sizes of 256 TiB (256 × 10244 bytes) and 4 PiB (4 × 10245 bytes), respectively. A PC cannot currently contain 4 pebibytes of memory (due to the physical size of the memory chips), but AMD envisioned large servers, shared memory clusters, and other uses of physical address space that might approach this in the foreseeable future. Thus the 52-bit physical address provides ample room for expansion while not incurring the cost of implementing full 64-bit physical addresses. Similarly, the 48-bit virtual address space was designed to provide 65,536 (216) times the 32-bit limit of 4 GiB (4 × 10243 bytes), allowing room for later expansion and incurring no overhead of translating full 64-bit addresses. The Power ISA v3.0 allows 64 bits for an effective address, mapped to a segmented address with between 65 and 78 bits allowed, for virtual memory, and, for any given processor, up to 60 bits for physical memory.[10] The Oracle SPARC Architecture 2015 allows 64 bits for virtual memory and, for any given processor, between 40 and 56 bits for physical memory.[11] The ARM AArch64 Virtual Memory System Architecture allows 48 bits for virtual memory and, for any given processor, from 32 to 48 bits for physical memory.[12] The DEC Alpha specification requires minimum of 43 bits of virtual memory address space (8 TiB) to be supported, and hardware need to check and trap if the remaining unsupported bits are zero (to support compatibility on future processors). Alpha 21064 supported 43 bits of virtual memory address space (8 TiB) and 34 bits of physical memory address space (16 GiB). Alpha 21164 supported 43 bits of virtual memory address space (8TiB) and 40 bits of physical memory address space (1TiB). Alpha 21264 supported user-configurable 43 or 48 bits of virtual memory address space (8TiB or 256TiB) and 44 bits of physical memory address space (16TiB). 64-bit data timeline[edit] 1961 IBM delivers the IBM 7030 Stretch supercomputer, which uses 64-bit data words and 32- or 64-bit instruction words. 1974 Control Data Corporation launches the CDC Star-100 vector supercomputer, which uses a 64-bit word architecture (prior CDC systems were based on a 60-bit architecture). International Computers Limited launches the ICL 2900 Series with 32-bit, 64-bit, and 128-bit two's complement integers; 64-bit and 128-bit floating point; 32-bit, 64-bit, and 128-bit packed decimal and a 128-bit accumulator register. The architecture has survived through a succession of ICL and Fujitsu machines. The latest is the Fujitsu Supernova, which emulates the original environment on 64-bit Intel processors. 1976 Cray Research delivers the first Cray-1 supercomputer, which is based on a 64-bit word architecture and will form the basis for later Cray vector supercomputers. 1983 Elxsi launches the Elxsi 6400 parallel minisupercomputer. The Elxsi architecture has 64-bit data registers but a 32-bit address space. 1989 Intel introduces the Intel i860 reduced instruction set computing (RISC) processor. Marketed as a "64-Bit Microprocessor", it had essentially a 32-bit architecture, enhanced with a 3D graphics unit capable of 64-bit integer operations.[13] 1993 Atari introduces the Atari Jaguar video game console, which includes some 64-bit wide data paths in its architecture.[14] 64-bit address timeline[edit] 1991 MIPS Computer Systems produces the first 64-bit microprocessor, the R4000, which implements the MIPS III architecture, the third revision of its MIPS architecture.[15] The CPU is used in SGI graphics workstations starting with the IRIS Crimson. Kendall Square Research deliver their first KSR1 supercomputer, based on a proprietary 64-bit RISC processor architecture running OSF/1. 1992 Digital Equipment Corporation (DEC) introduces the pure 64-bit Alpha architecture which was born from the Prism project.[16] 1994 Intel announces plans for the 64-bit IA-64 architecture (jointly developed with Hewlett-Packard) as a successor to its 32-bit IA-32 processors. A 1998 to 1999 launch date was targeted. 1995 Sun launches a 64-bit SPARC processor, the UltraSPARC.[17] Fujitsu-owned HAL Computer Systems launches workstations based on a 64-bit CPU, HAL's independently designed first-generation SPARC64. IBM releases the A10 and A30 microprocessors, the first 64-bit PowerPC AS processors.[18] IBM also releases a 64-bit AS/400 system upgrade, which can convert the operating system, database and applications. 1996 Nintendo introduces the Nintendo 64 video game console, built around a low-cost variant of the MIPS R4000. HP releases the first implementation of its 64-bit PA-RISC 2.0 architecture, the PA-8000.[19] 1998 IBM releases the POWER3 line of full-64-bit PowerPC/POWER processors.[20] 1999 Intel releases the instruction set for the IA-64 architecture. AMD publicly discloses its set of 64-bit extensions to IA-32, called x86-64 (later branded AMD64). 2000 IBM ships its first 64-bit z/Architecture mainframe, the zSeries z900. z/Architecture is a 64-bit version of the 32-bit ESA/390 architecture, a descendant of the 32-bit System/360 architecture. 2001 Intel ships its IA-64 processor line, after repeated delays in getting to market. Now branded Itanium and targeting high-end servers, sales fail to meet expectations. 2003 AMD introduces its Opteron and Athlon 64 processor lines, based on its AMD64 architecture which is the first x86-based 64-bit processor architecture. Apple also ships the 64-bit "G5" PowerPC 970 CPU produced by IBM. Intel maintains that its Itanium chips would remain its only 64-bit processors. 2004 Intel, reacting to the market success of AMD, admits it has been developing a clone of the AMD64 extensions named IA-32e (later renamed EM64T, then yet again renamed to Intel 64). Intel ships updated versions of its Xeon and Pentium 4 processor families supporting the new 64-bit instruction set. VIA Technologies announces the Isaiah 64-bit processor.[21] 2006 Sony, IBM, and Toshiba begin manufacturing the 64-bit Cell processor for use in the PlayStation 3, servers, workstations, and other appliances. Intel released Core 2 Duo as the first mainstream x86-64 processor for its mobile, desktop, and workstation line. Prior 64-bit extension processor lines were not widely available in the consumer retail market (most of 64-bit Pentium 4/D were OEM), 64-bit Pentium 4, Pentium D, and Celeron were not into mass production until late 2006 due to poor yield issue (most of good yield wafers were targeted at server and mainframe while mainstream still remain 130 nm 32-bit processor line until 2006) and soon became low end after Core 2 debuted. AMD released their first 64-bit mobile processor and manufactured in 90 nm. 2011 ARM Holdings announces ARMv8-A, the first 64-bit version of the ARM architecture.[22] 2012 ARM Holdings announced their Cortex-A53 and Cortex-A57 cores, their first cores based on their 64-bit architecture, on 30 October 2012.[1][23] 2013 Apple announces the iPhone 5S, with the world's first 64-bit processor in a smartphone, which uses their A7 ARMv8-A-based system-on-a-chip. 2014 Google announces the Nexus 9 tablet, the first Android device to run on the 64-bit Tegra K1 chip. 64-bit operating system timeline[edit] 1985 Cray releases UNICOS, the first 64-bit implementation of the Unix operating system.[24] 1993 DEC releases the 64-bit DEC OSF/1 AXP Unix-like operating system (later renamed Tru64 UNIX) for its systems based on the Alpha architecture. 1994 Support for the R8000 processor is added by Silicon Graphics to the IRIX operating system in release 6.0. 1995 DEC releases OpenVMS 7.0, the first full 64-bit version of OpenVMS for Alpha. First 64-bit Linux distribution for the Alpha architecture is released.[25] 1996 Support for the R4x00 processors in 64-bit mode is added by Silicon Graphics to the IRIX operating system in release 6.2. 1998 Sun releases Solaris 7, with full 64-bit UltraSPARC support. 2000 IBM releases z/OS, a 64-bit operating system descended from MVS, for the new zSeries 64-bit mainframes; 64-bit Linux on z Systems follows the CPU release almost immediately. 2001 Linux becomes the first OS kernel to fully support x86-64 (on a simulator, as no x86-64 processors had been released yet).[26] 2001 Microsoft releases Windows XP 64-Bit Edition for the Itanium's IA-64 architecture, although it was able to run 32-bit applications through an execution layer. 2003 Apple releases its Mac OS X 10.3 "Panther" operating system which adds support for native 64-bit integer arithmetic on PowerPC 970 processors.[27] Several Linux distributions release with support for AMD64. FreeBSD releases with support for AMD64. 2005 On January 4, Microsoft discontinues Windows XP 64-Bit Edition, as no PCs with IA-64 processors had been available since the previous September, and announces that it is developing x86-64 versions of Windows to replace it.[28] On January 31, Sun releases Solaris 10 with support for AMD64 and EM64T processors. On April 29, Apple releases Mac OS X 10.4 "Tiger" which provides limited support for 64-bit command-line applications on machines with PowerPC 970 processors; later versions for Intel-based Macs supported 64-bit command-line applications on Macs with EM64T processors. On April 30, Microsoft releases Windows XP Professional x64 Edition and Windows Server 2003 x64 Edition for AMD64 and EM64T processors.[29] 2006 Microsoft releases Windows Vista, including a 64-bit version for AMD64/EM64T processors that retains 32-bit compatibility. In the 64-bit version, all Windows applications and components are 64-bit, although many also have their 32-bit versions included for compatibility with plug-ins. 2007 Apple releases Mac OS X 10.5 "Leopard", which fully supports 64-bit applications on machines with PowerPC 970 or EM64T processors. 2009 Microsoft releases Windows 7, which, like Windows Vista, includes a full 64-bit version for AMD64/Intel 64 processors; most new computers are loaded by default with a 64-bit version. Microsoft also releases Windows Server 2008 R2, which is the first 64-bit only server operating system. Apple releases Mac OS X 10.6, "Snow Leopard", which ships with a 64-bit kernel for AMD64/Intel64 processors, although only certain recent models of Apple computers will run the 64-bit kernel by default. Most applications bundled with Mac OS X 10.6 are now also 64-bit.[27] 2011 Apple releases Mac OS X 10.7, "Lion", which runs the 64-bit kernel by default on supported machines. Older machines that are unable to run the 64-bit kernel run the 32-bit kernel, but, as with earlier releases, can still run 64-bit applications; Lion does not support machines with 32-bit processors. Nearly all applications bundled with Mac OS X 10.7 are now also 64-bit, including iTunes. 2012 Microsoft releases Windows 8 which supports UEFI Class 3 (UEFI without CSM) and Secure Boot.[30] 2013 Apple releases iOS 7, which, on machines with AArch64 processors, has a 64-bit kernel that supports 64-bit applications. 2014 Google releases Android Lollipop, the first version of the Android operating system with support for 64-bit processors. 2017 Apple releases iOS 11, supporting only machines with AArch64 processors. It has a 64-bit kernel that only supports 64-bit applications. 32-bit applications are no longer compatible. 2019 Apple releases macOS 10.15 "Catalina", dropping support for 32-bit Intel applications. 64-bit applications[edit] 32-bit vs 64-bit[edit] A change from a 32-bit to a 64-bit architecture is a fundamental alteration, as most operating systems must be extensively modified to take advantage of the new architecture, because that software has to manage the actual memory addressing hardware.[31] Other software must also be ported to use the new abilities; older 32-bit software may be supported either by virtue of the 64-bit instruction set being a superset of the 32-bit instruction set, so that processors that support the 64-bit instruction set can also run code for the 32-bit instruction set, or through software emulation, or by the actual implementation of a 32-bit processor core within the 64-bit processor, as with some Itanium processors from Intel, which included an IA-32 processor core to run 32-bit x86 applications. The operating systems for those 64-bit architectures generally support both 32-bit and 64-bit applications.[32] One significant exception to this is the AS/400, software for which is compiled into a virtual instruction set architecture (ISA) called Technology Independent Machine Interface (TIMI); TIMI code is then translated to native machine code by low-level software before being executed. The translation software is all that must be rewritten to move the full OS and all software to a new platform, as when IBM transitioned the native instruction set for AS/400 from the older 32/48-bit IMPI to the newer 64-bit PowerPC-AS, codenamed Amazon. The IMPI instruction set was quite different from even 32-bit PowerPC, so this transition was even bigger than moving a given instruction set from 32 to 64 bits. On 64-bit hardware with x86-64 architecture (AMD64), most 32-bit operating systems and applications can run with no compatibility issues. While the larger address space of 64-bit architectures makes working with large data sets in applications such as digital video, scientific computing, and large databases easier, there has been considerable debate on whether they or their 32-bit compatibility modes will be faster than comparably priced 32-bit systems for other tasks. A compiled Java program can run on a 32- or 64-bit Java virtual machine with no modification. The lengths and precision of all the built-in types, such as char, short, int, long, float, and double, and the types that can be used as array indices, are specified by the standard and are not dependent on the underlying architecture. Java programs that run on a 64-bit Java virtual machine have access to a larger address space.[33] Speed is not the only factor to consider in comparing 32-bit and 64-bit processors. Applications such as multi-tasking, stress testing, and clustering – for high-performance computing (HPC) – may be more suited to a 64-bit architecture when deployed appropriately. For this reason, 64-bit clusters have been widely deployed in large organizations, such as IBM, HP, and Microsoft. Summary: A 64-bit processor performs best with 64-bit software. A 64-bit processor may have backward compatibility, allowing it to run 32-bit application software for the 32-bit version of its instruction set, and may also support running 32-bit operating systems for the 32-bit version of its instruction set. A 32-bit processor is incompatible with 64-bit software. Pros and cons[edit] A common misconception is that 64-bit architectures are no better than 32-bit architectures unless the computer has more than 4 GiB of random-access memory.[34] This is not entirely true: Some operating systems and certain hardware configurations limit the physical memory space to 3 GiB on IA-32 systems, due to much of the 3–4 GiB region being reserved for hardware addressing; see 3 GB barrier; 64-bit architectures can address far more than 4 GiB. However, IA-32 processors from the Pentium Pro onward allow a 36-bit physical memory address space, using Physical Address Extension (PAE), which gives a 64 GiB physical address range, of which up to 62 GiB may be used by main memory; operating systems that support PAE may not be limited to 4 GiB of physical memory, even on IA-32 processors. However, drivers and other kernel mode software, more so older versions, may be incompatible with PAE; this has been cited as the reason for 32-bit versions of Microsoft Windows being limited to 4 GiB of physical RAM[35] (although the validity of this explanation has been disputed[36]). Some operating systems reserve portions of process address space for OS use, effectively reducing the total address space available for mapping memory for user programs. For instance, 32-bit Windows reserves 1 or 2 GiB (depending on the settings) of the total address space for the kernel, which leaves only 3 or 2 GiB (respectively) of the address space available for user mode. This limit is much higher on 64-bit operating systems. Memory-mapped files are becoming more difficult to implement in 32-bit architectures as files of over 4 GiB become more common; such large files cannot be memory-mapped easily to 32-bit architectures, as only part of the file can be mapped into the address space at a time, and to access such a file by memory mapping, the parts mapped must be swapped into and out of the address space as needed. This is a problem, as memory mapping, if properly implemented by the OS, is one of the most efficient disk-to-memory methods. Some 64-bit programs, such as encoders, decoders and encryption software, can benefit greatly from 64-bit registers,[citation needed] while the performance of other programs, such as 3D graphics-oriented ones, remains unaffected when switching from a 32-bit to a 64-bit environment.[citation needed] Some 64-bit architectures, such as x86-64, support more general-purpose registers than their 32-bit counterparts (although this is not due specifically to the word length). This leads to a significant speed increase for tight loops since the processor does not have to fetch data from the cache or main memory if the data can fit in the available registers. Example in C: int a, b, c, d, e;for (a = 0; a < 100; a++){    b = a;    c = b;    d = c;    e = d;} If a processor only has the ability to keep two or three values or variables in registers, it would need to move some values between memory and registers to be able to process variables d and e also; this is a process that takes many CPU cycles. A processor that is able to hold all values and variables in registers can loop through them with no need to move data between registers and memory for each iteration. This behavior can easily be compared with virtual memory, although any effects are contingent on the compiler. The main disadvantage of 64-bit architectures is that, relative to 32-bit architectures, the same data occupies more space in memory (due to longer pointers and possibly other types, and alignment padding). This increases the memory requirements of a given process and can have implications for efficient processor cache use. Maintaining a partial 32-bit model is one way to handle this, and is in general reasonably effective. For example, the z/OS operating system takes this approach, requiring program code to reside in 31-bit address spaces (the high order bit is not used in address calculation on the underlying hardware platform) while data objects can optionally reside in 64-bit regions. Not all such applications require a large address space or manipulate 64-bit data items, so these applications do not benefit from these features. Software availability[edit] x86-based 64-bit systems sometimes lack equivalents of software that is written for 32-bit architectures. The most severe problem in Microsoft Windows is incompatible device drivers for obsolete hardware. Most 32-bit application software can run on a 64-bit operating system in a compatibility mode, also termed an emulation mode, e.g., Microsoft WoW64 Technology for IA-64 and AMD64. The 64-bit Windows Native Mode[37] driver environment runs atop 64-bit NTDLL.DLL, which cannot call 32-bit Win32 subsystem code (often devices whose actual hardware function is emulated in user mode software, like Winprinters). Because 64-bit drivers for most devices were unavailable until early 2007 (Vista x64), using a 64-bit version of Windows was considered a challenge. However, the trend has since moved toward 64-bit computing, more so as memory prices dropped and the use of more than 4 GB of RAM increased. Most manufacturers started to provide both 32-bit and 64-bit drivers for new devices, so unavailability of 64-bit drivers ceased to be a problem. 64-bit drivers were not provided for many older devices, which could consequently not be used in 64-bit systems. Driver compatibility was less of a problem with open-source drivers, as 32-bit ones could be modified for 64-bit use. Support for hardware made before early 2007, was problematic for open-source platforms,[citation needed] due to the relatively small number of users. 64-bit versions of Windows cannot run 16-bit software. However, most 32-bit applications will work well. 64-bit users are forced to install a virtual machine of a 16- or 32-bit operating system to run 16-bit applications.[38] Mac OS X 10.4 "Tiger" and Mac OS X 10.5 "Leopard" had only a 32-bit kernel, but they can run 64-bit user-mode code on 64-bit processors. Mac OS X 10.6 "Snow Leopard" had both 32- and 64-bit kernels, and, on most Macs, used the 32-bit kernel even on 64-bit processors. This allowed those Macs to support 64-bit processes while still supporting 32-bit device drivers; although not 64-bit drivers and performance advantages that can come with them. Mac OS X 10.7 "Lion" ran with a 64-bit kernel on more Macs, and OS X 10.8 "Mountain Lion" and later macOS releases only have a 64-bit kernel. On systems with 64-bit processors, both the 32- and 64-bit macOS kernels can run 32-bit user-mode code, and all versions of macOS include 32-bit versions of libraries that 32-bit applications would use, so 32-bit user-mode software for macOS will run on those systems. Linux and most other Unix-like operating systems, and the C and C++ toolchains for them, have supported 64-bit processors for many years. Many applications and libraries for those platforms are open-source software, written in C and C++, so that if they are 64-bit-safe, they can be compiled into 64-bit versions. This source-based distribution model, with an emphasis on frequent releases, makes availability of application software for those operating systems less of an issue. 64-bit data models[edit] In 32-bit programs, pointers and data types such as integers generally have the same length. This is not necessarily true on 64-bit machines.[39][40][41] Mixing data types in programming languages such as C and its descendants such as C++ and Objective-C may thus work on 32-bit implementations but not on 64-bit implementations. In many programming environments for C and C-derived languages on 64-bit machines, int variables are still 32 bits wide, but long integers and pointers are 64 bits wide. These are described as having an LP64 data model.[42][43] Other models are the ILP64 data model in which all three data types are 64 bits wide,[44][43] and even the SILP64 model where short integers are also 64 bits wide.[45][46] However, in most cases the modifications required are relatively minor and straightforward, and many well-written programs can simply be recompiled for the new environment with no changes. Another alternative is the LLP64 model, which maintains compatibility with 32-bit code by leaving both int and long as 32-bit.[47][43] LL refers to the long long integer type, which is at least 64 bits on all platforms, including 32-bit environments. 64-bit data models Data model short (integer) int long (integer) long long pointers, size_t Sample operating systems LLP64 16 32 32 64 64 Microsoft Windows (x86-64 and IA-64) using Visual C++; and MinGW LP64 16 32 64 64 64 Most Unix and Unix-like systems, e.g., Solaris, Linux, BSD, macOS. Windows when using Cygwin; z/OS ILP64 16 64 64 64 64 HAL Computer Systems port of Solaris to the SPARC64 SILP64 64 64 64 64 64 Classic UNICOS[45][46] (versus UNICOS/mp, etc.) Many 64-bit platforms today use an LP64 model (including Solaris, AIX, HP-UX, Linux, macOS, BSD, and IBM z/OS). Microsoft Windows uses an LLP64 model. The disadvantage of the LP64 model is that storing a long into an int may truncate. On the other hand, converting a pointer to a long will “work” in LP64. In the LLP64 model, the reverse is true. These are not problems which affect fully standard-compliant code, but code is often written with implicit assumptions about the widths of data types. C code should prefer (u)intptr_t instead of long when casting pointers into integer objects. A programming model is a choice made to suit a given compiler, and several can coexist on the same OS. However, the programming model chosen as the primary model for the OS application programming interface (API) typically dominates. Another consideration is the data model used for device drivers. Drivers make up the majority of the operating system code in most modern operating systems[citation needed] (although many may not be loaded when the operating system is running). Many drivers use pointers heavily to manipulate data, and in some cases have to load pointers of a certain size into the hardware they support for direct memory access (DMA). As an example, a driver for a 32-bit PCI device asking the device to DMA data into upper areas of a 64-bit machine's memory could not satisfy requests from the operating system to load data from the device to memory above the 4 gibibyte barrier, because the pointers for those addresses would not fit into the DMA registers of the device. This problem is solved by having the OS take the memory restrictions of the device into account when generating requests to drivers for DMA, or by using an input–output memory management unit (IOMMU). Current 64-bit architectures[edit] As of May 2018[update], 64-bit architectures for which processors are being manufactured include: The 64-bit extension created by AMD to Intel's x86 architecture (later licensed by Intel); commonly termed x86-64, AMD64, or x64: AMD's AMD64 extensions (used in Athlon 64, Opteron, Sempron, Turion 64, Phenom, Athlon II, Phenom II, APU, FX, Ryzen, and Epyc processors) Intel's Intel 64 extensions, used in Intel Core 2/i3/i5/i7/i9, some Atom, and newer Celeron, Pentium, and Xeon processors Intel's K1OM architecture, a variant of Intel 64 with no CMOV, MMX, and SSE instructions, used in Xeon Phi coprocessors, binary incompatible with x86-64 programs VIA Technologies' 64-bit extensions, used in the VIA Nano processors IBM's PowerPC/Power ISA: IBM's POWER4, POWER5, POWER6, POWER7, POWER8, POWER9, and IBM A2 processors SPARC V9 architecture: Oracle's M8 and S7 processors Fujitsu's SPARC64 XII and SPARC64 XIfx processors IBM's z/Architecture, a 64-bit version of the ESA/390 architecture, used in IBM's eServer zSeries and System z mainframes: IBM z13 and z14 Hitachi AP8000E HP-Intel's IA-64 architecture: Intel's Itanium processors MIPS Technologies' MIPS64 architecture ARM Holdings' AArch64 architecture Elbrus architecture: Elbrus-8S NEC SX architecture SX-Aurora TSUBASA RISC-V Most architectures of 64 bits that are derived from the same architecture of 32 bits can execute code written for the 32-bit versions natively, with no performance penalty.[citation needed] This kind of support is commonly called bi-arch support or more generally multi-arch support. See also[edit] Computer memory Notes[edit] This article is based on material taken from the Free On-line Dictionary of Computing prior to 1 November 2008 and incorporated under the "relicensing" terms of the GFDL, version 1.3 or later. References[edit] ^ a b "ARM Launches Cortex-A50 Series, the World's Most Energy-Efficient 64-bit Processors" (Press release). ARM Holdings. Retrieved 2012-10-31. ^ Pentium Processor User's Manual Volume 1: Pentium Processor Data Book (PDF). Intel. 1993. ^ "Cray-1 Computer System Hardware Reference Manual" (PDF). Cray Research. 1977. Retrieved October 8, 2013. ^ Grimes, Jack; Kohn, Les; Bharadhwaj, Rajeev (July–August 1989). "The Intel i860 64-Bit Processor: A General-Purpose CPU with 3D Graphics Capabilities". IEEE Computer Graphics and Applications. 9 (4): 85–94. doi:10.1109/38.31467. S2CID 38831149. Retrieved 2010-11-19. ^ Zachary, G. Pascal (1994). Showstopper! The Breakneck Race to Create Windows NT and the Next Generation at Microsoft. Warner Books. ISBN 0-02-935671-7. ^ "i860 Processor Family Programmer's Reference Manual" (PDF). Intel. 1991. Retrieved September 12, 2019. ^ "NEC Offers Two High Cost Performance 64-bit RISC Microprocessors" (Press release). NEC. 1998-01-20. Retrieved 2011-01-09. Versions of the VR4300 processor are widely used in consumer and office automation applications, including the popular Nintendo 64TM video game and advanced laser printers such as the recently announced, award-winning Hewlett-Packard LaserJet 4000 printer family. ^ "AMD64 Programmer's Manual Volume 2: System Programming" (PDF). Advanced Micro Devices. December 2016. p. 120. ^ "Intel 64 and IA-32 Architectures Software Developer's Manual Volume 3A: System Programming Guide, Part 1" (PDF). Intel. September 2016. p. 4-2. ^ "Power ISA Version 3.0". IBM. November 30, 2015. p. 983. ^ "Oracle SPARC Architecture 2015 Draft D1.0.9". Oracle. p. 475. ^ "ARM Architecture Reference Manual ARMv8, for ARMv8-A architecture profile". pp. D4-1723, D4-1724, D4-1731. ^ "i860 64-Bit Microprocessor". Intel. 1989. Retrieved 30 November 2010. ^ "Atari Jaguar History". AtariAge. ^ Joe Heinrich (1994). MIPS R4000 Microprocessor User's Manual (2nd ed.). MIPS Technologies, Inc. ^ Richard L. Sites (1992). "Alpha AXP Architecture". Digital Technical Journal. Digital Equipment Corporation. 4 (4). ^ Linley Gwennap (3 October 1994). "UltraSparc Unleashes SPARC Performance". Microprocessor Report. MicroDesign Resources. 8 (13). ^ J. W. Bishop; et al. (July 1996). "PowerPC AS A10 64-bit RISC microprocessor". IBM Journal of Research and Development. IBM Corporation. 40 (4): 495–505. doi:10.1147/rd.404.0495. ^ Linley Gwennap (14 November 1994). "PA-8000 Combines Complexity and Speed". Microprocessor Report. MicroDesign Resources. 8 (15). ^ F. P. O'Connell; S. W. White (November 2000). "POWER3: The next generation of PowerPC processors". IBM Journal of Research and Development. IBM Corporation. 44 (6): 873–884. doi:10.1147/rd.446.0873. ^ "VIA Unveils Details of Next-Generation Isaiah Processor Core". VIA Technologies, Inc. Archived from the original on 2007-10-11. Retrieved 2007-07-18. ^ "ARMv8 Technology Preview" (PDF). October 31, 2011. Retrieved November 15, 2012. ^ "ARM Keynote: ARM Cortex-A53 and ARM Cortex-A57 64bit ARMv8 processors launched". ARMdevices.net. 2012-10-31. ^ Stefan Berka. "Unicos Operating System". www.operating-system.org. Archived from the original on 26 November 2010. Retrieved 2010-11-19. ^ Jon "maddog" Hall (Jun 1, 2000). "My Life and Free Software". Linux Journal. ^ Andi Kleen. Porting Linux to x86-64 (PDF). Ottawa Linux Symposium 2001. Status: The kernel, compiler, tool chain work. The kernel boots and work on simulator and is used for porting of userland and running programs ^ a b John Siracusa. "Mac OS X 10.6 Snow Leopard: the Ars Technica review". Ars Technica. p. 5. Archived from the original on 9 October 2009. Retrieved 2009-09-06. ^ Joris Evers (5 January 2005). "Microsoft nixes Windows XP for Itanium". Computerworld. Archived from the original on 18 June 2013. Retrieved 17 October 2017. ^ "Microsoft Raises the Speed Limit with the Availability of 64-Bit Editions of Windows Server 2003 and Windows XP Professional" (Press release). Microsoft. April 25, 2005. Retrieved September 10, 2015. ^ "UEFI_on_Dell BizClient_Platforms" (PDF). ^ Mashey, John (October 2006). "The Long Road to 64 Bits". ACM Queue. 4 (8): 85–94. doi:10.1145/1165754.1165766. Retrieved 2011-02-19. ^ "Windows 7: 64 bit vs 32 bit?". W7 Forums. Archived from the original on 5 April 2009. Retrieved 2009-04-05. ^ "Frequently Asked Questions About the Java HotSpot VM". Sun Microsystems, Inc. Archived from the original on 10 May 2007. Retrieved 2007-05-03. ^ "A description of the differences between 32-bit versions of Windows Vista and 64-bit versions of Windows Vista". Retrieved 2011-10-14. ^ Mark Russinovich (2008-07-21). "Pushing the Limits of Windows: Physical Memory". Retrieved 2017-03-09. ^ Chappell, Geoff (2009-01-27). "Licensed Memory in 32-Bit Windows Vista". geoffchappell.com. WP:SPS. Retrieved 9 March 2017. ^ "Inside Native Applications". Technet.microsoft.com. 2006-11-01. Archived from the original on 23 October 2010. Retrieved 2010-11-19. ^ Lincoln Spector (August 12, 2013). "Run an old program on a new PC". ^ Peter Seebach (2006). "Exploring 64-bit development on POWER5: How portable is your code, really?". ^ Henry Spencer. "The Ten Commandments for C Programmers". ^ "The Story of Thud and Blunder". Datacenterworks.com. Retrieved 2010-11-19. ^ "ILP32 and LP64 data models and data type sizes". z/OS XL C/C++ Programming Guide. ^ a b c "64-BIT PROGRAMMING MODELS". Retrieved 2020-06-05. ^ "Using the ILP64 Interface vs. LP64 Interface". Intel. Retrieved Jun 24, 2020. ^ a b "Cray C/C++ Reference Manual". August 1998. Table 9-1. Cray Research systems data type mapping. Archived from the original on October 16, 2013. Retrieved October 15, 2013. ^ a b "Cray C and C++ Reference Manual (8.7) S-2179". Retrieved Jun 24, 2020. ^ "Abstract Data Models - Windows applications". May 30, 2018. External links[edit] 64-bit Transition Guide, Mac Developer Library Andrey Karpov. A Collection of Examples of 64-bit Errors in Real Programs Mark J. Kilgard. "Is your X code ready for 64-bit?". Archived from the original on June 3, 2001. Retrieved September 26, 2012. Lessons on development of 64-bit C/C++ applications 64-Bit Programming Models: Why LP64? AMD64 (EM64T) architecture v t e Processor technologies Models Turing machine Universal Post–Turing Quantum Belt machine Stack machine Finite-state machine with datapath Hierarchical Queue automaton Register machines Counter Pointer Random-access Random-access stored program Architecture Microarchitecture Von Neumann Harvard modified Dataflow Transport-triggered Cellular Endianness Memory access NUMA HUMA Load/store Register/memory Cache hierarchy Memory hierarchy Virtual memory Secondary storage Heterogeneous Fabric Multiprocessing Cognitive Neuromorphic Instruction set architectures Types CISC RISC Application-specific EDGE TRIPS VLIW EPIC MISC OISC NISC ZISC Comparison Addressing modes Instruction sets x86 ARM MIPS Power ISA SPARC Itanium Unicore MicroBlaze RISC-V LMC Others Execution Instruction pipelining Pipeline stall Operand forwarding Classic RISC pipeline Hazards Data dependency Structural Control False sharing Out-of-order Tomasulo algorithm Reservation station Re-order buffer Register renaming Speculative Branch prediction Memory dependence prediction Parallelism Level Bit Bit-serial Word Instruction Pipelining Scalar Superscalar Task Thread Process Data Vector Memory Distributed Multithreading Temporal Simultaneous Hyperthreading Speculative Preemptive Cooperative Flynn's taxonomy SISD SIMD SWAR SIMT MISD MIMD SPMD Processor performance Transistor count Instructions per cycle (IPC) Cycles per instruction (CPI) Instructions per second (IPS) Floating-point operations per second (FLOPS) Transactions per second (TPS) Synaptic updates per second (SUPS) Performance per watt (PPW) Cache performance metrics Computer performance by orders of magnitude Types Central processing unit (CPU) Graphics processing unit (GPU) GPGPU Vector Barrel Stream Coprocessor ASIC FPGA CPLD Multi-chip module (MCM) System in package (SiP) By application Microprocessor Microcontroller Mobile Notebook Ultra-low-voltage ASIP Systems on chip System on a chip (SoC) Multiprocessor (MPSoC) Programmable (PSoC) Network on a chip (NoC) Hardware accelerators AI accelerator Vision processing unit (VPU) Physics processing unit (PPU) Digital signal processor (DSP) Tensor processing unit (TPU) Secure cryptoprocessor Network processor Baseband processor Word size 1-bit 4-bit 8-bit 12-bit 15-bit 16-bit 24-bit 32-bit 48-bit 64-bit 128-bit 256-bit 512-bit bit slicing others variable Core count Single-core Multi-core Manycore Heterogeneous architecture Components Core Cache CPU cache replacement policies coherence Bus Clock rate Clock signal FIFO Functional units Arithmetic logic unit (ALU) Address generation unit (AGU) Floating-point unit (FPU) Memory management unit (MMU) Load–store unit Translation lookaside buffer (TLB) Integrated memory controller (IMC) Logic Combinational Sequential Glue Logic gate Quantum Array Registers Processor register Status register Stack register Register file Memory buffer Program counter Control unit Instruction unit Data buffer Write buffer Microcode ROM Counter Datapath Multiplexer Demultiplexer Adder Multiplier CPU Binary decoder Address decoder Sum addressed decoder Barrel shifter Circuitry Integrated circuit 3D Mixed-signal Power management Boolean Digital Analog Quantum Switch Power management PMU APM ACPI Dynamic frequency scaling Dynamic voltage scaling Clock gating Performance per watt (PPW) Race to sleep Related History of general-purpose CPUs Microprocessor chronology Processor design Digital electronics Hardware security module Semiconductor device fabrication Tick–tock model Retrieved from "https://en.wikipedia.org/w/index.php?title=64-bit_computing&oldid=991962870" Categories: 64-bit computers Data unit Hidden categories: Articles with short description Short description matches Wikidata All articles with unsourced statements Articles with unsourced statements from August 2017 Articles needing additional references from January 2010 All articles needing additional references Articles containing potentially dated statements from 2016 All articles containing potentially dated statements Articles with unsourced statements from February 2015 Articles with unsourced statements from February 2013 Articles with unsourced statements from May 2011 Articles containing potentially dated statements from May 2018 Articles with unsourced statements from September 2010 Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages العربية Català Čeština Deutsch Eesti Español Français 한국어 Bahasa Indonesia Italiano Latviešu Magyar മലയാളം Bahasa Melayu 日本語 Norsk bokmål Occitan Polski Português Română Русский Simple English Slovenčina தமிழ் Українська Tiếng Việt 吴语 中文 Edit links This page was last edited on 2 December 2020, at 19:14 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement