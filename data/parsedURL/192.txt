Control store - Wikipedia Control store From Wikipedia, the free encyclopedia Jump to navigation Jump to search A control store is the part of a CPU's control unit that stores the CPU's microprogram. It is usually accessed by a microsequencer. A control store implementation whose contents are unalterable is known as a Read Only Memory (ROM) or Read Only Storage (ROS); one whose contents are alterable is known as a Writable Control Store (WCS). Contents 1 Implementation 1.1 Early use 1.2 Writable stores 1.3 Timing, latching and avoiding a race condition 2 References Implementation[edit] Early use[edit] Early control stores were implemented as a diode-array accessed via address decoders, a form of read-only memory. This tradition dates back to the program timing matrix on the MIT Whirlwind, first described in 1947. Modern VLSI processors instead use matrices of field-effect transistors to build the ROM and/or PLA structures used to control the processor as well as its internal sequencer in a microcoded implementation. IBM System/360 used a variety of techniques: CCROS (Card Capacitor Read-Only Storage) on the Model 30, TROS (Transformer Read-Only Storage) on the Model 40, and BCROS (Balanced Capacitor Read-Only Storage) on the Model 50. Writable stores[edit] Some computers were built using "writable microcode" — rather than storing the microcode in ROM or hard-wired logic, the microcode was stored in a RAM called a writable control store or WCS. Such a computer is sometimes called a Writable Instruction Set Computer or WISC.[1] Many of these machines were experimental laboratory prototypes, such as the WISC CPU/16[2] and the RTX 32P.[3] The original System/360 models had read-only control store, but later System/360, System/370 and successor models loaded part or all of their microprograms from floppy disks or other DASD into a writable control store consisting of ultra-high speed random-access read-write memory. The System/370 architecture included a facility called Initial-Microprogram Load (IML or IMPL)[4] that could be invoked from the console, as part of Power On Reset (POR) or from another processor in a tightly coupled multiprocessor complex. This permitted IBM to easily repair microprogramming defects in the field. Even when the majority of the control store is stored in ROM, computer vendors would often sell writable control store as an option, allowing the customers to customize the machine's microprogram. Other vendors, e.g., IBM, use the WCS to run microcode for emulator features[5][6] and hardware diagnostics.[7] Other commercial machines that used writable microcode include the Burroughs Small Systems (1970s and 1980s), the Xerox processors in their Lisp machines and Xerox Star workstations, the DEC VAX 8800 ("Nautilus") family, and the Symbolics L- and G-machines (1980s). Some DEC PDP-10 machines stored their microcode in SRAM chips (about 80 bits wide x 2 Kwords), which was typically loaded on power-on through some other front-end CPU.[8] Many more machines offered user-programmable writable control stores as an option (including the HP 2100, DEC PDP-11/60 and Varian Data Machines V-70 series minicomputers).The Mentec M11 and Mentec M1 stored its microcode in SRAM chips, loaded on power-on through another CPU.The Data General Eclipse MV/8000 ("Eagle") had a SRAM writable control store, loaded on power-on through another CPU.[9] WCS offered several advantages including the ease of patching the microprogram and, for certain hardware generations, faster access than ROMs could provide. User-programmable WCS allowed the user to optimize the machine for specific purposes. Some CPU designs compile the instruction set to a writable RAM or FLASH inside the CPU (such as the Rekursiv processor and the Imsys Cjip),[10] or an FPGA (reconfigurable computing). Several Intel CPUs in the x86 architecture family have writable microcode,[11] starting with the Pentium Pro in 1995.[12]This has allowed bugs in the Intel Core 2 microcode and Intel Xeon microcode to be fixed in software, rather than requiring the entire chip to be replaced.Such fixes can be installed by Linux,[13] FreeBSD,[14] Microsoft Windows,[15] or the motherboard BIOS.[16] Timing, latching and avoiding a race condition[edit] The control store usually has a register on its outputs. The outputs that go back into the sequencer to determine the next address have to go through some sort of register to prevent the creation of a race condition. In most designs all of the other bits also go through a register. This is because the machine will work faster if the execution of the next microinstruction is delayed by one cycle. This register is known as a pipeline register. Very often the execution of the next microinstruction is dependent on the result of the current microinstruction, which will not be stable until the end of the current microcycle. It can be seen that either way, all of the outputs of the control store go into one big register. Historically it used to be possible to buy EPROMs with these register bits on the same chip. The clock signal determining the clock rate, which is the cycle time of the system, primarily clocks this register. References[edit] The Wikibook Microprocessor Design has a page on the topic of: Microcode ^ "Writable instruction set, stack oriented computers: The WISC Concept" article by Philip Koopman Jr. 1987 ^ "Architecture of the WISC CPU/16" by Phil Koopman 1989 ^ "Architecture of the RTX 32P" by Philip Koopman 1989 ^ IBM (September 1974), IBM System/370 Principles of Operation (PDF), Fourth Edition, pp. 98, 245, GA22-7000-4 ^ IBM (June 1968), IBM System/360 Model 85 Functional Characteristics (PDF), SECOND EDITION, A22-6916-1 ^ IBM (March 1969), IBM System/360 Special Feature Description 709/7090/7094 Compatibility Feature for IBM System/360 Model 85, First Edition, GA27-2733-0 ^ IBM (January 1971), IBM System/370 Model 155 Functional Characteristics (PDF), SECOND EDITION, GA22-6942-1 ^ http://pdp10.nocrew.org/cpu/kl10-ucode.txt ^ Mark Smotherman. "CPSC 330 / The Soul of a New Machine". 4096 x 75-bit SRAM writeable control store: 74-bit microinstruction with 1 parity bit (18 fields) ^ "Great Microprocessors of the Past and Present (V 13.4.0)". Cpushack.com. Retrieved 2010-04-26. ^ "Intel(R) 64 and IA-32 Architectures Software Developer’s Manual", Volume 3A: System Programming Guide, Part 1, chapter 9.11: "Microcode update facilities", December 2009. ^ Gwennap, Linley (1997-09-15). "P6 Microcode can be Patched" (PDF). Microprocessor Report. Retrieved 2017-06-26. ^ "Intel Microcode Update Utility for Linux". Archived from the original on 2012-02-26. ^ Stefan Blachmann (2018-03-02). "New microcode updating tool for FreeBSD". freebsd-hackers (Mailing list). Retrieved 2019-07-09. ^ "A microcode reliability update is available that improves the reliability of systems that use Intel processors" ^ "BIOS Update required when Missing Microcode message is seen during POST" Smith, Richard E. (1988). "A Historical Overview of Computer Architecture". Annals of the History of Computing. 10 (4): 277–303. doi:10.1109/MAHC.1988.10039. Retrieved 2006-06-21. v t e Processor technologies Models Turing machine Universal Post–Turing Quantum Belt machine Stack machine Finite-state machine with datapath Hierarchical Queue automaton Register machines Counter Pointer Random-access Random-access stored program Architecture Microarchitecture Von Neumann Harvard modified Dataflow Transport-triggered Cellular Endianness Memory access NUMA HUMA Load/store Register/memory Cache hierarchy Memory hierarchy Virtual memory Secondary storage Heterogeneous Fabric Multiprocessing Cognitive Neuromorphic Instruction set architectures Types CISC RISC Application-specific EDGE TRIPS VLIW EPIC MISC OISC NISC ZISC Comparison Addressing modes Instruction sets x86 ARM MIPS Power ISA SPARC Itanium Unicore MicroBlaze RISC-V LMC Others Execution Instruction pipelining Pipeline stall Operand forwarding Classic RISC pipeline Hazards Data dependency Structural Control False sharing Out-of-order Tomasulo algorithm Reservation station Re-order buffer Register renaming Speculative Branch prediction Memory dependence prediction Parallelism Level Bit Bit-serial Word Instruction Pipelining Scalar Superscalar Task Thread Process Data Vector Memory Distributed Multithreading Temporal Simultaneous Hyperthreading Speculative Preemptive Cooperative Flynn's taxonomy SISD SIMD SWAR SIMT MISD MIMD SPMD Processor performance Transistor count Instructions per cycle (IPC) Cycles per instruction (CPI) Instructions per second (IPS) Floating-point operations per second (FLOPS) Transactions per second (TPS) Synaptic updates per second (SUPS) Performance per watt (PPW) Cache performance metrics Computer performance by orders of magnitude Types Central processing unit (CPU) Graphics processing unit (GPU) GPGPU Vector Barrel Stream Coprocessor ASIC FPGA CPLD Multi-chip module (MCM) System in package (SiP) By application Microprocessor Microcontroller Mobile Notebook Ultra-low-voltage ASIP Systems on chip System on a chip (SoC) Multiprocessor (MPSoC) Programmable (PSoC) Network on a chip (NoC) Hardware accelerators AI accelerator Vision processing unit (VPU) Physics processing unit (PPU) Digital signal processor (DSP) Tensor processing unit (TPU) Secure cryptoprocessor Network processor Baseband processor Word size 1-bit 4-bit 8-bit 12-bit 15-bit 16-bit 24-bit 32-bit 48-bit 64-bit 128-bit 256-bit 512-bit bit slicing others variable Core count Single-core Multi-core Manycore Heterogeneous architecture Components Core Cache CPU cache replacement policies coherence Bus Clock rate Clock signal FIFO Functional units Arithmetic logic unit (ALU) Address generation unit (AGU) Floating-point unit (FPU) Memory management unit (MMU) Load–store unit Translation lookaside buffer (TLB) Integrated memory controller (IMC) Logic Combinational Sequential Glue Logic gate Quantum Array Registers Processor register Status register Stack register Register file Memory buffer Program counter Control unit Instruction unit Data buffer Write buffer Microcode ROM Counter Datapath Multiplexer Demultiplexer Adder Multiplier CPU Binary decoder Address decoder Sum addressed decoder Barrel shifter Circuitry Integrated circuit 3D Mixed-signal Power management Boolean Digital Analog Quantum Switch Power management PMU APM ACPI Dynamic frequency scaling Dynamic voltage scaling Clock gating Performance per watt (PPW) Race to sleep Related History of general-purpose CPUs Microprocessor chronology Processor design Digital electronics Hardware security module Semiconductor device fabrication Tick–tock model Retrieved from "https://en.wikipedia.org/w/index.php?title=Control_store&oldid=963414788" Categories: Instruction processing Firmware Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages Deutsch 한국어 日本語 中文 Edit links This page was last edited on 19 June 2020, at 17:46 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement