Unlambda - Wikipedia Unlambda From Wikipedia, the free encyclopedia (Redirected from UnLamda programming language) Jump to navigation Jump to search This article needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed. Find sources: "Unlambda" – news · newspapers · books · scholar · JSTOR (August 2020) (Learn how and when to remove this template message) Functional programming language Unlambda Paradigm Nearly pure functional Designed by David Madore Developer David Madore First appeared 28 June 1999; 21 years ago (1999-06-28) Stable release 2.0.0 / 20 December 1999; 20 years ago (1999-12-20) Typing discipline Untyped Implementation language Scheme, C, Java License GPL 2.0 or later Website www.madore.org/~david/programs/unlambda Unlambda is a minimal, "nearly pure"[1] functional programming language invented by David Madore. It is based on combinatory logic, an expression system without the lambda operator or free variables. It relies mainly on two built-in functions (s and k) and an apply operator (written `, the backquote character). These alone make it Turing-complete, but there are also some input/output (I/O) functions to enable interacting with the user, some shortcut functions, and a lazy evaluation function. Variables are unsupported. Unlambda is free and open-source software distributed under a GNU General Public License (GPL) 2.0 or later. Contents 1 Basic principles 2 Original built-in functions 3 Version 2 built-in functions 4 See also 5 References 6 External links Basic principles[edit] As an esoteric programming language, Unlambda is meant as a demonstration of very pure functional programming rather than for practical use. Its main feature is the lack of conventional operators and data types—the only kind of data in the program are one-parameter functions. Data can nevertheless be simulated with appropriate functions as in the lambda calculus. Multi-parameter functions can be represented via the method of currying. Unlambda is based on the principle of abstraction elimination, or the elimination of all saved variables, including functions. As a purely functional language, Unlambda's functions are first-class objects, and are the only such objects. Here is an implementation of a hello world program in Unlambda:[1] `r```````````.H.e.l.l.o. .w.o.r.l.di Original built-in functions[edit] The notation .x denotes a function which takes one argument and returns it unchanged, printing the single character x as a side effect when it is invoked. i represents the version of the identity function that has no such side effect; it is used here as a dummy argument. The program `.di applies the d-printing function to a dummy argument of i, returning i and printing the letter d as a side effect. Similarly, ``.l.di first applies .l to .d, printing the letter l and returning .d; this result of .d is then applied to i as in the previous example. The function r is syntactic sugar for the function that prints a newline character. Other important features provided by Unlambda include the k and s functions. k manufactures constant functions: the result of `kx is a function which, when invoked, returns x. Thus the value of ``kxy is x for any x and y. s is a generalized evaluation operator. ```sxyz evaluates to ``xz`yz for any x, y, and z. It is a remarkable fact that s and k are sufficient to perform any calculation, as described in SKI combinator calculus. As a brief example, the identity function i can be implemented as ``skk, since ```skkx yields x for all x. Unlambda's one flow control construct is call with current continuation, denoted c. When an expression of the form `cx is evaluated, a special continuation object is constructed, representing the state of the interpreter at that moment. Then x is evaluated, and then the result is given the continuation object as an argument. If the continuation is never applied to an argument, the value of the `cx expression is the same as the value of x. But if the continuation object is applied to a value y, execution of x is immediately aborted, and the value of the entire `cx expression is y. Unlambda's execution semantics are normally eager evaluation, but a lazy evaluation option exists, indicated by the use of the d operator. Usually, to evaluate an expression of the form `xy, unlambda first evaluates x, then y, and then applies x to y. However, if x evaluates to the special value d, then y is not evaluated; instead, the value of the expression `dy is a special "delayed computation" object, which, when applied to an argument z, evaluates y, and then applies its value to z. In the absence of side effects, this is exactly the same as `iy. The difference is that `iy executes any side effects in y immediately, whereas `dy defers the side effects until the result is applied to another argument. Unlambda's next built-in operator is v, which ignores its argument and returns v. This feature is not strictly necessary, since v could be implemented as ``s`k``s``s`kskk`k``s``s`kskk, but it is supplied as a convenience. (This expression above is simply `Yk, where Y denotes a fixed point combinator.) Version 2 built-in functions[edit] More built-ins were introduced in Unlambda version 2. Input is facilitated by operators @ and ?u. When @ is applied to a function x, a character is read from input, and stored as the "current character"; then x is applied to i. However, if no more characters were available on input, the current character is left undefined, and x is applied to v instead. When a function ?u is applied to a function x, the result is the evaluation of `xi if the current character is u, otherwise `xv is evaluated. There is also a "reprint" operator |. When `|x is evaluated, the function x is applied to .u if u is the current character, or to v if there is no current character. Finally, there is an exit operator e. When e is applied to x, the execution of the program is terminated, and x is taken as the result of the program (most of the currently existing interpreters ignore the result anyway). See also[edit] Iota and Jot SKI combinator calculus References[edit] ^ a b Chu-Carroll, Mark C. (2006-08-11). "Friday Pathological Programming: Unlambda, or Programming Without Variables". Good Math, Bad Math (blog). ScienceBlogs. Felix-Hernandez Campos (1 April 2002), Lecture 28: More on functional programming, University of North Carolina COMP144 原 悠 (Yutaka Hara) (2008). Rubyで作る奇妙なプログラミング言語 (in Japanese). Tōkyō: Mainichikomyunikēshonzu. pp. 205–214. ISBN 4-8399-2784-7. External links[edit] Official website Online Unlambda REPL Retrieved from "https://en.wikipedia.org/w/index.php?title=Unlambda&oldid=973702490" Categories: Esoteric programming languages Functional languages Hidden categories: Articles needing additional references from August 2020 All articles needing additional references Articles with short description Short description matches Wikidata CS1 Japanese-language sources (ja) Official website different in Wikidata and Wikipedia Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages Eesti Español Euskara Français Magyar 日本語 Polski Português Русский Српски / srpski Edit links This page was last edited on 18 August 2020, at 18:48 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement