Ada (programming language) - Wikipedia Ada (programming language) From Wikipedia, the free encyclopedia Jump to navigation Jump to search High-level programming language first released in 1980 Ada Paradigm Multi-paradigm Family Pascal Designed by MIL-STD-1815, Ada 83: Jean Ichbiah Ada 95: Tucker Taft Ada 2005: Tucker Taft Ada 2012: Tucker Taft First appeared February 1980; 40 years ago (1980-02) Stable release Ada 2012 TC1[1][2] / February 1, 2016; 4 years ago (2016-02-01) Preview release Ada 2012 TC1[3] / April 2015; 5 years ago (2015-04) Typing discipline static, strong, safe, nominative OS Multi- or cross-platform Filename extensions .adb, .ads Website www.adaic.org Major implementations AdaCore GNAT (free download: http://libre.adacore.com/download), Green Hills Software Optimising Ada 95 compiler, PTC, Inc. PTC ApexAda and PTC ObjectAda,[4] "MapuSoft Ada-C/C++ changer". , formerly known as "AdaMagic with C Intermediate",[5] DDC-I Score Dialects SPARK, Ravenscar profile Influenced by ALGOL 68, Pascal, C++ (Ada 95), Smalltalk (Ada 95), Modula-2 (Ada 95) Java (Ada 2005), Eiffel (Ada 2012) Influenced C++, Chapel,[6] "Drago". , D, Eiffel, "Griffin". , Java, Nim, ParaSail, PL/SQL, PL/pgSQL, Python, Ruby, Seed7, "SPARforte". , Sparkel, SQL/PSM, VHDL Ada Programming at Wikibooks Ada is a structured, statically typed, imperative, and object-oriented high-level programming language, extended from Pascal and other languages. It has built-in language support for design by contract (DbC), extremely strong typing, explicit concurrency, tasks, synchronous message passing, protected objects, and non-determinism. Ada improves code safety and maintainability by using the compiler to find errors in favor of runtime errors. Ada is an international technical standard, jointly defined by the International Organization for Standardization (ISO), and the International Electrotechnical Commission (IEC). As of 2020[update], the standard, called Ada 2012 informally,[7] is ISO/IEC 8652:2012.[8] Ada was originally designed by a team led by French computer scientist Jean Ichbiah of CII Honeywell Bull under contract to the United States Department of Defense (DoD) from 1977 to 1983 to supersede over 450 programming languages used by the DoD at that time.[9] Ada was named after Ada Lovelace (1815–1852), who has been credited as the first computer programmer.[10] Contents 1 Features 2 History 3 Standardization 4 Language constructs 4.1 "Hello, world!" in Ada 4.2 Data types 4.3 Control structures 4.4 Packages, procedures and functions 4.5 Concurrency 4.6 Pragmas 5 See also 6 References 6.1 International standards 6.2 Rationale 6.3 Books 6.4 Archives 7 External links Features[edit] Ada was originally designed for embedded and real-time systems. The Ada 95 revision, designed by S. Tucker Taft of Intermetrics between 1992 and 1995, improved support for systems, numerical, financial, and object-oriented programming (OOP). Features of Ada include: strong typing, modular programming mechanisms (packages), run-time checking, parallel processing (tasks, synchronous message passing, protected objects, and nondeterministic select statements), exception handling, and generics. Ada 95 added support for object-oriented programming, including dynamic dispatch. The syntax of Ada minimizes choices of ways to perform basic operations, and prefers English keywords (such as "or else" and "and then") to symbols (such as "||" and "&&"). Ada uses the basic arithmetical operators "+", "-", "*", and "/", but avoids using other symbols. Code blocks are delimited by words such as "declare", "begin", and "end", where the "end" (in most cases) is followed by the identifier of the block it closes (e.g., if ... end if, loop ... end loop). In the case of conditional blocks this avoids a dangling else that could pair with the wrong nested if-expression in other languages like C or Java. Ada is designed for developing very large software systems. Ada packages can be compiled separately. Ada package specifications (the package interface) can also be compiled separately without the implementation to check for consistency. This makes it possible to detect problems early during the design phase, before implementation starts. A large number of compile-time checks are supported to help avoid bugs that would not be detectable until run-time in some other languages or would require explicit checks to be added to the source code. For example, the syntax requires explicitly named closing of blocks to prevent errors due to mismatched end tokens. The adherence to strong typing allows detecting many common software errors (wrong parameters, range violations, invalid references, mismatched types, etc.) either during compile-time, or otherwise during run-time. As concurrency is part of the language specification, the compiler can in some cases detect potential deadlocks.[citation needed] Compilers also commonly check for misspelled identifiers, visibility of packages, redundant declarations, etc. and can provide warnings and useful suggestions on how to fix the error. Ada also supports run-time checks to protect against access to unallocated memory, buffer overflow errors, range violations, off-by-one errors, array access errors, and other detectable bugs. These checks can be disabled in the interest of runtime efficiency, but can often be compiled efficiently. It also includes facilities to help program verification. For these reasons, Ada is widely used in critical systems, where any anomaly might lead to very serious consequences, e.g., accidental death, injury or severe financial loss. Examples of systems where Ada is used include avionics, air traffic control, railways, banking, military and space technology.[11][12] Ada's dynamic memory management is high-level and type-safe. Ada has no generic or untyped pointers; nor does it implicitly declare any pointer type. Instead, all dynamic memory allocation and deallocation must occur via explicitly declared access types. Each access type has an associated storage pool that handles the low-level details of memory management; the programmer can either use the default storage pool or define new ones (this is particularly relevant for Non-Uniform Memory Access). It is even possible to declare several different access types that all designate the same type but use different storage pools. Also, the language provides for accessibility checks, both at compile time and at run time, that ensures that an access value cannot outlive the type of the object it points to. Though the semantics of the language allow automatic garbage collection of inaccessible objects, most implementations do not support it by default, as it would cause unpredictable behaviour in real-time systems. Ada does support a limited form of region-based memory management; also, creative use of storage pools can provide for a limited form of automatic garbage collection, since destroying a storage pool also destroys all the objects in the pool. A double-dash ("--"), resembling an em dash, denotes comment text. Comments stop at end of line, to prevent unclosed comments from accidentally voiding whole sections of source code. Disabling a whole block of code now requires the prefixing of each line (or column) individually with "--". While clearly denoting disabled code with a column of repeated "--" down the page this renders the experimental dis/re-enablement of large blocks a more drawn out process. The semicolon (";") is a statement terminator, and the null or no-operation statement is null;. A single ; without a statement to terminate is not allowed. Unlike most ISO standards, the Ada language definition (known as the Ada Reference Manual or ARM, or sometimes the Language Reference Manual or LRM) is free content. Thus, it is a common reference for Ada programmers, not only programmers implementing Ada compilers. Apart from the reference manual, there is also an extensive rationale document which explains the language design and the use of various language constructs. This document is also widely used by programmers. When the language was revised, a new rationale document was written. One notable free software tool that is used by many Ada programmers to aid them in writing Ada source code is the GNAT Programming Studio. History[edit] In the 1970s the US Department of Defense (DoD) became concerned by the number of different programming languages being used for its embedded computer system projects, many of which were obsolete or hardware-dependent, and none of which supported safe modular programming. In 1975, a working group, the High Order Language Working Group (HOLWG), was formed with the intent to reduce this number by finding or creating a programming language generally suitable for the department's and the UK Ministry of Defence's requirements. After many iterations beginning with an original Straw man proposal the eventual programming language was named Ada. The total number of high-level programming languages in use for such projects fell from over 450 in 1983 to 37 by 1996. The HOLWG working group crafted the Steelman language requirements, a series of documents stating the requirements they felt a programming language should satisfy. Many existing languages were formally reviewed, but the team concluded in 1977 that no existing language met the specifications. Requests for proposals for a new programming language were issued and four contractors were hired to develop their proposals under the names of Red (Intermetrics led by Benjamin Brosgol), Green (CII Honeywell Bull, led by Jean Ichbiah), Blue (SofTech, led by John Goodenough)[13] and Yellow (SRI International, led by Jay Spitzen). In April 1978, after public scrutiny, the Red and Green proposals passed to the next phase. In May 1979, the Green proposal, designed by Jean Ichbiah at CII Honeywell Bull, was chosen and given the name Ada—after Augusta Ada, Countess of Lovelace. This proposal was influenced by the language LIS that Ichbiah and his group had developed in the 1970s. The preliminary Ada reference manual was published in ACM SIGPLAN Notices in June 1979. The Military Standard reference manual was approved on December 10, 1980 (Ada Lovelace's birthday), and given the number MIL-STD-1815 in honor of Ada Lovelace's birth year. In 1981, C. A. R. Hoare took advantage of his Turing Award speech to criticize Ada for being overly complex and hence unreliable,[14] but subsequently seemed to recant in the foreword he wrote for an Ada textbook.[15] Ada attracted much attention from the programming community as a whole during its early days. Its backers and others predicted that it might become a dominant language for general purpose programming and not only defense-related work.[16] Ichbiah publicly stated that within ten years, only two programming languages would remain: Ada and Lisp.[17] Early Ada compilers struggled to implement the large, complex language, and both compile-time and run-time performance tended to be slow and tools primitive.[16] Compiler vendors expended most of their efforts in passing the massive, language-conformance-testing, government-required "ACVC" validation suite that was required in another novel feature of the Ada language effort.[17] The Jargon File, a dictionary of computer hacker slang originating in 1975–1983, notes in an entry on Ada that "it is precisely what one might expect given that kind of endorsement by fiat; designed by committee...difficult to use, and overall a disastrous, multi-billion-dollar boondoggle...Ada Lovelace...would almost certainly blanch at the use her name has been latterly put to; the kindest thing that has been said about it is that there is probably a good small language screaming to get out from inside its vast, {elephantine} bulk." The first validated Ada implementation was the NYU Ada/Ed translator,[18] certified on April 11, 1983. NYU Ada/Ed is implemented in the high-level set language SETL.[19] Several commercial companies began offering Ada compilers and associated development tools, including Alsys, TeleSoft, DDC-I, Advanced Computer Techniques, Tartan Laboratories, TLD Systems, and Verdix.[20] Augusta Ada King, Countess of Lovelace. In 1991, the US Department of Defense began to require the use of Ada (the Ada mandate) for all software,[21] though exceptions to this rule were often granted.[16] The Department of Defense Ada mandate was effectively removed in 1997, as the DoD began to embrace COTS technology.[16] Similar requirements existed in other NATO countries: Ada was required for NATO systems involving command and control and other functions, and Ada was the mandated or preferred language for defense-related applications in countries such as Sweden, Germany, and Canada.[22] By the late 1980s and early 1990s, Ada compilers had improved in performance, but there were still barriers to fully exploiting Ada's abilities, including a tasking model that was different from what most real-time programmers were used to.[17] Because of Ada's safety-critical support features, it is now used not only for military applications, but also in commercial projects where a software bug can have severe consequences, e.g., avionics and air traffic control, commercial rockets such as the Ariane 4 and 5, satellites and other space systems, railway transport and banking.[12]For example, the Airplane Information Management System, the fly-by-wire system software in the Boeing 777, was written in Ada.[23][24] Developed by Honeywell Air Transport Systems in collaboration with consultants from DDC-I, it became arguably the best-known of any Ada project, civilian or military.[23][24] The Canadian Automated Air Traffic System was written in 1 million lines of Ada (SLOC count). It featured advanced distributed processing, a distributed Ada database, and object-oriented design. Ada is also used in other air traffic systems, e.g., the UK's next-generation Interim Future Area Control Tools Support (iFACTS) air traffic control system is designed and implemented using SPARK Ada.[25]It is also used in the French TVM in-cab signalling system on the TGV high-speed rail system, and the metro suburban trains in Paris, London, Hong Kong and New York City.[12][26] Standardization[edit] The language became an ANSI standard in 1983 (ANSI/MIL-STD 1815A), and after translation in French and without any further changes in English becamean ISO standard in 1987 (ISO-8652:1987). This version of the language is commonly known as Ada 83, from the date of its adoption by ANSI, but is sometimes referred to also as Ada 87, from the date of its adoption by ISO. Ada 95, the joint ISO/ANSI standard (ISO-8652:1995) was published in February 1995, making Ada 95 the first ISO standard object-oriented programming language. To help with the standard revision and future acceptance, the US Air Force funded the development of the GNAT Compiler. Presently, the GNAT Compiler is part of the GNU Compiler Collection. Work has continued on improving and updating the technical content of the Ada language. A Technical Corrigendum to Ada 95 was published in October 2001, and a major Amendment, ISO/IEC 8652:1995/Amd 1:2007 was published on March 9, 2007. At the Ada-Europe 2012 conference in Stockholm, the Ada Resource Association (ARA) and Ada-Europe announced the completion of the design of the latest version of the Ada language and the submission of the reference manual to the International Organization for Standardization (ISO) for approval. ISO/IEC 8652:2012 was published in December 2012.[8] Other related standards include ISO 8651-3:1988 Information processing systems—Computer graphics—Graphical Kernel System (GKS) language bindings—Part 3: Ada. Language constructs[edit] Ada is an ALGOL-like programming language featuring control structures with reserved words such as if, then, else, while, for, and so on. However, Ada also has many data structuring facilities and other abstractions which were not included in the original ALGOL 60, such as type definitions, records, pointers, enumerations. Such constructs were in part inherited from or inspired by Pascal. "Hello, world!" in Ada[edit] A common example of a language's syntax is the Hello world program:(hello.adb) with Ada.Text_IO; use Ada.Text_IO;procedure Hello isbegin   Put_Line ("Hello, world!");end Hello; This program can be compiled by using the freely available open source compiler GNAT, by executing gnatmake hello.adb Data types[edit] Ada's type system is not based on a set of predefined primitive types but allows users to declare their own types. This declaration in turn is not based on the internal representation of the type but on describing the goal which should be achieved. This allows the compiler to determine a suitable memory size for the type, and to check for violations of the type definition at compile time and run time (i.e., range violations, buffer overruns, type consistency, etc.). Ada supports numerical types defined by a range, modulo types, aggregate types (records and arrays), and enumeration types. Access types define a reference to an instance of a specified type; untyped pointers are not permitted.Special types provided by the language are task types and protected types. For example, a date might be represented as: type Day_type   is range    1 ..   31;type Month_type is range    1 ..   12;type Year_type  is range 1800 .. 2100;type Hours is mod 24;type Weekday is (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday);type Date is   record     Day   : Day_type;     Month : Month_type;     Year  : Year_type;   end record; Types can be refined by declaring subtypes: subtype Working_Hours is Hours range 0 .. 12;            -- at most 12 Hours to work a daysubtype Working_Day is Weekday range Monday .. Friday;   -- Days to workWork_Load: constant array(Working_Day) of Working_Hours  -- implicit type declaration   := (Friday => 6, Monday => 4, others => 10);           -- lookup table for working hours with initialization Types can have modifiers such as limited, abstract, private etc. Private types can only be accessed and limited types can only be modified or copied within the scope of the package that defines them.[27] Ada 95 adds further features for object-oriented extension of types. Control structures[edit] Ada is a structured programming language, meaning that the flow of control is structured into standard statements. All standard constructs and deep-level early exit are supported, so the use of the also supported "go to" commands is seldom needed. -- while a is not equal to b, loop.while a /= b loop  Ada.Text_IO.Put_Line ("Waiting");end loop;if a > b then  Ada.Text_IO.Put_Line ("Condition met");else  Ada.Text_IO.Put_Line ("Condition not met");end if;for i in 1 .. 10 loop  Ada.Text_IO.Put ("Iteration: ");  Ada.Text_IO.Put (i);  Ada.Text_IO.Put_Line;end loop;loop  a := a + 1;  exit when a = 10;end loop;case i is  when 0 => Ada.Text_IO.Put ("zero");  when 1 => Ada.Text_IO.Put ("one");  when 2 => Ada.Text_IO.Put ("two");  -- case statements have to cover all possible cases:  when others => Ada.Text_IO.Put ("none of the above");end case;for aWeekday in Weekday'Range loop               -- loop over an enumeration   Put_Line ( Weekday'Image(aWeekday) );         -- output string representation of an enumeration   if aWeekday in Working_Day then               -- check of a subtype of an enumeration      Put_Line ( " to work for " &               Working_Hours'Image (Work_Load(aWeekday)) ); -- access into a lookup table   end if;end loop; Packages, procedures and functions[edit] Among the parts of an Ada program are packages, procedures and functions. Example:Package specification (example.ads) package Example is     type Number is range 1 .. 11;     procedure Print_and_Increment (j: in out Number);end Example; Package body (example.adb) with Ada.Text_IO;package body Example is  i : Number := Number'First;  procedure Print_and_Increment (j: in out Number) is    function Next (k: in Number) return Number is    begin      return k + 1;    end Next;  begin    Ada.Text_IO.Put_Line ( "The total is: " & Number'Image(j) );    j := Next (j);  end Print_and_Increment;-- package initialization executed when the package is elaboratedbegin  while i < Number'Last loop    Print_and_Increment (i);  end loop;end Example; This program can be compiled, e.g., by using the freely available open-source compiler GNAT, by executing gnatmake -z example.adb Packages, procedures and functions can nest to any depth, and each can also be the logical outermost block. Each package, procedure or function can have its own declarations of constants, types, variables, and other procedures, functions and packages, which can be declared in any order. Concurrency[edit] Ada has language support for task-based concurrency. The fundamental concurrent unit in Ada is a task, which is a built-in limited type. Tasks are specified in two parts – the task declaration defines the task interface (similar to a type declaration), the task body specifies the implementation of the task. Depending on the implementation, Ada tasks are either mapped to operating system threads or processes, or are scheduled internally by the Ada runtime. Tasks can have entries for synchronisation (a form of synchronous message passing). Task entries are declared in the task specification. Each task entry can have one or more accept statements within the task body. If the control flow of the task reaches an accept statement, the task is blocked until the corresponding entry is called by another task (similarly, a calling task is blocked until the called task reaches the corresponding accept statement). Task entries can have parameters similar to procedures, allowing tasks to synchronously exchange data. In conjunction with select statements it is possible to define guards on accept statements (similar to Dijkstra's guarded commands). Ada also offers protected objects for mutual exclusion. Protected objects are a monitor-like construct, but use guards instead of conditional variables for signaling (similar to conditional critical regions). Protected objects combine the data encapsulation and safe mutual exclusion from monitors, and entry guards from conditional critical regions. The main advantage over classical monitors is that conditional variables are not required for signaling, avoiding potential deadlocks due to incorrect locking semantics. Like tasks, the protected object is a built-in limited type, and it also has a declaration part and a body. A protected object consists of encapsulated private data (which can only be accessed from within the protected object), and procedures, functions and entries which are guaranteed to be mutually exclusive (with the only exception of functions, which are required to be side effect free and can therefore run concurrently with other functions). A task calling a protected object is blocked if another task is currently executing inside the same protected object, and released when this other task leaves the protected object. Blocked tasks are queued on the protected object ordered by time of arrival. Protected object entries are similar to procedures, but additionally have guards. If a guard evaluates to false, a calling task is blocked and added to the queue of that entry; now another task can be admitted to the protected object, as no task is currently executing inside the protected object. Guards are re-evaluated whenever a task leaves the protected object, as this is the only time when the evaluation of guards can have changed. Calls to entries can be requeued to other entries with the same signature. A task that is requeued is blocked and added to the queue of the target entry; this means that the protected object is released and allows admission of another task. The select statement in Ada can be used to implement non-blocking entry calls and accepts, non-deterministic selection of entries (also with guards), time-outs and aborts. The following example illustrates some concepts of concurrent programming in Ada. with Ada.Text_IO; use Ada.Text_IO;procedure Traffic is   type Airplane_ID is range 1..10;             -- 10 airplanes   task type Airplane (ID: Airplane_ID);        -- task representing airplanes, with ID as initialisation parameter   type Airplane_Access is access Airplane;     -- reference type to Airplane   protected type Runway is                     -- the shared runway (protected to allow concurrent access)      entry Assign_Aircraft (ID: Airplane_ID);  -- all entries are guaranteed mutually exclusive      entry Cleared_Runway (ID: Airplane_ID);      entry Wait_For_Clear;   private      Clear: Boolean := True;                   -- protected private data - generally more than only a flag...   end Runway;   type Runway_Access is access all Runway;   -- the air traffic controller task takes requests for takeoff and landing   task type Controller (My_Runway: Runway_Access) is      -- task entries for synchronous message passing      entry Request_Takeoff (ID: in Airplane_ID; Takeoff: out Runway_Access);      entry Request_Approach(ID: in Airplane_ID; Approach: out Runway_Access);   end Controller;   --  allocation of instances   Runway1    : aliased Runway;              -- instantiate a runway   Controller1: Controller (Runway1'Access); -- and a controller to manage it   ------ the implementations of the above types ------   protected body Runway is      entry Assign_Aircraft (ID: Airplane_ID) when Clear is   -- the entry guard - calling tasks are blocked until the condition is true      begin       Clear := False;       Put_Line (Airplane_ID'Image (ID) & " on runway ");      end;      entry Cleared_Runway (ID: Airplane_ID) when not Clear is      begin         Clear := True;         Put_Line (Airplane_ID'Image (ID) & " cleared runway ");      end;      entry Wait_For_Clear when Clear is      begin         null;      -- no need to do anything here - a task can only enter if "Clear" is true      end;   end Runway;   task body Controller is   begin      loop         My_Runway.Wait_For_Clear;   -- wait until runway is available (blocking call)         select                      -- wait for two types of requests (whichever is runnable first)            when Request_Approach'count = 0 =>  -- guard statement - only accept if there are no tasks queuing on Request_Approach             accept Request_Takeoff (ID: in Airplane_ID; Takeoff: out Runway_Access)             do                                 -- start of synchronized part               My_Runway.Assign_Aircraft (ID);  -- reserve runway (potentially blocking call if protected object busy or entry guard false)               Takeoff := My_Runway;            -- assign "out" parameter value to tell airplane which runway             end Request_Takeoff;               -- end of the synchronised part         or            accept Request_Approach (ID: in Airplane_ID; Approach: out Runway_Access) do               My_Runway.Assign_Aircraft (ID);               Approach := My_Runway;            end Request_Approach;         or                          -- terminate if no tasks left who could call            terminate;         end select;      end loop;   end;   task body Airplane is      Rwy : Runway_Access;   begin      Controller1.Request_Takeoff (ID, Rwy); -- This call blocks until Controller task accepts and completes the accept block      Put_Line (Airplane_ID'Image (ID) & "  taking off...");      delay 2.0;      Rwy.Cleared_Runway (ID);               -- call will not block as "Clear" in Rwy is now false and no other tasks should be inside protected object      delay 5.0; -- fly around a bit...      loop         select   -- try to request a runway            Controller1.Request_Approach (ID, Rwy); -- this is a blocking call - will run on controller reaching accept block and return on completion            exit; -- if call returned we're clear for landing - leave select block and proceed...         or            delay 3.0;  -- timeout - if no answer in 3 seconds, do something else (everything in following block)            Put_Line (Airplane_ID'Image (ID) & "   in holding pattern");  -- simply print a message         end select;      end loop;      delay 4.0;  -- do landing approach...      Put_Line (Airplane_ID'Image (ID) & "            touched down!");      Rwy.Cleared_Runway (ID);  -- notify runway that we're done here.   end;   New_Airplane: Airplane_Access;begin   for I in Airplane_ID'Range loop  -- create a few airplane tasks      New_Airplane := new Airplane (I); -- will start running directly after creation      delay 4.0;   end loop;end Traffic; Pragmas[edit] A pragma is a compiler directive that conveys information to the compiler to allow specific manipulating of compiled output.[28] Certain pragmas are built into the language,[29] while others are implementation-specific. Examples of common usage of compiler pragmas would be to disable certain features, such as run-time type checking or array subscript boundary checking, or to instruct the compiler to insert object code instead of a function call (as C/C++ does with inline functions). See also[edit] APSE – a specification for a programming environment to support software development in Ada Ravenscar profile – a subset of the Ada tasking features designed for safety-critical hard real-time computing SPARK (programming language) – a programming language consisting of a highly restricted subset of Ada, annotated with meta information describing desired component behavior and individual runtime requirements References[edit] ^ "Technical Corrigendum for Ada 2012 published by ISO". Ada Resource Association. 2016-01-29. Retrieved 2016-02-23. ^ "Consolidated Ada 2012 Language Reference Manual". Ada Conformity Assessment Authority. Archived from the original on 2016-03-03. Retrieved 2016-02-23. ^ "Technical Corrigendum 1 for Ada 2012". Ada Conformity Assessment Authority. Archived from the original on 2016-03-02. Retrieved 2016-02-23. ^ "PTC ObjectAda". PTC.com. Retrieved 2014-01-27. ^ "AdaMagic with C Intermediate certificate". ^ "Chapel spec (Acknowledgements)" (PDF). Cray Inc. 2015-10-01. Retrieved 2016-01-14. ^ Ganssle, Jack (2013-05-29). "Ada Resource Association – News and resource for the Ada programming language". Adaic.org. Retrieved 2013-06-14. ^ a b "ISO/IEC 8652:2012 Information technology – Programming languages – Ada". International Organization for Standardization. Retrieved 2012-12-23. ^ "The Ada Programming Language". University of Mich. Archived from the original on 2016-05-22. Retrieved 27 May 2016. ^ Fuegi, J; Francis, J (2003). "Lovelace & Babbage and the creation of the 1843 'notes'". IEEE Annals of the History of Computing. 25 (4): 16–26. doi:10.1109/MAHC.2003.1253887. S2CID 40077111. ^ Taft, S. Tucker; Olsen, Florence (1999-06-30). "Ada helps churn out less-buggy code". Government Computer News. pp. 2–3. Retrieved 2010-09-14. ^ a b c Feldman, Michael. "Who's using Ada?". SIGAda Education Working Group. ^ "John Goodenough | SEI Staff Profile". Sei.cmu.edu. Retrieved 2014-01-27. ^ C.A.R., Hoare (1981). "The Emperor's Old Clothes" (PDF). Communications of the ACM. Association for Computing Machinery. 24 (2): 75–83. doi:10.1145/358549.358561. S2CID 97895. ^ Watt, D.A.; Wichmann, B.A.; Findlay, W. (1987). Ada: Language and Methodology. Prentice-Hall. ^ a b c d Sward, Ricky E. (November 2010). "The rise, fall and persistence of Ada". SIGAda '10: Proceedings of the ACM SIGAda annual international conference on SIGAda. pp. 71–74. doi:10.1145/1879063.1879081. ^ a b c Rosen, J-P. (August 2009). "The Ada Paradox(es)". Ada Letters. ACM SIGAda. 24 (2): 28–35. doi:10.1145/1620593.1620597. S2CID 608405. ^ SofTech Inc. (1983-04-11). "Ada Compiler Validation Summary Report: NYU Ada/ED, Version 19.7 V-001". Waltham, MA. Archived from the original on 2012-03-12. Retrieved 2010-12-16. ^ Dewar, Robert B. K.; Fisher, Gerald A. Jr.; Schonberg, Edmond; Froelich, Robert; Bryant, Stephen; Goss, Clinton F.; Burke, Michael (November 1980). "The NYU Ada Translator and Interpreter". ACM SIGPLAN Notices – Proceedings of the ACM-SIGPLAN Symposium on the Ada Programming Language. 15 (11): 194–201. doi:10.1145/948632.948659. ISBN 0-89791-030-3. S2CID 10586359. ^ "Ada Validated Compilers List". Ada Information Clearinghouse. July 1, 1992. pp. 1–36. ^ Ada Information Clearinghouse (1983-04-11). "The Congressional Ada Mandate". Archived from the original on 2016-03-04. Retrieved 2015-06-07. ^ Babiak, Nicholas J. (1989). Ada, the New DoD Weapon System Computer Language – Panacea or Calamity (PDF). Air University (United States Air Force). pp. 39–40. ^ a b Rehmer, Karl (2009). "The HADS Team". In Stellman, Andrew; Greene, Jennifer (eds.). Beautiful Teams: Inspiring and Cautionary Tales from Veteran Team Leaders. Sebastopol, California: O'Reilly. pp. 299–312. ^ a b Wolfe, Alexander (October 2004). "There's Still Some Life Left in Ada". ACM Queue. 2 (7): 28–31. doi:10.1145/1035594.1035608. ^ AdaCore. "GNAT Pro Chosen for UK's Next Generation ATC System". Archived from the original on 2010-12-24. Retrieved 2011-03-01. ^ AdaCore. "Look Who's Using Ada". Archived from the original on 2010-12-24. Retrieved 2011-03-01. ^ "Ada Syntax Card" (PDF). Archived from the original (PDF) on 6 July 2011. Retrieved 28 February 2011. ^ "Ada 83 LRM, Sec 2.8: Pragmas". Archive.adaic.com. Retrieved 2014-01-27. ^ "Ada 83 LRM, Appendix/Annex B: Predefined Language Pragmas". Archive.adaic.com. Archived from the original on 2012-02-06. Retrieved 2014-01-27. International standards[edit] ISO/IEC 8652: Information technology—Programming languages—Ada ISO/IEC 15291: Information technology—Programming languages—Ada Semantic Interface Specification (ASIS) ISO/IEC 18009: Information technology—Programming languages—Ada: Conformity assessment of a language processor (ACATS) IEEE Standard 1003.5b-1996, the POSIX Ada binding Ada Language Mapping Specification, the CORBA interface description language (IDL) to Ada mapping Rationale[edit] These documents have been published in various forms, including print. Ichbiah, Jean D.; Barnes, John G. P.; Firth, Robert J.; Woodger, Mike (1986), Rationale for the Design of the Ada Programming Language, archived from the original on 2007-02-02 Barnes, John G. P. (1995), Ada 95 rationale: the language: the standard libraries Barnes, John (2006) [2005], Rationale for Ada 2005 Books[edit] Booch, Grady (1987). Software Engineering with Ada. California: The Benjamin/Cummings Publishing Company. ISBN 0-8053-0604-8. Skansholm, Jan (1996). Ada 95 From the Beginning. Addison-Wesley. ISBN 0-201-40376-5. Gilpin, Geoff. Ada: A Guided Tour and Tutorial. Prentice hall. ISBN 978-0-13-004045-9. Barnes, John (2006). Programming in Ada 2005. Addison-Wesley. ISBN 0-321-34078-7. Barnes, John (1991). Programming in Ada plus Language Reference Manual. Addison-Wesley. ISBN 0-201-56539-0. Barnes, John (1998). Programming in Ada 95. Addison-Wesley. ISBN 0-201-34293-6. Barnes, John (1997). High Integrity Ada: The SPARK Approach. Addison-Wesley. ISBN 0-201-17517-7. Barnes, John (2003). High Integrity Software: The SPARK Approach to Safety and Security. Addison-Wesley. ISBN 0-321-13616-0. Beidler, John (1997). Data Structures and Algorithms: An Object-Oriented Approach Using Ada 95. Springer-Verlag. ISBN 0-387-94834-1. Gonzalez, Dean W. (1991). Ada Programmer's Handbook. Benjamin-Cummings Publishing Company. ISBN 0-8053-2529-8. Ben-Ari, M. (1998). Ada for Software Engineers. John Wiley & Sons. ISBN 0-471-97912-0. Cohen, Norman (1996). Ada as a Second Language. McGraw-Hill Science/Engineering/Math. ISBN 0-07-011607-5. Burns, Alan; Wellings, Andy (2001). Real-Time Systems and Programming Languages. Ada 95, Real-Time Java and Real-Time POSIX. Addison-Wesley. ISBN 0-201-72988-1. Burns, Alan; Wellings, Andy (1995). Concurrency in Ada. Cambridge University Press. ISBN 0-521-62911-X. Atkinson, Colin (1991). Object-Oriented Reuse, Concurrency and Distribution: An Ada-Based Approach. Addison-Wesley. ISBN 0-201-56527-7. Booch, Grady; Bryan, Doug (1994). Software Engineering with Ada. Addison-Wesley. ISBN 0-8053-0608-0. Jones, Do-While (1989). Ada in Action: With Practical Programming Examples. John Wiley & Sons. ISBN 0-471-60708-8. Stubbs, Daniel; Webre, Neil W. (1993). Data Structures with Abstract Data Types and Ada. Brooks Cole. ISBN 0-534-14448-9. Ledru, Pascal (December 1998). Distributed Programming in Ada with Protected Objects. Dissertation.com. ISBN 1-58112-034-6. Culwin, Fintan (1997). Ada, a Developmental Approach. Prentice Hall. ISBN 0-13-264680-3. English, John; Culwin, Fintan (January 1997). Ada 95 the Craft of Object-Oriented Programming. Prentice Hall. ISBN 0-13-230350-7. Musser, David R.; Stepanov, Alexander (24 October 1989). The Ada Generic Library: Linear List Processing Packages. Springer-Verlag. ISBN 0-387-97133-5. Feldman, Michael B. (1997). Software Construction and Data Structures with Ada 95. Addison-Wesley. ISBN 0-201-88795-9. Johnston, Simon (1997). Ada 95 for C and C++ Programmers. Addison-Wesley. ISBN 0-201-40363-3. Feldman, Michael B.; Koffman, Elliot B. (1992–1993). Ada: Problem Solving and Program Design. Addison-Wesley. ISBN 0-201-52279-9. 795 pages. Feldman, Michael B.; Koffman, Elliot B. (1999). Ada 95. Addison-Wesley. ISBN 0-201-36123-X. Dale, Nell B.; Weems, Chip; McCormick, John (August 1996). Programming and Problem Solving with Ada 95. Jones & Bartlett Publishers. ISBN 0-7637-0293-5. Dale, Nell B.; McCormick, John (2007). Ada Plus Data Structures: An Object-Oriented Approach, 2nd edition. Jones & Bartlett Publishers. ISBN 978-0-7637-3794-8. Krell, Bruce C. (1992). Developing With Ada: Life-Cycle Methods. Bantam Dell Pub Group. ISBN 0-553-09102-6. Bishop, Judy (10 May 1990). Distributed Ada: Developments and Experiences. Cambridge University Press. ISBN 0-521-39251-9. Sanden, Bo (1994). Software Systems Construction With Examples in Ada. Prentice Hall. ISBN 0-13-030834-X. Hillam, Bruce (1994). Introduction to Abstract Data Types Using Ada. Prentice Hall. ISBN 0-13-045949-6. Rudd, David (1994). Introduction to Software Design and Development With Ada. Brooks Cole. ISBN 0-314-02829-3. Pyle, Ian C. (1991). Developing Safety Systems: A Guide Using Ada. Prentice Hall. ISBN 0-13-204298-3. Baker, Louis (1989). Artificial Intelligence With Ada. McGraw-Hill. ISBN 0-07-003350-1. Burns, Alan; Wellings, Andy. HRT-HOOD: A Structured Design Method for Hard Real-Time Ada Systems. North-Holland. ISBN 0-444-82164-3. Savitch, Walter; Peterson, Charles (1992). Ada: An Introduction to the Art and Science of Programming. Benjamin-Cummings Publishing Company. ISBN 0-8053-7070-6. Weiss, Mark Allen (1993). Data Structures and Algorithm Analysis in Ada. Benjamin-Cummings Publishing Company. ISBN 0-8053-9055-3. Ledgard, Henry (1983). Ada: An Introduction (second ed.). Springer-Verlag. ISBN 0-387-90814-5. Bjørner, Dines; Oest, Ole N., eds. (1980). Towards a Formal Description of Ada. London: Springer-Verlag. ISBN 3-540-10283-3. Archives[edit] Ada Programming Language Materials, 1981–1990. Charles Babbage Institute, University of Minnesota. Includes literature on software products designed for the Ada language; U.S. government publications, including Ada 9X project reports, technical reports, working papers, newsletters; and user group information. External links[edit] Wikimedia Commons has media related to Ada (programming language). Wikibooks has a book on the topic of: Ada Programming Wikisource has several original texts related to:Ada Wikiversity has learning resources about Ada Ada - C/C++ changer - MapuSoft DOD Ada programming language (ANSI/MIL STD 1815A-1983) specification JTC1/SC22/WG9 ISO home of Ada Standards Ada (programming language) at Curlie v t e Pascal programming language family Dialects Pascal Object Pascal Pascal Script Oxygene Clascal Concurrent Pascal Joyce SuperPascal Compilers Current Delphi Oxygene PocketStudio VSI Pascal IP Pascal Free Pascal (Lazarus) PascalABC.NET GNU Pascal Turbo51 MIDletPascal Pic Micro Pascal ACK Historic Virtual Pascal Apple Pascal Turbo Pascal Microsoft Pascal UCSD Pascal JRT Pascal/MT+ API CLX FCL FireMonkey LCL Object Windows Library OpenWire RTL Turbo Vision Visual Component Library Comparison of Pascal and C Comparison of Pascal and Delphi Related to ALGOL (1958) Modula-2 (1977) Ada (1983) Oberon (1986) Modula-3 (1988) Oberon-2 (1991) Component Pascal (1991) v t e Programming languages Comparison Timeline History ALGOL APL Assembly BASIC C C++ C# COBOL Go Erlang Forth Fortran Haskell Java JavaScript Kotlin Lisp ML Objective-C Pascal Perl PHP Prolog Python R Ruby Rust SQL Shell Simula Smalltalk Swift more... Category Lists: Alphabetical Categorical Generational Non-English-based v t e Embedded systems General terms ASIC Board support package Bootloader Consumer electronics Cross compiler Embedded database Embedded hypervisor Embedded OS Embedded software FPGA IoT Memory footprint Microcontroller Single-board computer Raspberry Pi SoC Firmware and controls Closed platform Crippleware Custom firmware Defective by Design Hacking of consumer electronics Homebrew (video games) iOS jailbreaking PlayStation 3 Jailbreak Proprietary firmware Rooting (Android) Vendor lock-in Boot loaders U-Boot Barebox Software libraries uClibc dietlibc Embedded GLIBC lwIP musl Programming tools Almquist shell Bitbake Buildroot BusyBox OpenEmbedded Stand-alone shell Toybox Yocto Project Operating systems Linux on embedded systems Linux for mobile devices Light-weight Linux distribution Real-time operating system Windows IoT Win CE Programming languages Ada Assembly language CAPL Embedded C Embedded C++ Embedded Java MISRA C Lightweight browsers Open-source computing hardware Open-source robotics Authority control BNE: XX531014 GND: 4000430-2 LCCN: sh85000774 Retrieved from "https://en.wikipedia.org/w/index.php?title=Ada_(programming_language)&oldid=990948123" Categories: Ada (programming language) Programming languages .NET programming languages Avionics programming languages Embedded systems High Integrity Programming Language Multi-paradigm programming languages Programming language standards Programming languages created in 1980 Programming languages with an ISO standard Statically typed programming languages Systems programming languages 1980 software High-level programming languages Hidden categories: Articles with short description Short description is different from Wikidata Articles containing potentially dated statements from 2020 All articles containing potentially dated statements All articles with unsourced statements Articles with unsourced statements from March 2016 Commons category link is on Wikidata Articles with Curlie links Wikipedia articles with BNE identifiers Wikipedia articles with GND identifiers Wikipedia articles with LCCN identifiers Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikibooks Wikiquote Wikiversity Languages العربية Aragonés Azərbaycanca বাংলা Беларуская Български Bosanski Català Чӑвашла Čeština Dansk Deutsch Eesti Ελληνικά Español Esperanto Euskara فارسی Français Gaeilge Galego 한국어 Հայերեն Hrvatski Bahasa Indonesia Interlingua Italiano עברית ქართული Қазақша Kiswahili Кыргызча Latina Magyar മലയാളം Bahasa Melayu Nederlands 日本語 Norsk bokmål Norsk nynorsk ਪੰਜਾਬੀ Polski Português Română Русиньскый Русский Simple English Slovenčina Slovenščina Српски / srpski Srpskohrvatski / српскохрватски Suomi Svenska தமிழ் ไทย Тоҷикӣ Türkçe Українська Tiếng Việt 吴语 粵語 中文 Edit links This page was last edited on 27 November 2020, at 12:38 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement