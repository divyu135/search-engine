IBM RPG - Wikipedia IBM RPG From Wikipedia, the free encyclopedia (Redirected from IBM RPG (programming language)) Jump to navigation Jump to search RPG Report Program Generator Paradigm Multi-paradigm Developer IBM First appeared 1959 Stable release RPG IV version 7 release 4 / October 6, 2020 (2020-10-06) Typing discipline Strong, static OS CPF, SSP, OS/400, IBM i, OS/VS1, z/OS, DOS/VSE, VSE/SP, VSE/ESA, z/VSE, VS/9, PRIMOS, OpenVMS, Wang VS, Burroughs MCP, OS/2, Microsoft Windows Dialects RPG, RPG II, RPG III, RPG 400, RPG IV, RPG/ILE; RPG/Free, Baby/36, Baby/400, Lattice RPG Influenced by 9PAC, FARGO Influenced RPG II RPG is a modern proprietary high-level programming language (HLL) for business applications, popular on the IBM i operating system on IBM Power Systems hardware. The current version, RPG IV, a.k.a. ILE RPG, provides a modern programming environment. IBM has evolved the language, providing new capabilities, to take advantage of technologies that have grown up in the marketplace. Contents 1 Platforms 2 History 3 RPG IV 4 RPG Open Access 5 Data types 6 Example code 7 See also 8 References 9 Further reading 10 External links Platforms[edit] The RPG programming language originally was introduced by IBM for their proprietary 1401, /360, /3, /32, /34, /36, /38 AS/400 and System i systems. There have also been implementations for the Digital VAX, Sperry Univac BC/7, Univac system 80, Siemens BS2000, Burroughs B700, B1700, Hewlett Packard HP 3000, ICL 2900 series, Honeywell 6220 and 2020, Four-Phase IV/70 and IV/90 series, Singer System 10 and WANG VS, as well as miscellaneous compilers and runtime environments for Unix-based systems, such as Infinite36 (formerly Unibol 36), and PCs (Baby/400, Lattice-RPG). The latest platform to receive an RPG compiler is Windows .Net through the WINRPG compiler which was purchased by I-Net System Solutions in March 2013. This version contains extensions to RPG IV beyond that of the base IBM compiler. These extensions provide Microsoft Windows and .NET Framework hooks in the Native and System/36 environment, as well as the ability to port DB/2 files to Microsoft Access and Microsoft SQL Server databases via Open Database Connectivity (ODBC). Open-source compiler implementations, targeting platforms such as Microsoft Dot-NET and in various stages of completion, can also be found on various repository sites such as GitHub. RPG II applications are still supported under the IBM z/VSE and z/OS operating systems, HP MPE operating system on HP3000 and the OpenVMS operating system on VAX, Alpha, and Unisys MCP and now Windows Servers and Desktops under I-Net RPG. History[edit] Originally developed by IBM in 1959, the name Report Program Generator was descriptive of the purpose of the language: generation of reports from transactional data files. The language replicated punched card processing on the IBM 1401[1] — then updated to RPG II for the IBM System/3 in the late 1960s, and since evolved into an HLL equivalent to COBOL and PL/I. In the early days of RPG, its major strength was the program cycle, executing within a loop, processing every record of a file. This was conducive to producing reports with subtotals and grand totals at control breaks. At that time each record (individual punched card) would be compared to each line in the program, which would act upon the record, or not, based upon whether that line had an "indicator" turned "on" or "off" — from a set of logical variables numbered 01–99 for user-defined purposes, or other smaller sets based upon record, field, or report processing functions. The concept of level breaks and matching records is unique to the RPG II language, and was originally developed with card readers in mind. The matching record feature of the cycle enabled easy processing of files having a header-to-detail relationship. RPG programs written to take advantage of the program cycle could produce complex reports with far fewer lines of computer code than programs written in COBOL and other business-centric languages. The program File Specifications, listed all files being written to, read from or updated, followed by Data Definition Specifications containing program elements such as Data Structures and dimensional arrays, much like a "Working-Storage" section of a COBOL program. This is followed by Calculation Specifications, which contain the executable instructions. Output Specifications can follow which can be used to determine the layout of other files or reports. Alternatively files, some data structures and reports can be defined externally, mostly eliminating the need to hand code input and output ("I/O") specifications. RPG II was introduced with the System/3 series of computers. It was later used on System/32, System/34, and System/36, with an improved version of the language. RPG II was also available for larger systems, including the IBM System/370 mainframe running DOS/VSE (then VSE/SP, VSE/ESA, and z/VSE). ICL also produced a version on its VME/K operating system. Since the introduction of the IBM System/38 in 1979 most RPG programmers discontinued use of the cycle in favor of controlling program flow with standard looping constructs, although IBM has continued to provide backward compatibility for the cycle. RPG's recent versions are available only on IBM i or OS/400-based systems.[2] FOLDOC accredits Wilf Hey with work at IBM that resulted in the development of RPG.[3] FARGO (Fourteen-o-one Automatic Report Generation Operation) was the predecessor to RPG on the IBM 1401. Both languages were intended to facilitate ease of transition for IBM tabulating machine (Tab) unit record equipment technicians to the then-new computers. Tab machine technicians were accustomed to plugging wires into control panels to implement input, output, control and counter operations (add, subtract, multiply, divide). Tab machines programs were executed by impulses emitted in a machine cycle; hence, FARGO and RPG emulated the notion of the machine cycle with the program cycle. RPG was superior to and rapidly replaced FARGO as the report generator program of choice. The alternative languages generally available at the time were Assembler, COBOL or FORTRAN. COBOL was a natural language-like business oriented language and FORTRAN was a language that facilitated mathematical applications. Other languages of the era included ALGOL and Autocoder and a few years later PL/I. Assembler and COBOL were more common in mainframe business operations (System/360 models 30 and above) and RPG more commonly used by customers who were in transition from tabulating equipment (System/360 model 20). RPG III was created for the System/38 and its successor the AS/400. RPG III significantly departed from the original language, providing modern structured constructs like IF-ENDIF blocks, DO loops, and subroutines. RPG III was also available for larger systems including the IBM System/370 mainframe running OS/VS1. It was also available from Unisys for the VS/9 operating system running on the UNIVAC Series 90 mainframes. DE/RPG or Data Entry RPG was exclusively available on the IBM 5280 series of data-entry workstations in the early '80s. It was similar to RPG III but lacking external Data Descriptions (DDS) to describe data(files) like on the System/38 and its successors. Instead, the DDS part had to be included into the RPG source itself. RPG/400 was effectively RPG III running on AS/400. IBM renamed the RPG compiler as "RPG/400" but at the time of its introduction it was identical to the RPG III compiler on System/38. Virtually all IBM products were rebranded as xxx/400 and the RPG compiler was no exception. RPG III compiled with the RPG/400 compiler offered nothing new to the RPG III language until IBM began development of new operation codes, such as SCAN, CAT and XLATE after several years of AS/400 availability. These enhancements to RPG III were not available in the System/38 version of RPG III. RPG IV[edit] RPG IV, a.k.a. RPGLE or ILE RPG,[4]) was released in 1994 as part of the v3r2 release of OS/400.[5] With the release of RPG IV, the RPG name was officially no longer an initialism. RPG IV offered a greater variety of expressions within its Extended Factor-2 Calculation Specification and, later in life, its free-format Calculation Specifications and Procedure syntax. RPG IV is the only version of RPG supported by IBM in its long line of successors to the AS/400 system (iSeries, System i, etc.). In 2001, with the release of OS/400 V5R1, RPG IV offered greater freedom for calculations than offered by the Extended Factor-2 Calculation Specification: a free-format text-capable source entry, as an alternative to the original column-dependent source format. The "/FREE" calculation did not require the operation code to be placed in a particular column; the operation code is optional for the EVAL and CALLP operations; and syntax generally more closely resembles that of mainstream, general-purpose programming languages. Until November 2013, the free format applied exclusively to the calculation specifications.[6] With the IBM i V7R1 TR7 upgrade to the language, the "/free" and "/end-free" calculations are no longer necessary, and the language has finally broken the ties to punched cards. Today, RPG IV is a more robust language. While editing can still be done via SEU, the simple green screen editor (even though syntax checking is not supported for features introduced from IBM i V7R1 onward), a long progression of tools has been developed over time. Some of these have included Code/400 and Visual Age for RPG, which were developed by IBM. Currently the preferred editing platform is IBM's Websphere Development Studio client, (WDSc) now named RDi (Rational Developer for i), which is a customized implementation of Eclipse. Eclipse, and therefore RDi, runs primarily on personal computers and other devices. IBM is continually extending its capabilities and adding more built-in functions (BIFs). It has the ability to link to Java objects,[7] and i5/OS APIs; it can be used to write CGI programs with the help of IBM's Cgidev2 Web toolkit,[8] the Cozzi cozTools (a collection of RPG and CGI routines for RPG IV), CGILIB, the RPG Toolbox, and other commercial Web-enabled packages. Even with the changes, it retains a great deal of backward compatibility, so an RPG program written 37 years ago could run today with little or no modification. The SQL precompiler allows current RPG developers to take advantage of IBM's cost-based SQE (SQL Query Engine). With the traditional F-Spec approach a developer had to identify a specific access path to a data set, now they can implement standard embedded SQL statements directly in the program. When compiled, the SQL precompiler transforms SQL statements into RPG statements which call the database manager programs that ultimately implement the query request. In 2006, OS/400 was renamed i5/OS to correspond with the new IBM System i5 branding initiative; the 5 was later dropped in favor of just System i. In March 2008 i5/OS was renamed IBM i as part of the Power Systems consolidation of System i and System p product lines. The new Power Systems also adopt more mainstream version numbers, substituting 6.1 for the twenty-year-old V1R1M0 notation. The latest release is now referred to as IBM i 7.3 and fully supports the RPG IV language, as well as many others. The RPG IV language is based on the EBCDIC character set, but also supports UTF-8, UTF-16 and many other character sets. The threadsafe aspects of the language are considered idiosyncratic by some as the compiler team has addressed threads by giving each thread its own static storage, rather than make the RPG run-time environment re-entrant. This has been noted to muddle the distinction between a thread and a process (making RPG IV threads a kind of hybrid between threads and processes). RPG Open Access[edit] This section contains content that is written like an advertisement. Please help improve it by removing promotional content and inappropriate external links, and by adding encyclopedic content written from a neutral point of view. (October 2019) (Learn how and when to remove this template message) RPG Edition was launched in 2010 with the full name of Rational Open Access. Upon its launch, IBM i chief architect Steve Will described it as an "enhancement that's really an architectural change that opens RPG up to whole new uses, and it’s being brought to the community by IBM i, our friends in IBM Rational, and several ISVs who’ve been working with IBM to hit the ground running. The idea behind the new capability is to remove the necessity for all output from RPG programs to be forced into the limited 5250 data stream. Instead, it can be passed to handlers, which can transform it in any way the handler wants. Wrap it in XML; put it in the format required by a pervasive device; make a Web page that doesn’t look like a 5250 screen; whatever you want."[9] While many companies were skeptical about the usefulness of Open Access, it gained immediate acceptance from some others, including Profound Logic corporation, which rapidly incorporated it into their products aimed at opening the i, and hired Scott Klement, a product developer well known for creating open-source tools to access the technology.[10][11] Data types[edit] RPG supports the following data types. Note: The character in the data type column is the character that is encoded on the Definition Specification in the column designated for data type. To compare, in a language like C where definitions of variables are free-format and would use a keyword such as int to declare an integer variable, in RPG, a variable is defined with a fixed-format Definition Specification. In the Definition Specification, denoted by a letter D in column 6 of a source line, the data type character would be encoded in column 40. Also, if the data type character is omitted, that is, left blank, the default is A if no decimal positions are specified, P when decimal positions are specified for stand-along fields, and S (ZONED) when decimal positions are specified within a data structure. Data type Name Length Description A Alphanumeric character 1 to 16,773,104 bytes (fixed) 1 to 16,773,100 bytes (varying-length) Alphanumeric character B Binary numeric 1 byte (8-bit) 2 byte (16-bit) 4 bytes (32-bit) 8 bytes (64-bit) Signed binary integer C UCS-2 character 1 to 8,386,552 characters (fixed) 1 to 8,386,550 characters (varying) 16-bit UCS-2 character (DBCS or EGCS) D Date 10 bytes Date: year, month, day F Floating point numeric 4 bytes (32-bit) 8 bytes (64-bit) Signed binary floating-point real G Graphic character 1 to 8,386,552 characters (fixed) 1 to 8,386,550 characters (varying) 16-bit graphic character (DBCS or EGCS) I Integer numeric 1 byte (8-bit) 2 bytes (16-bit) 4 bytes (32-bit) 8 bytes (64-bit) Signed binary integer N Character indicator 1 byte '1' = TRUE '0' = FALSE O Object Size undisclosed Object reference P Packed decimal numeric 1 to 63 digits, 2 digits per byte plus sign Signed fixed-point decimal number with integer and fraction digits S Zoned decimal numeric 1 to 63 digits, 1 digit per byte Signed fixed-point decimal number with integer and fraction digits T Time 8 bytes Time: hour, minute, second U Integer numeric 1 byte (8-bit) 2 bytes (16-bit) 4 bytes (32-bit) 8 bytes (64-bit) Unsigned binary integer Z Timestamp 26 bytes Date and time: year, month, day, hour, minute, second, microseconds * Basing-Pointer Procedure-Pointer System-Pointer 16 bytes Address to Data Address to Activated Procedure Address to Object Example code[edit] The following program receives a customer number as an input parameter and returns the name and address as output parameters.This is the most primitive version of RPG IV syntax. The same program is shown later with gradually more modern versions of the syntax and gradually more relaxed rules.       * Historically RPG was columnar in nature, though free-formatting      * was allowed under particular circumstances.      * The purpose of various lines code are determined by a      * letter code in column 6.      * An asterisk (*) in column 7 denotes a comment line      * "F" (file) specs define files and other i/o devices     F ARMstF1   IF   E       K     Disk    Rename(ARMST:RARMST)      * "D" (data) specs are used to define variables     D pCusNo          S              6p     D pName           S             30a     D pAddr1          S             30a     D pAddr2          S             30a     D pCity           S             25a     D pState          S              2a     D pZip            S             10a      * "C" (calculation) specs are used for executable statements      * Parameters are defined using plist and parm opcodes     C     *entry        plist     C                   parm                    pCusNo     C                   parm                    pName     C                   parm                    pAddr1     C                   parm                    pAddr2     C                   parm                    pCity     C                   parm                    pState     C                   parm                    pZip      * The "chain" command is used for random access of a keyed file     C     pCusNo        chain     ARMstF1      * If a record is found, move fields from the file into parameters     C                   if        %found     C                   eval      pName  = ARNm01     C                   eval      pAddr1 = ARAd01     C                   eval      pAddr2 = ARAd02     C                   eval      pCity  = ARCy01     C                   eval      pState = ARSt01     C                   eval      pZip   = ARZp15     C                   endif      * RPG makes use of switches.  One switch "LR" originally stood for "last record"      * LR flags the program and its dataspace as removable from memory     C                   eval      *InLR = *On The same program using free calculations available starting in V5R1:       * "F" (file) specs define files and other i/o devices     FARMstF1   IF   E        K     Disk    Rename(ARMST:RARMST)      * "D" (data) specs are used to define variables and parameters      * The "prototype" for the program is in a separate file      * allowing other programs to call it      /copy cust_pr      * The "procedure interface" describes the *ENTRY parameters     D getCustInf      PI     D  pCusNo                        6p 0   const     D  pName                        30a     D  pAddr1                       30a     D  pAddr2                       30a     D  pCity                        25a     D  pState                        2a     D  pZip                         10a      /free        // The "chain" command is used for random access of a keyed file        chain pCusNo ARMstF1;        // If a record is found, move fields from the file into parameters        if %found;           pName  = ARNm01;           pAddr1 = ARAd01;           pAddr2 = ARAd02;           pCity  = ARCy01;           pState = ARSt01;           pZip   = ARZp15;        endif;      // RPG makes use of switches.  One switch "LR" originally stood for "last record"      // LR actually flags the program and its dataspace as removable from memory.        *InLR = *On;      /end-free Assume the ARMSTF1 example table was created using the following SQL Statement: create table armstf1(arcnum decimal(7,0), arname char(30), aradd1 char(30), aradd2 char(30), arcity char(25), arstte char(2), arzip  char(10)) The same program using free calculations and embedded SQL:       * RPG IV no longer requires the use of the *INLR indicator to terminate a program.      * by using the MAIN keyword on the "H" (Header) spec, and identifying the "main" or      * entry procedure name, the program will begin and end normally without using the      * decades-old RPG Cycle and instead a more "C like" begin and end logic.     H  MAIN(getCustInf)      * "D" (data) specs are used to define variables and parameters      * The "prototype" for the program is in a separate file      * allowing other programs to call it      /copy cust_pr      * The "procedure interface" describes the *ENTRY parameters     P getCustInf      B     D getCustInf      PI     D  pCusNo                        6p 0   const     D  pName                        30a     D  pAddr1                       30a     D  pAddr2                       30a     D  pCity                        25a     D  pState                        2a     D  pZip                         10a      /free        exec sql select arName, arAddr1, arAdd2, arCity, arStte, arZip                 into  :pName, :pAddr1, :pAddr2, :pCity, :pState, :pZip                 from   ARMstF1                 where  arCNum = :pCusNo                 for fetch only                 fetch first 1 row only                 optimize for 1 row                 with CS;      /end-free     P GetCustInf      E As of V7R1 of the operating system, the above program would not necessarily need the prototype in a separate file, so it could be completely written as:      H main(GetCustInf)     D ARMSTF1       E DS     P GetCustInf      B     D GetCustInf      PI                  extpgm('CUS001')     D  inCusNo                            like(arCNum) const     D  outName                            like(arName)     D  outAddr1                           like(arAdd1)     D  outAddr2                           like(arAdd2)     D  outCity                            like(arCity)     D  outState                           like(arStte)     D  outZip                             like(arZip)      /free       exec sql select arName, arAdd1, arAdd2, arCity, arStte, arZip                into  :outName, :outAddr1, :outAddr2, :outCity, :outState,                      :outZip                from   ARMSTF1                where  arCNum = :inCusNo                fetch first 1 row only                with CS                use currently committed;      /end-free     P GetCustInf      E Lastly, if you apply the compiler PTFs related Technology Refresh 7 (TR7) to your 7.1 operating system, then the above program can be coded completely in free-form, as follows:        ctl-opt main(GetCustInf);       dcl-ds ARMSTF1 ext end-ds;       dcl-proc GetCustInf;         dcl-pi *n extpgm('CUS001');           inCusNo like(arCNum) const;           outName like(arName);           outAddr1 like(arAdd1);           outAddr2 like(arAdd2);           outCity like(arCity);           outState like(arStte);           outZip like(arZip);         end-pi;         exec sql select arName, arAdd1, arAdd2, arCity, arStte, arZip                  into  :outName, :outAddr1, :outAddr2, :outCity, :outState,                        :outZip                  from   ARMSTF1                  where  arCNum = :inCusNo                  fetch first 1 row only                  with CS                  use currently committed;         return;       end-proc; See also[edit] IBM RPG II References[edit] ^ "...IBM 1401 and the Report Program Generator (RPG) contributed significantly to this success...", IBM 1401 Data Processing System / 1959 ^ "IBM Knowledge Center - Home of IBM product documentation". Ibm.com. Retrieved 26 March 2019. ^ but it says 1965, rather than the 1959 mentioned here. ^ "Generating Random Numbers in ILE RPG Using the CEERAN0 API", IBM.com ^ "How did we miss RPG IV's Coming of Age?", ibmsystemsmag.com ^ Paris, Jon; Gantner, Susan. "Totally Free RPG". IBM Systems Magazine. Retrieved 8 March 2014. ^ "RPG/400 User's Guide" (PDF). Ibm.com. Retrieved 6 August 2017. ^ "EASY400 CGIDEV2". Easy400.net. Retrieved 26 March 2019. ^ You and i: You and i 7.1. Ibmsystemsmag.blogs.com (2010-04-13). Retrieved on 2013-08-10. ^ Smith, Chris (16 May 2012). "Profound Logic Blasts the Myths Surrounding Rational Open Access: RPG Edition". Mcpressonline.com. Retrieved 12 April 2016. ^ "Scott Klement Joins Profound Logic Staff". Itjungle.com. 16 July 2012. Retrieved 12 April 2016. Further reading[edit] "9PAC, Report Generator". History of Programming Languages (HOPL), Murdoch University, AU. 2006. Archived from the original on 2010-12-24. Retrieved 2008-04-01. "RPG, Report Program Generator". History of Programming Languages (HOPL), Murdoch University, AU. 2006. Archived from the original on 2011-04-15. Retrieved 2008-04-01. DuCharme, Bob (2006-02-26). "Pulling data out of computers in the mid-twentieth and early twenty-first centuries". Cozzi, Robert (1996). "The Modern RPG IV Language". Shelly, Gary B.; Thomas J. Cashman (1977). Introduction to Computer Programming RPG. Fullerton, California: Anaheim Publishing Company. ISBN 0-88236-225-9. External links[edit] Smith, Brian R.; Martin Barbeau; Susan Gantner; Jon Paris; Zdravko Vincetic; Vladimir Zupka (April 25, 2000). "Who Knew You Could Do That with RPG IV? A Sorcerer's Guide to System Access and More" (PDF). IBM International Technical Support Organization. Retrieved 2012-02-18. "This redbook is focused on RPG IV as a modern, thriving, and rich application development language for the 21st century." Midrange.com — A large number of code examples are available here RPGPGM.COM — An extensive resource of articles giving examples of RPG code and related programming RPG Open — Free (open source) resources for RPG IV and IBM i application development. IBM (1964). IBM 1401 RPG manual (PDF). C24-3261-1. IBM (2016). ILE RPG Programmer's Guide (PDF). SC09-2507-10. RPG II for MVS, OS/390 and z/OS — Status of the IBM RPG II product in z/OS For Old Timers — Online RPG I compiler for small experiments and tinkering [1] rpg programmers RPGLE Tutorial for beginers - AS400i.com Retrieved from "https://en.wikipedia.org/w/index.php?title=IBM_RPG&oldid=989182889" Categories: Data-centric programming languages Procedural programming languages IBM software Programming languages created in 1959 Hidden categories: Articles with a promotional tone from October 2019 All articles with a promotional tone Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages العربية Български Català Čeština Deutsch Español فارسی Français Bahasa Indonesia Italiano Magyar Nederlands 日本語 Polski Português Română Русский Suomi Svenska ไทย Українська Edit links This page was last edited on 17 November 2020, at 14:54 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement