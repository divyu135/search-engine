Processor register - Wikipedia Processor register From Wikipedia, the free encyclopedia Jump to navigation Jump to search Immediately accessible working storage available as part of a digital processor This article has multiple issues. Please help improve it or discuss these issues on the talk page. (Learn how and when to remove these template messages) This article needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed. Find sources: "Processor register" – news · newspapers · books · scholar · JSTOR (March 2008) (Learn how and when to remove this template message) This article may require cleanup to meet Wikipedia's quality standards. No cleanup reason has been specified. Please help improve this article if you can. (January 2012) (Learn how and when to remove this template message) This article needs to be updated. Please update this article to reflect recent events or newly available information. (March 2016) (Learn how and when to remove this template message) A processor register is a quickly accessible location available to a computer's processor. Registers usually consist of a small amount of fast storage, although some registers have specific hardware functions, and may be read-only or write-only. In computer architecture, registers are typically addressed by mechanisms other than main memory, but may in some cases be assigned a memory address e.g. DEC PDP-10, ICT 1900. Almost all computers, whether load/store architecture or not, load data from a larger memory into registers where it is used for arithmetic operations and is manipulated or tested by machine instructions. Manipulated data is then often stored back to main memory, either by the same instruction or by a subsequent one. Modern processors use either static or dynamic RAM as main memory, with the latter usually accessed via one or more cache levels. Processor registers are normally at the top of the memory hierarchy, and provide the fastest way to access data. The term normally refers only to the group of registers that are directly encoded as part of an instruction, as defined by the instruction set. However, modern high-performance CPUs often have duplicates of these "architectural registers" in order to improve performance via register renaming, allowing parallel and speculative execution. Modern x86 design acquired these techniques around 1995 with the releases of Pentium Pro, Cyrix 6x86, Nx586, and AMD K5. When a computer program accesses the same data repeatedly, this is called locality of reference. Holding frequently used values in registers can be critical to a program's performance. Register allocation is performed either by a compiler in the code generation phase, or manually by an assembly language programmer. Contents 1 Size 2 Types 3 Examples 4 Usage 5 See also 6 References Size[edit] Registers are normally measured by the number of bits they can hold, for example, an "8-bit register", "32-bit register" or a "64-bit register" or even more. In some instruction sets, the registers can operate in various modes breaking down its storage memory into smaller ones (32-bit into four 8-bit one for instance) to which multiple data (vector, or one dimensional array of data) can be loaded and operated upon at the same time. Typically it is implemented by adding extra registers that map their memory into bigger one. Processors that have the ability to execute single instruction on multiple data are called vector processors. Types[edit] A processor often contains several kinds of registers, which can be classified according to their content or instructions that operate on them: User-accessible registers can be read or written by machine instructions. The most common division of user-accessible registers is into data registers and address registers. Data registers can hold numeric data values such as integer and, in some architectures, floating-point values, as well as characters, small bit arrays and other data. In some older and low end CPUs, a special data register, known as the accumulator, is used implicitly for many operations. Address registers hold addresses and are used by instructions that indirectly access primary memory. Some processors contain registers that may only be used to hold an address or only to hold numeric values (in some cases used as an index register whose value is added as an offset from some address); others allow registers to hold either kind of quantity. A wide variety of possible addressing modes, used to specify the effective address of an operand, exist. The stack pointer is used to manage the run-time stack. Rarely, other data stacks are addressed by dedicated address registers, see stack machine. General-purpose registers (GPRs) can store both data and addresses, i.e., they are combined data/address registers; in some architectures, the register file is unified so that the GPRs can store floating-point numbers as well. Status registers hold truth values often used to determine whether some instruction should or should not be executed. Floating-point registers (FPRs) store floating point numbers in many architectures. Constant registers hold read-only values such as zero, one, or pi. Vector registers hold data for vector processing done by SIMD instructions (Single Instruction, Multiple Data). Special-purpose registers (SPRs) hold program state; they usually include the program counter, also called the instruction pointer, and the status register; the program counter and status register might be combined in a program status word (PSW) register. The aforementioned stack pointer is sometimes also included in this group. Embedded microprocessors can also have registers corresponding to specialized hardware elements. In some architectures, model-specific registers (also called machine-specific registers) store data and settings related to the processor itself. Because their meanings are attached to the design of a specific processor, they cannot be expected to remain standard between processor generations. Memory type range registers (MTRRs) Internal registers – registers not accessible by instructions, used internally for processor operations. Instruction register, holding the instruction currently being executed. Registers related to fetching information from RAM, a collection of storage registers located on separate chips from the CPU: Memory buffer register (MBR), also known as Memory data register (MDR) Memory address register (MAR) Architectural register - The registers visible to software defined by an architecture may not correspond to the physical hardware, if there is register renaming being performed by underlying hardware. Hardware registers are similar, but occur outside CPUs. In some architectures (such as SPARC and MIPS), the first or last register in the integer register file is a pseudo-register in a way that it is hardwired to always return zero when read (mostly to simplify indexing modes), and it cannot be overwritten. In Alpha this is also done for the floating-point register file. As a result of this, register files are commonly quoted as having one register more than how many of them are actually usable; for example, 32 registers are quoted when only 31 of them fit within the above definition of a register. Examples[edit] The following table shows the number of registers in several mainstream CPU architectures. Note that in x86-compatible processors the stack pointer (ESP) is counted as an integer register, even though there are a limited number of instructions that may be used to operate on its contents. Similar caveats apply to most architectures. Although all of the above listed architectures are different, almost all are a basic arrangement known as the Von Neumann architecture, first proposed by the Hungarian-American mathematician John von Neumann. It is also noteworthy that the number of registers on GPUs is much higher than that on CPUs. Architecture GPRs/data+address registers FP registers Notes AT&T Hobbit 0 stack of 7 Stack machine Cray-1[1] 8 scalar data, 8 address 8 scalar, 8 vector (64 elements) Scalar data registers can be integer or floating-point; also 64 scalar scratch-pad T registers and 64 address scratch-pad B registers 4004[2] 1 accumulator, 16 others 0 Register A is for general purpose, while r0–r15 registers are for the address and segment. 8008[3] 1 accumulator, 6 others 0 The A register is an accumulator to which all arithmetic is done; the H and L registers can be used in combination as an address register; all registers can be used as operands in load/store/move/increment/decrement instructions and as the other operand in arithmetic instructions. There is no FP unit available. 8080[4] 1 accumulator, 6 others 0 Plus a stack pointer. The A register is an accumulator to which all arithmetic is done; the register pairs B+C, D+E, and H+L, can be used as address registers in some instructions; all registers can be used as operands in load/store/move/increment/decrement instructions and as the other operand in arithmetic instructions. Some instructions only use H+L; another instruction swaps H+L and D+E. Floating point processors intended for the 8080 were Intel 8231, AMD Am9511 and Intel 8232. They were also readily usable with the Z80 and similar processors. iAPX432 0 stack of 6 Stack machine 16-bit x86[5] 6 stack of 8 (if FP present) 8086/8088, 80186/80188, 80286, with 8087, 80187 or 80287 for floating-point, with an 80-bit wide, 8 deep register stack with some instructions able to use registers relative to the top of the stack as operands; without 8087/80187/80287, no floating-point registers IA-32[6] 8 stack of 8 (if FP present), 8 (if SSE/MMX present) 80386 required 80387 for floating-point, later processors had built-in floating point, with both having an 80-bit wide, 8 deep register stack with some instructions able to use registers relative to the top of the stack as operands. The Pentium III and later had the SSE with additional 128-bit XMM registers. x86-64[6][7] 16 16/32 FP registers are 128-bit XMM registers, later extended to 256-bit YMM registers with AVX/AVX2 and 512-bit ZMM0-ZMM31 registers with AVX-512.[8] Xeon Phi[9] 16 32 Including 32 256/512-bit ZMM registers with AVX-512. Fairchild F8 one accumulator, 64 scratchpad registers, one indirect scratchpad register (ISAR) n/a Instructions can directly reference the first 16 scratchpad registers and can access all scratchpad registers indirectly through the ISAR[10] Geode GX 1 data, 1 address 8 Geode GX/Media GX/4x86/5x86 is the emulation of 486/Pentium compatible processor made by Cyrix/National Semiconductor. Like Transmeta, the processor had a translation layer that translated x86 code to native code and executed it.[citation needed] It does not support 128-bit SSE registers, just the 80387 stack of eight 80-bit floating point registers, and partially support 3DNow! from AMD. The native processor only contains 1 data and 1 address register for all purpose and translated into 4 paths of 32-bit naming register r1 (base), r2 (data), r3 (back pointer), and r4 (stack pointer) within scratchpad sram for integer operation and uses the L1 cache for x86 code emulation(note that it's not compatible with some 286/386/486 instructions in real mode).[citation needed] Later the design was abandoned after AMD acquired the IP from National Semiconductor and branded it with Athlon core in embedded market. SunPlus SPG 0 6 stack + 4 SIMD A 16-bit wide, 32-bit address space stack machine processor from the Taiwanese company Sunplus Technology, it can be found on Vtech's V.Smile line for educational purpose and the video game console like wireless 60, Mattel HyperScan, and XaviXPORT. it does lack any general purpose register or internal register for naming/renaming but its Floating Point Unit has 80-bit 6 stage stack and four 128-bit VLIW SIMD register on a vertex shader co-processor. VM Labs Nuon 0 1 a 32-bit stack machine processor that developed by VM labs for specialized on multimedia purpose. It can be found on the company's own Nuon DVD player console line and Game Wave Family Entertainment System from ZaPit games. The design was heavy influence by Intel's MMX technology, it contained a 128 bytes unified stack cache for both vector and scalar instructions. the unified cache can be divided as 8 128-bit vector register or 32 32bit SIMD scalar register through bank renaming, no integer register found in this architecture. Nios II[11][12] 31 8 Nios II is based on MIPS IV instruction set[citation needed] and has 31 32-bit GPRs, with register 0 being hardwired to zero and 8 64-bit floating point registers[citation needed] Motorola 6800[13] 2 data, 1 index 0 Plus a stack pointer Motorola 68k[14] 8 data (d0-d7), 8 address (a0-a7) 8 (if FP present) Address register 8 (a7) is the stack pointer. 68000, 68010, 68012, 68020, and 68030 require an FPU for floating point; 68040 had FPU built in. FP registers are 80-bit. SH 16-bit 1 6 Emotion Engine 3(VU0)+ 32(VU1) 32 SIMD(integrated in UV1) + 2x 32 Vector (dedicated vector co-processor that located near by its GPU) The Emotion Engine's main core (VU0) is a heavily modified DSP general core that's for general background task and it contains one 64 bit accumulator, two general data registers and one 32 bit program counter. A modified MIPS III executable core(VU1) is for game data and protocol control and it contains 32 entries 32-bit general-purpose registers for integer computation and 32 entries 128-bit SIMD registers for storing SIMD instruction, streaming data value and some integer calculation value. one accumulator register for connecting general floating-point computation to vector register file on co-processor. The coprocessor is built via 32 entries 128-bit vector register file(can only store vector value that pass from accumulator in cpu. ) and no integer register is built in. Both vector co-processor(VPU 0/1) and emotion engine's entire main processor module(VU0 + VU1 + VPU0 + VPU1) are built based on modified MIPS instructions set and accumulator in this case is not general purpose but control status. CUDA[15] configurable, up to 255 per thread Earlier generations allowed up to 127/63 registers per thread (Tesla/Fermi). The more registers are configured per thread, the fewer threads can run at the same time. Registers are 32 bits wide, double precision floating point numbers and 64 bit pointers require two registers. Additionally has up to 8 predicate registers per thread[16] CDC 6000 series 16 8 8 'A' registers A0-A7 hold 18-bit addresses; 8 'B' registers B0-B7 hold 18-bit integer values (with B0 permanently set to zero); 8 'X' registers X0-X7 hold 60 bits of integer or floating point data. Seven of the eight 18-bit A registers were coupled to their corresponding X registers: setting any of registers A1 through A5 to a value caused a memory load of the contents of that address into the corresponding X register. Likewise, setting an address into registers A6 or A7 caused a memory store into that location in memory from X6 or X7. (Registers A0 and X0 were not coupled like this). IBM S/360 16 4 (if FP present) This applies to S/360's successors, System/370 through System/390; FP was optional in System/360, and always present in S/370 and later. In processors with the Vector Facility, there are 16 vector registers containing a machine-dependent number of 32-bit elements.[17] z/Architecture 16 16 64-bit version of S/360 and successors; it increased the number of floating-point registers to 16. MMIX[18] 256 256 An instruction set designed by Donald Knuth in the late 1990s for pedagogical purposes. NS320xx[19] 8 8 (if FP present) Xelerated X10 1 32 a 32/40 bit stack machine based network processor with modified MIPS instruction and 128 bit floating point unit.[citation needed] Parallax Propeller 0 2 An eight core 8/16 bit sliced stack machine controller with simple logic circus inside, have eight cog counter(core) and each contain three 8/16 bit special control registers with 32 bit x 512 stack ram however it does not carrying any general register for integer purpose. unlike most of shadow register file in modern processor and multi core system, all these stack ram in cog can be accessed in instruction level which all these cog can act as one big single general purpose core if necessary. Floating point unit is external and it contain two 80 bit vector register. Itanium 128 128 And 64 1-bit predicate registers and 8 branch registers. The FP registers are 82-bit. SPARC 31 32 Global register 0 is hardwired to 0. Uses register windows. IBM POWER 32 32 And 1 link and 1 count register. Power ISA 32 32 And 1 link and 1 count register. Processors supporting the Vector facility also have 32 128-bit vector registers, Blackfin 8 data, 2 accumulator, 6 address 0 And stack pointer and frame pointer. Additional registers are used to implement zero-overhead loops and circular buffer DAGs (data address generators). IBM Cell SPE 128 128 GPRs, which can hold integer, address, or floating-point values[20] PDP-10 16 All may be used generally (integer, float, stack pointer, jump, indexing, etc.). Every 36-bit memory (or register) word can also be manipulated as a half-word, which can be considered an (18-bit) address. Other word interpretations are used by certain instructions. In the original PDP-10 processors, these 16 GPRs also corresponded to main (i.e. core) memory locations 0-15; a hardware option called "fast memory" implemented the registers as separate ICs, and references to memory locations 0-15 referred to the IC registers. Later models implemented the registers as "fast memory" and continued to make memory locations 0-15 refer to them. Movement instructions take (register, memory) operands: MOVE 1,2 is register-register, and MOVE 1,1000 is memory-to-register. PDP-11 8 0 R7 is actually the Program Counter. Any register can be a stack pointer but R6 is used for hardware interrupts and traps. VAX 16 The GPRs are used for floating-point values as well. Three of the registers have special uses: R12 (Argument Pointer), R13 (Frame Pointer), and R14 (Stack Pointer), while R15 refers to the Program Counter. Alpha 31 31 Registers R31 (integer) and F31 (floating-point) are hardwired to zero. 6502 1 data, 2 index 0 6502's content A (Accumulator) register for main purpose data store and memory address (8-bit data/16-bit address), X,Y are indirect and direct index registers (respectively) and SP register are specific index only. W65C816S 1 0 65c816 is the 16-bit successor of the 6502. X,Y, D (Direct Page register) are condition registers and SP register are specific index only. main accumulator extended to 16-bit (C)[21] while keep 8-bit (A) for compatibility and main register can now address up to 24-bit (16-bit wide data instruction/24-bit memory address). 65k 1 0 Direct successor of 6502, 65002 only content A (Accumulator) register for main purpose data store and extend data wide to 32-bit and 64-bit instruction wide, support 48-bit virtual address in software mode, X,Y are still condition register and remain 8-bit and SP register are specific index but increase to 16-bit wide. MeP 4 8 Media-embedded processor was a 32 bit processor developed by toshiba, a modded 8080 instruction set with only A, B, C, D register available through all mode(8/16/32 bit) and incompatible with x86, however it contain 80 bit floating point unit that is x87 compatible. PIC microcontroller 1 0 AVR microcontroller 32 0 ARM 32-bit (ARM/A32, Thumb-2/T32) 14 Varies (up to 32) r15 is the program counter, and not usable as a GPR; r13 is the stack pointer; r8-r13 can be switched out for others (banked) on a processor mode switch. Older versions had 26-bit addressing,[22] and used upper bits of the program counter (r15) for status flags, making that register 32-bit. ARM 32-bit (Thumb) 8 16 Version 1 of Thumb, which only supported access to registers r0 through r7[23] ARM 64-bit (A64)[24] 31 32 Register r31 is the stack pointer or hardwired to 0, depending on the context. MIPS 31 32 Integer register 0 is hardwired to 0. RISC-V 31 32 Integer register 0 hardwired to 0. The variant RV32E intended for systems with very limited resources has 15 integer registers. Epiphany 64 (per core)[25] Each instruction controls whether registers are interpreted as integers or single precision floating point. Architecture is scalable to 4096 cores with 16 and 64 core implementations currently available. Usage[edit] The number of registers available on a processor and the operations that can be performed using those registers has a significant impact on the efficiency of code generated by optimizing compilers. The Strahler number of an expression tree gives the minimum number of registers required to evaluate that expression tree. See also[edit] CPU cache Register allocation Register file Shift register References[edit] ^ "Cray-1 Computer System Hardware Reference Manual" (PDF). Cray Research. November 1977. ^ "MCS-4 Micro Computer Set Users Manual" (PDF). Intel. February 1973. ^ "8008 8 Bit Parallel Central Processor Unit Users Manual" (PDF). Intel. November 1973. Retrieved January 23, 2014. ^ "Intel 8080 Microcomputer Systems User's Manual" (PDF). Intel. September 1975. Retrieved January 23, 2014. ^ "80286 and 80287 Programmer's Reference Manual" (PDF). Intel. 1987. ^ a b "Intel 64 and IA-32 Architectures Software Developer Manuals". Intel. 4 December 2019. ^ "AMD64 Architecture Programmer's Manual Volume 1: Application Programming" (PDF). AMD. October 2013. ^ "Intel Architecture Instruction Set Extensions and Future Features Programming Reference" (PDF). Intel. January 2018. ^ "Intel Xeon Phi Coprocessor Instruction Set Architecture Reference Manual" (PDF). Intel. September 7, 2012. ^ F8 Guide to Programming (PDF). Fairchild MOS Microcomputer Division. 1977. ^ "Nios II Classic Processor Reference Guide" (PDF). Altera. April 2, 2015. ^ "Nios II Gen2 Processor Reference Guide" (PDF). Altera. April 2, 2015. ^ "M6800 Programming Reference Manual" (PDF). Motorola. November 1976. Retrieved May 18, 2015. ^ "Motorola M68000 Family Programmer's Reference Manual" (PDF). Motorola. 1992. Retrieved June 13, 2015. ^ "CUDA C Programming Guide". Nvidia. 2019. Retrieved Jan 9, 2020. ^ Jia, Zhe; Maggioni, Marco; Staiger, Benjamin; Scarpazza, Daniele P. (2018). "Dissecting the NVIDIA Volta GPU Architecture via Microbenchmarking". arXiv:1804.06826 [cs.DC]. ^ "IBM Enterprise Systems Architecture/370 and System/370 - Vector Operations" (PDF). IBM. SA22-7125-3. Retrieved May 11, 2020. ^ "MMIX Home Page". ^ "Series 32000 Databook" (PDF). National Semiconductor. ^ "Synergistic Processor Unit Instruction Set Architecture Version 1.2" (PDF). IBM. January 27, 2007. ^ "Learning 65816 Assembly". Super Famicom Development Wiki. Retrieved 14 November 2019. ^ "Procedure Call Standard for the ARM Architecture" (PDF). ARM Holdings. 30 November 2013. Retrieved 27 May 2013. ^ "2.6.2. The Thumb-state register set". ARM7TDMI Technical Reference Manual. ARM Holdings. ^ "Procedure Call Standard for the ARM 64-bit Architecture" (PDF). ARM Holdings. 22 May 2013. Retrieved 27 May 2013. ^ "Epiphany Architecture Reference" (PDF). v t e Processor technologies Models Turing machine Universal Post–Turing Quantum Belt machine Stack machine Finite-state machine with datapath Hierarchical Queue automaton Register machines Counter Pointer Random-access Random-access stored program Architecture Microarchitecture Von Neumann Harvard modified Dataflow Transport-triggered Cellular Endianness Memory access NUMA HUMA Load/store Register/memory Cache hierarchy Memory hierarchy Virtual memory Secondary storage Heterogeneous Fabric Multiprocessing Cognitive Neuromorphic Instruction set architectures Types CISC RISC Application-specific EDGE TRIPS VLIW EPIC MISC OISC NISC ZISC Comparison Addressing modes Instruction sets x86 ARM MIPS Power ISA SPARC Itanium Unicore MicroBlaze RISC-V LMC Others Execution Instruction pipelining Pipeline stall Operand forwarding Classic RISC pipeline Hazards Data dependency Structural Control False sharing Out-of-order Tomasulo algorithm Reservation station Re-order buffer Register renaming Speculative Branch prediction Memory dependence prediction Parallelism Level Bit Bit-serial Word Instruction Pipelining Scalar Superscalar Task Thread Process Data Vector Memory Distributed Multithreading Temporal Simultaneous Hyperthreading Speculative Preemptive Cooperative Flynn's taxonomy SISD SIMD SWAR SIMT MISD MIMD SPMD Processor performance Transistor count Instructions per cycle (IPC) Cycles per instruction (CPI) Instructions per second (IPS) Floating-point operations per second (FLOPS) Transactions per second (TPS) Synaptic updates per second (SUPS) Performance per watt (PPW) Cache performance metrics Computer performance by orders of magnitude Types Central processing unit (CPU) Graphics processing unit (GPU) GPGPU Vector Barrel Stream Coprocessor ASIC FPGA CPLD Multi-chip module (MCM) System in package (SiP) By application Microprocessor Microcontroller Mobile Notebook Ultra-low-voltage ASIP Systems on chip System on a chip (SoC) Multiprocessor (MPSoC) Programmable (PSoC) Network on a chip (NoC) Hardware accelerators AI accelerator Vision processing unit (VPU) Physics processing unit (PPU) Digital signal processor (DSP) Tensor processing unit (TPU) Secure cryptoprocessor Network processor Baseband processor Word size 1-bit 4-bit 8-bit 12-bit 15-bit 16-bit 24-bit 32-bit 48-bit 64-bit 128-bit 256-bit 512-bit bit slicing others variable Core count Single-core Multi-core Manycore Heterogeneous architecture Components Core Cache CPU cache replacement policies coherence Bus Clock rate Clock signal FIFO Functional units Arithmetic logic unit (ALU) Address generation unit (AGU) Floating-point unit (FPU) Memory management unit (MMU) Load–store unit Translation lookaside buffer (TLB) Integrated memory controller (IMC) Logic Combinational Sequential Glue Logic gate Quantum Array Registers Processor register Status register Stack register Register file Memory buffer Program counter Control unit Instruction unit Data buffer Write buffer Microcode ROM Counter Datapath Multiplexer Demultiplexer Adder Multiplier CPU Binary decoder Address decoder Sum addressed decoder Barrel shifter Circuitry Integrated circuit 3D Mixed-signal Power management Boolean Digital Analog Quantum Switch Power management PMU APM ACPI Dynamic frequency scaling Dynamic voltage scaling Clock gating Performance per watt (PPW) Race to sleep Related History of general-purpose CPUs Microprocessor chronology Processor design Digital electronics Hardware security module Semiconductor device fabrication Tick–tock model v t e x86 assembly topics Topics Assembly language Comparison of assemblers Disassembler Instruction set Low-level programming language Machine code Microassembler x86 assembly language Assemblers A86/A386 Flat Assembler (FASM) GNU Assembler (GAS) High Level Assembly (HLA) Microsoft Macro Assembler (MASM) Netwide Assembler (NASM) Turbo Assembler (TASM) Open Watcom Assembler (WASM) Programming issues Call stack Flags Carry flag Direction flag Interrupt flag Overflow flag Zero flag Opcode Program counter Processor register Calling conventions Instruction listings Registers Authority control GND: 4359667-8 LCCN: sh85112381 Retrieved from "https://en.wikipedia.org/w/index.php?title=Processor_register&oldid=991464967" Categories: Computer architecture Digital registers Central processing unit Hidden categories: Articles with short description Short description matches Wikidata Articles needing additional references from March 2008 All articles needing additional references Articles needing cleanup from January 2012 All pages needing cleanup Cleanup tagged articles without a reason field from January 2012 Wikipedia pages needing cleanup from January 2012 Wikipedia articles in need of updating from March 2016 All Wikipedia articles in need of updating Articles with multiple maintenance issues All articles with unsourced statements Articles with unsourced statements from February 2016 Articles with unsourced statements from March 2019 Wikipedia articles with GND identifiers Wikipedia articles with LCCN identifiers Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version In other projects Wikimedia Commons Languages العربية Azərbaycanca Български Català Čeština Dansk Deutsch Eesti Ελληνικά Español Esperanto Euskara فارسی Français 한국어 Bahasa Indonesia Íslenska Italiano עברית Қазақша Lietuvių Lumbaart Magyar Македонски Монгол Nederlands 日本語 Norsk bokmål Polski Português Română Русский Slovenčina Српски / srpski Srpskohrvatski / српскохрватски Suomi Svenska Türkçe Українська اردو Tiếng Việt 吴语 粵語 中文 Edit links This page was last edited on 30 November 2020, at 05:15 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement