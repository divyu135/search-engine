Recursive descent parser - Wikipedia Recursive descent parser From Wikipedia, the free encyclopedia Jump to navigation Jump to search Algorithm This article includes a list of general references, but it remains largely unverified because it lacks sufficient corresponding inline citations. Please help to improve this article by introducing more precise citations. (February 2009) (Learn how and when to remove this template message) In computer science, a recursive descent parser is a kind of top-down parser built from a set of mutually recursive procedures (or a non-recursive equivalent) where each such procedure implements one of the nonterminals of the grammar. Thus the structure of the resulting program closely mirrors that of the grammar it recognizes.[1] A predictive parser is a recursive descent parser that does not require backtracking.[2] Predictive parsing is possible only for the class of LL(k) grammars, which are the context-free grammars for which there exists some positive integer k that allows a recursive descent parser to decide which production to use by examining only the next k tokens of input. The LL(k) grammars therefore exclude all ambiguous grammars, as well as all grammars that contain left recursion. Any context-free grammar can be transformed into an equivalent grammar that has no left recursion, but removal of left recursion does not always yield an LL(k) grammar. A predictive parser runs in linear time. Recursive descent with backtracking is a technique that determines which production to use by trying each production in turn. Recursive descent with backtracking is not limited to LL(k) grammars, but is not guaranteed to terminate unless the grammar is LL(k). Even when they terminate, parsers that use recursive descent with backtracking may require exponential time. Although predictive parsers are widely used, and are frequently chosen if writing a parser by hand, programmers often prefer to use a table-based parser produced by a parser generator[citation needed], either for an LL(k) language or using an alternative parser, such as LALR or LR. This is particularly the case if a grammar is not in LL(k) form, as transforming the grammar to LL to make it suitable for predictive parsing is involved. Predictive parsers can also be automatically generated, using tools like ANTLR. Predictive parsers can be depicted using transition diagrams for each non-terminal symbol where the edges between the initial and the final states are labelled by the symbols (terminals and non-terminals) of the right side of the production rule.[3] Contents 1 Example parser 1.1 C implementation 2 Examples 3 See also 4 References 4.1 General references 5 External links Example parser[edit] The following EBNF-like grammar (for Niklaus Wirth's PL/0 programming language, from Algorithms + Data Structures = Programs) is in LL(1) form:  program = block "." .  block =     ["const" ident "=" num {"," ident "=" num} ";"]     ["var" ident {"," ident} ";"]     {"procedure" ident ";" block ";"} statement .  statement =     ident ":=" expression     | "call" ident     | "begin" statement {";" statement } "end"     | "if" condition "then" statement     | "while" condition "do" statement .  condition =     "odd" expression     | expression ("="|"#"|"<"|"<="|">"|">=") expression .  expression = ["+"|"-"] term {("+"|"-") term} .  term = factor {("*"|"/") factor} .  factor =     ident     | number     | "(" expression ")" . Terminals are expressed in quotes. Each nonterminal is defined by a rule in the grammar, except for ident and number, which are assumed to be implicitly defined. C implementation[edit] What follows is an implementation of a recursive descent parser for the above language in C. The parser reads in source code, and exits with an error message if the code fails to parse, exiting silently if the code parses correctly. Notice how closely the predictive parser below mirrors the grammar above. There is a procedure for each nonterminal in the grammar. Parsing descends in a top-down manner, until the final nonterminal has been processed. The program fragment depends on a global variable, sym, which contains the current symbol from the input, and the function nextsym, which updates sym when called. The implementations of the functions nextsym and error are omitted for simplicity. typedef enum {ident, number, lparen, rparen, times, slash, plus,    minus, eql, neq, lss, leq, gtr, geq, callsym, beginsym, semicolon,    endsym, ifsym, whilesym, becomes, thensym, dosym, constsym, comma,    varsym, procsym, period, oddsym} Symbol;Symbol sym;void nextsym(void);void error(const char msg[]);int accept(Symbol s) {    if (sym == s) {        nextsym();        return 1;    }    return 0;}int expect(Symbol s) {    if (accept(s))        return 1;    error("expect: unexpected symbol");    return 0;}void factor(void) {    if (accept(ident)) {        ;    } else if (accept(number)) {        ;    } else if (accept(lparen)) {        expression();        expect(rparen);    } else {        error("factor: syntax error");        nextsym();    }}void term(void) {    factor();    while (sym == times || sym == slash) {        nextsym();        factor();    }}void expression(void) {    if (sym == plus || sym == minus)        nextsym();    term();    while (sym == plus || sym == minus) {        nextsym();        term();    }}void condition(void) {    if (accept(oddsym)) {        expression();    } else {        expression();        if (sym == eql || sym == neq || sym == lss || sym == leq || sym == gtr || sym == geq) {            nextsym();            expression();        } else {            error("condition: invalid operator");            nextsym();        }    }}void statement(void) {    if (accept(ident)) {        expect(becomes);        expression();    } else if (accept(callsym)) {        expect(ident);    } else if (accept(beginsym)) {        do {            statement();        } while (accept(semicolon));        expect(endsym);    } else if (accept(ifsym)) {        condition();        expect(thensym);        statement();    } else if (accept(whilesym)) {        condition();        expect(dosym);        statement();    } else {        error("statement: syntax error");        nextsym();    }}void block(void) {    if (accept(constsym)) {        do {            expect(ident);            expect(eql);            expect(number);        } while (accept(comma));        expect(semicolon);    }    if (accept(varsym)) {        do {            expect(ident);        } while (accept(comma));        expect(semicolon);    }    while (accept(procsym)) {        expect(ident);        expect(semicolon);        block();        expect(semicolon);    }    statement();}void program(void) {    nextsym();    block();    expect(period);} Examples[edit] Some recursive descent parser generators: TMG – an early compiler-compiler used in the 1960s and early 1970s JavaCC Coco/R ANTLR Spirit Parser Framework – a C++ recursive descent parser generator framework requiring no pre-compile step parboiled (Java) – a recursive descent PEG parsing library for Java See also[edit] Parser combinator – a higher-order function used in combinatory parsing, a method of factoring recursive descent parser designs Parsing expression grammar – another form representing recursive descent grammar Recursive ascent parser Tail recursive parser – a variant of the recursive descent parser References[edit] ^ Burge, W.H. (1975). Recursive Programming Techniques. ISBN 0-201-14450-6. ^ Watson, Des (22 March 2017). A Practical Approach to Compiler Construction. Springer. ISBN 978-3-319-52789-5. ^ Aho, Alfred V.; Sethi, Ravi; Ullman, Jeffrey (1986). Compilers: Principles, Techniques and Tools (first ed.). Addison Wesley. p. 183. General references[edit] Compilers: Principles, Techniques, and Tools, first edition, Alfred V Aho, Ravi Sethi, and Jeffrey D Ullman, in particular Section 4.4. Modern Compiler Implementation in Java, Second Edition, Andrew Appel, 2002, ISBN 0-521-82060-X. Recursive Programming Techniques, W.H. Burge, 1975, ISBN 0-201-14450-6 Crafting a Compiler with C, Charles N Fischer and Richard J LeBlanc, Jr, 1991, ISBN 0-8053-2166-7. Compiling with C# and Java, Pat Terry, 2005, ISBN 0-321-26360-X, 624 Algorithms + Data Structures = Programs, Niklaus Wirth, 1975, ISBN 0-13-022418-9 Compiler Construction, Niklaus Wirth, 1996, ISBN 0-201-40353-6 External links[edit] Introduction to Parsing - an easy to read introduction to parsing, with a comprehensive section on recursive descent parsing How to turn a Grammar into C code - a brief tutorial on implementing recursive descent parser Simple mathematical expressions parser in Ruby Simple Top Down Parsing in Python Jack W. Crenshaw: Let's Build A Compiler (1988-1995), in Pascal, with assembly language output, using a "keep it simple" approach Functional Pearls: Monadic Parsing in Haskell v t e Parsing algorithms Top-down LL Recursive descent Tail recursive Pratt parser Bottom-up Precedence Simple Operator Shunting-yard Bounded-context LR Simple Look-ahead Canonical Generalized CYK Recursive ascent Shift-reduce Mixed, other Combinator Chart Earley Related topics PEG Definite clause grammar Deterministic parsing Dynamic programming Memoization Parser generator LALR Parse tree AST Scannerless parsing History of compiler construction Comparison of parser generators Retrieved from "https://en.wikipedia.org/w/index.php?title=Recursive_descent_parser&oldid=990788914" Categories: Parsing algorithms Hidden categories: Articles with short description Short description matches Wikidata Articles lacking in-text citations from February 2009 All articles lacking in-text citations All articles with unsourced statements Articles with unsourced statements from February 2018 Articles with example C code Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages العربية Čeština Deutsch فارسی 한국어 日本語 Norsk bokmål Português Русский Српски / srpski Українська Edit links This page was last edited on 26 November 2020, at 14:41 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement