Befunge - Wikipedia Befunge From Wikipedia, the free encyclopedia Jump to navigation Jump to search This article has multiple issues. Please help improve it or discuss these issues on the talk page. (Learn how and when to remove these template messages) This article needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed. Find sources: "Befunge" – news · newspapers · books · scholar · JSTOR (January 2012) (Learn how and when to remove this template message) This article's lead section does not adequately summarize key points of its contents. Please consider expanding the lead to provide an accessible overview of all important aspects of the article. (January 2012) (Learn how and when to remove this template message) Befunge Developer Chris Pressey First appeared 1993 (1993) Website catseye.tc/node/Befunge-93.html Influenced by Forth, FALSE Befunge is a stack-based, reflective, esoteric programming language. It differs from conventional languages in that programs are arranged on a two-dimensional grid. "Arrow" instructions direct the control flow to the left, right, up or down, and loops are constructed by sending the control flow in a cycle. It has been described as "a cross between Forth and Lemmings".[1] A worthy companion to INTERCAL; a computer language family which escapes the quotidian limitation of linear control flow and embraces program counters flying through multiple dimensions with exotic topologies. — Jargon File[2] Contents 1 History 2 Compilation 3 Sample Befunge-93 code 4 Befunge-93 instruction list 5 See also 6 References 7 External links History[edit] The language was originally created by Chris Pressey[3] in 1993 for the Amiga, as an attempt to devise a language which is as hard to compile as possible. Note that the p command allows for self-modifying code. Nevertheless, a number of compilers have subsequently been written. A number of extensions to the original "Befunge-93" specification also exist, most notably Funge-98, which extends the concept to an arbitrary number of dimensions and can be multithreaded, with multiple instruction pointers operating simultaneously on the same space. Befunge-extensions and variants are called Fungeoids or just Funges. The Befunge-93 specification restricts each valid program to a grid of 80 instructions horizontally by 25 instructions vertically. Program execution which exceeds these limits "wraps around" to a corresponding point on the other side of the grid; a Befunge program is in this manner topologically equivalent to a torus. Since a Befunge-93 program can only have a single stack and its storage array is bounded, the Befunge-93 language is not Turing-complete (however, it has been shown that Befunge-93 is Turing Complete with unbounded stack word size).[4] The later Funge-98 specification provides Turing completeness by removing the size restrictions on the program; rather than wrapping around at a fixed limit, the movement of a Funge-98 instruction pointer follows a model dubbed "Lahey-space" after its originator, Chris Lahey. In this model, the grid behaves like a torus of finite size with respect to wrapping, while still allowing itself to be extended indefinitely. Compilation[edit] As stated, the design goal for Befunge was to create a language which was difficult to compile. This was attempted with the implementation of self-modifying code (the 'p' instruction can write new instructions into the playfield) and a multi-dimensional playfield (the same instruction can be executed in four different directions). Nevertheless, these obstacles have been overcome, to some degree, and Befunge compilers have been written using appropriate techniques. The bef2c compiler included with the standard Befunge-93 distribution uses threaded code: each instruction is compiled to a snippet of C code, and control flows through the snippets just as it does in a Befunge interpreter (that is, conditionally on the value of some 'direction' register). This does not result in a significant advantage over a good interpreter. Note that the bef2c compiler is not correct since it does not handle either 'p' or string mode, but it would not be impossible to make it do so (although the C language might not be well-suited for this). The Betty compiler, for example, treats every possible straight line of instructions as a subprogram, and if a 'p' instruction alters that subprogram, that subprogram is recompiled. This is an interesting variation on just-in-time compilation, and it results in a much better advantage over an interpreter, since many instructions can be executed in native code without making intervening decisions on the 'direction' register. Sample Befunge-93 code[edit] The technique of using arrows to change control flow is demonstrated in the random number generator program below. The Befunge instruction pointer begins in the upper left corner and will travel to the right if not redirected. Following the arrows around, the ? instructions send the instruction pointer in random cardinal directions until the pointer hits a digit, pushing it to the stack. Then the arrows navigate to the . to output the digit from the stack and return the pointer to the first directional randomiser. There is no @ to terminate this program, so it produces an endless stream of random numbers from 1 to 9.  v>>>>>v  12345  ^?^ > ? ?^  v?v  6789  >>>> v ^    .< The following code is an example of the classic "Hello World!" program. First the letters "olleH" are pushed onto the stack as ASCII numbers. These are then popped from the stack in LIFO order and output as text characters to give "Hello". A space is character number 32 in ASCII, which here is constructed by multiplying 4 and 8, before being output as text. The remaining code then outputs "World!" in a similar way, followed by ASCII character 10 (a line feed character, moving the output cursor to a new line). >              vv  ,,,,,"Hello"<>48*,          vv,,,,,,"World!"<>25*,@ The following code is a slightly more complicated version. It adds the ASCII character 10 (a line feed character) to the stack, and then pushes "!dlrow ,olleH" to the stack. Again, LIFO ordering means that "H" is now the top of the stack and will be the first printed, "e" is second, and so on. To print the characters, the program enters a loop that first duplicates the top value on the stack (so now the stack would look like "\n!dlrow ,olleHH"). Then the "_" operation will pop the duplicated value, and go right if it's a zero, left otherwise. (This assumes a compliant interpreter that "returns" 0 when popping an empty stack.) When it goes left, it pops and prints the top value as an ASCII character. It then duplicates the next character and loops back to the "_" test, continuing to print the rest of the stack until it is empty and so the next value popped is 0, at which point "@" ends the program.  >25*"!dlrow ,olleH":v                  v:,_@                  >  ^ Befunge-93 instruction list[edit] 0-9 Push this number on the stack + Addition: Pop a and b, then push a+b - Subtraction: Pop a and b, then push b-a * Multiplication: Pop a and b, then push a*b / Integer division: Pop a and b, then push b/a, rounded towards 0. % Modulo: Pop a and b, then push the remainder of the integer division of b/a. ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero. ` Greater than: Pop a and b, then push 1 if b>a, otherwise zero. > Start moving right < Start moving left ^ Start moving up v Start moving down ? Start moving in a random cardinal direction _ Pop a value; move right if value=0, left otherwise | Pop a value; move down if value=0, up otherwise " Start string mode: push each character's ASCII value all the way up to the next " : Duplicate value on top of the stack \ Swap two values on top of the stack $ Pop value from the stack and discard it . Pop value and output as an integer followed by a space , Pop value and output as ASCII character # Bridge: Skip next cell p A "put" call (a way to store a value for later use). Pop y, x, and v, then change the character at (x,y) in the program to the character with ASCII value v g A "get" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program & Ask user for a number and push it ~ Ask user for a character and push its ASCII value @ End program (space) No-op. Does nothing Most one-dimensional programming languages require some syntactic distinction between comment text and source code — although that distinction may be as trivial as Brainfuck's rule that any character not in the set +-[]<>,. is a comment. Languages like Lisp and Python treat strings as comments in contexts where the values are not used. Similarly, in Befunge, there is no comment syntax: to embed documentation in the code, the programmer simply routes the control flow around the "comment" area, so that the text in that area is never executed. See also[edit] Brainfuck Carnage Heart - PlayStation programming game using a similar language INTERCAL Whitespace Malbolge Piet References[edit] ^ "The Befunge FAQ v.4". 1997-11-04. Archived from the original on 2001-04-17. Retrieved 2014-01-23. ^ Raymond, Eric (2003-12-29). "The Jargon File 4.4.7". Jargon File Text Archive. Archived from the original on 2016-01-05. Retrieved 2012-01-16. ^ Ais523 (2008-12-18). "Chris Pressey". Esolang. Retrieved 2014-01-23. ^ Oerjan (2014-01-18). "Talk:Befunge". Esolang. Retrieved 2014-01-23. External links[edit] Befunge-93 Specification Befunge-93 Reference Implementation Funge-98 Specification Retrieved from "https://en.wikipedia.org/w/index.php?title=Befunge&oldid=987214378" Categories: Esoteric programming languages Stack-oriented programming languages Non-English-based programming languages Programming languages created in 1993 Hidden categories: Articles needing additional references from January 2012 All articles needing additional references Wikipedia introduction cleanup from January 2012 All pages needing cleanup Articles covered by WikiProject Wikify from January 2012 All articles covered by WikiProject Wikify Articles with multiple maintenance issues Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages العربية Čeština Deutsch Eesti Español Français Galego 한국어 Nederlands 日本語 Polski Português Русский Slovenčina Српски / srpski Suomi Svenska Українська Edit links This page was last edited on 5 November 2020, at 17:12 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement