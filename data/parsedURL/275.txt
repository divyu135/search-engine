GNU Bison - Wikipedia GNU Bison From Wikipedia, the free encyclopedia (Redirected from GNU bison) Jump to navigation Jump to search Yacc-compatible parser generator program GNU Bison Original author(s) Robert Corbett Developer(s) The GNU Project Initial release June 1985; 35 years ago (1985-06)[1] Stable release 3.7.2 / September 5, 2020; 2 months ago (2020-09-05)[2] Repository git.savannah.gnu.org/cgit/bison.git Written in C and m4 Operating system Unix-like Type Parser generator License GPL Website https://savannah.gnu.org/projects/bison/ www.gnu.org/software/bison/, https://savannah.gnu.org/projects/bison/ GNU Bison, commonly known as Bison, is a parser generator that is part of the GNU Project. Bison reads a specification of a context-free language, warns about any parsing ambiguities, and generates a parser (either in C, C++, or Java) which reads sequences of tokens and decides whether the sequence conforms to the syntax specified by the grammar. The generated parsers are portable: they do not require any specific compilers. Bison by default generates LALR(1) parsers but it can also generate canonical LR, IELR(1) and GLR parsers.[3] In POSIX mode, Bison is compatible with Yacc, but also has several extensions over this earlier program, including: generation of counterexamples for conflicts, location tracking (e.g., file, line, column), rich and internationalizable syntax error messages in the generated parsers, customizable syntax error generation, reentrant parsers, push parsers, with autocompletion, support for named references, several types of reports (graphical, XML) on the generated parser, support for several programming languages, etc. Flex, an automatic lexical analyser, is often used with Bison, to tokenise input data and provide Bison with tokens.[4] Bison was originally written by Robert Corbett in 1985.[1] Later, in 1989, Robert Corbett released another parser generator named Berkeley Yacc. Bison was made Yacc-compatible by Richard Stallman.[5] Bison is free software and is available under the GNU General Public License, with an exception (discussed below) allowing its generated code to be used without triggering the copyleft requirements of the licence. Contents 1 Some Bison Features 1.1 Counterexample Generation 1.2 Reentrancy 1.3 Several Output Languages 2 License and distribution of generated code 2.1 A GPL-compatible license is not required 2.2 Distribution of packages using Bison 3 Use 4 A complete reentrant parser example 5 See also 6 References 7 Further reading 8 External links Some Bison Features[edit] Counterexample Generation[edit] One delicate issue with LR parser generators is the resolution of conflicts (shift/reduce and reduce/reduce conflicts). Resolving conflicts usually requires the analysis of the parser automaton as described in the reports, and some expertise from the user. Counterexamples help understanding quickly some conflicts, and can even actually prove that the problem is that the grammar is actually ambiguous. For instance on a grammar suffering from the infamous dangling else problem, Bison reports doc/if-then-else.y: warning: shift/reduce conflict on token "else" [-Wcounterexamples]  Example: "if" expr "then" "if" expr "then" stmt • "else" stmt  Shift derivation    if_stmt    ↳ "if" expr "then" stmt                        ↳ if_stmt                           ↳ "if" expr "then" stmt • "else" stmt  Example: "if" expr "then" "if" expr "then" stmt • "else" stmt  Reduce derivation    if_stmt    ↳ "if" expr "then" stmt                        "else" stmt                        ↳ if_stmt                           ↳ "if" expr "then" stmt • Reentrancy[edit] Reentrancy is a feature which has been added to Bison and does not exist in Yacc. Normally, Bison generates a parser which is not reentrant. In order to achieve reentrancy the declaration %define api.pure must be used. More details on Bison reentrancy can be found in the Bison manual.[6] Several Output Languages[edit] Bison can generate code for C, C++ and Java.[7] An experimental backend for D is also available.[8] For using the Bison generated parser from other languages a language binding tool such as SWIG can be used. License and distribution of generated code[edit] Because Bison generates source code that in turn gets added to the source code of other software projects, it raises some simple but interesting copyright questions. A GPL-compatible license is not required[edit] The code generated by Bison includes significant amounts of code from the Bison project itself. The Bison package is distributed under the terms of the GNU General Public License (GPL) but an exception has been added so that the GPL does not apply to output.[9][10] Earlier releases of Bison stipulated that parts of its output were also licensed under the GPL, due to the inclusion of the yyparse() function from the original source code in the output. Distribution of packages using Bison[edit] Free software projects that use Bison may have a choice of whether to distribute the source code which their project feeds into Bison, or the resulting C code made output by Bison. Both are sufficient for a recipient to be able to compile the project source code. However, distributing only the input carries the minor inconvenience that the recipients must have a compatible copy of Bison installed so that they can generate the necessary C code when compiling the project. And distributing only the C code in output, creates the problem of making it very difficult for the recipients to modify the parser since this code was written neither by a human nor for humans - its purpose is to be fed directly into a C compiler. These problems can be avoided by distributing both the input files and the generated code. Most people will compile using the generated code, no different from any other software package, but anyone who wants to modify the parser component can modify the input files first and re-generate the generated files before compiling. Projects distributing both usually do not have the generated files in their revision control systems. The files are only generated when making a release. Some licenses, such as the GPL, require that the source code be in "the preferred form of the work for making modifications to it". GPL'd projects using Bison must thus distribute the files which are the input for Bison. Of course, they can also include the generated files. Use[edit] Because Bison was written as a replacement for Yacc, and is largely compatible, the code from a lot of projects using Bison could equally be fed into Yacc. This makes it difficult to determine if a project "uses" Bison-specific source code or not. In many cases, the "use" of Bison could be trivially replaced by the equivalent use of Yacc or one of its other derivatives. Bison does have features not found in Yacc, so some projects can be truly said to "use" Bison, since Yacc would not suffice. The following list is of projects which are known to "use" Bison in the looser sense, that they use free software development tools and distribute code which is intended to be fed into Bison or a Bison-compatible package. Bison's own grammar parser is generated by Bison[11] The Ruby programming language (YARV) The PHP programming language (Zend Parser) GCC started out using Bison, but switched to a hand-written recursive-descent parser for C++ in 2004 (version 3.4),[12] and for C and Objective-C in 2006 (version 4.1)[13] The Go programming language (GC) used Bison, but switched to a hand-written scanner and parser in version 1.5.[14] Bash shell uses a yacc grammar for parsing the command input. LilyPond PostgreSQL[15] MySQL[16] GNU Octave uses a Bison-generated parser.[17] Perl 5 uses a Bison-generated parser starting in 5.10.[18] A complete reentrant parser example[edit] This section is written like a manual or guidebook. Please help rewrite this section from a descriptive, neutral point of view, and remove advice or instruction. (September 2016) (Learn how and when to remove this template message) The following example shows how to use Bison and flex to write a simple calculator program (only addition and multiplication) and a program for creating an abstract syntax tree. The next two files provide definition and implementation of the syntax tree functions. /* * Expression.h * Definition of the structure used to build the syntax tree. */#ifndef __EXPRESSION_H__#define __EXPRESSION_H__/** * @brief The operation type */typedef enum tagEOperationType{    eVALUE,    eMULTIPLY,    eADD} EOperationType;/** * @brief The expression structure */typedef struct tagSExpression{    EOperationType type; /* /< type of operation */    int value; /* /< valid only when type is eVALUE */    struct tagSExpression *left; /* /<  left side of the tree */    struct tagSExpression *right; /* /< right side of the tree */} SExpression;/** * @brief It creates an identifier * @param value The number value * @return The expression or NULL in case of no memory */SExpression *createNumber(int value);/** * @brief It creates an operation * @param type The operation type * @param left The left operand * @param right The right operand * @return The expression or NULL in case of no memory */SExpression *createOperation(EOperationType type, SExpression *left, SExpression *right);/** * @brief Deletes a expression * @param b The expression */void deleteExpression(SExpression *b);#endif /* __EXPRESSION_H__ */ /* * Expression.c * Implementation of functions used to build the syntax tree. */#include "Expression.h"#include <stdlib.h>/** * @brief Allocates space for expression * @return The expression or NULL if not enough memory */static SExpression *allocateExpression(){    SExpression *b = (SExpression *)malloc(sizeof(SExpression));    if (b == NULL)        return NULL;    b->type = eVALUE;    b->value = 0;    b->left = NULL;    b->right = NULL;    return b;}SExpression *createNumber(int value){    SExpression *b = allocateExpression();    if (b == NULL)        return NULL;    b->type = eVALUE;    b->value = value;    return b;}SExpression *createOperation(EOperationType type, SExpression *left, SExpression *right){    SExpression *b = allocateExpression();    if (b == NULL)        return NULL;    b->type = type;    b->left = left;    b->right = right;    return b;}void deleteExpression(SExpression *b){    if (b == NULL)        return;    deleteExpression(b->left);    deleteExpression(b->right);    free(b);} The tokens needed by the Bison parser will be generated using flex. %{/* * Lexer.l file * To generate the lexical analyzer run: "flex Lexer.l" */#include "Expression.h"#include "Parser.h"#include <stdio.h>%}%option outfile="Lexer.c" header-file="Lexer.h"%option warn nodefault%option reentrant noyywrap never-interactive nounistd%option bison-bridge%%[ \r\n\t]*   { continue; /* Skip blanks. */ }[0-9]+       { sscanf(yytext, "%d", &yylval->value); return TOKEN_NUMBER; }"*"          { return TOKEN_STAR; }"+"          { return TOKEN_PLUS; }"("          { return TOKEN_LPAREN; }")"          { return TOKEN_RPAREN; }.            { continue; /* Ignore unexpected characters. */}%%int yyerror(const char *msg) {    fprintf(stderr, "Error: %s\n", msg);    return 0;} The names of the tokens are typically neutral: "TOKEN_PLUS" and "TOKEN_STAR", not "TOKEN_ADD" and "TOKEN_MULTIPLY". For instance if we were to support the unary "+" (as in "+1"), it would be wrong to name this "+" "TOKEN_ADD". In a language such as C, "int *ptr" denotes the definition of a pointer, not a product: it would be wrong to name this "*" "TOKEN_MULTIPLY". Since the tokens are provided by flex we must provide the means to communicate between the parser and the lexer.[19] The data type used for communication, YYSTYPE, is set using Bison %union declaration. Since in this sample we use the reentrant version of both flex and yacc we are forced to provide parameters for the yylex function, when called from yyparse.[19] This is done through Bison %lex-param and %parse-param declarations.[20] %{/* * Parser.y file * To generate the parser run: "bison Parser.y" */#include "Expression.h"#include "Parser.h"#include "Lexer.h"int yyerror(SExpression **expression, yyscan_t scanner, const char *msg) {    /* Add error handling routine as needed */}%}%code requires {  typedef void* yyscan_t;}%output  "Parser.c"%defines "Parser.h"%define api.pure%lex-param   { yyscan_t scanner }%parse-param { SExpression **expression }%parse-param { yyscan_t scanner }%union {    int value;    SExpression *expression;}%token TOKEN_LPAREN   "("%token TOKEN_RPAREN   ")"%token TOKEN_PLUS     "+"%token TOKEN_STAR     "*"%token <value> TOKEN_NUMBER "number"%type <expression> expr/* Precedence (increasing) and associativity:   a+b+c is (a+b)+c: left associativity   a+b*c is a+(b*c): the precedence of "*" is higher than that of "+". */%left "+"%left "*"%%input    : expr { *expression = $1; }    ;expr    : expr[L] "+" expr[R] { $$ = createOperation( eADD, $L, $R ); }    | expr[L] "*" expr[R] { $$ = createOperation( eMULTIPLY, $L, $R ); }    | "(" expr[E] ")"     { $$ = $E; }    | "number"            { $$ = createNumber($1); }    ;%% The code needed to obtain the syntax tree using the parser generated by Bison and the scanner generated by flex is the following. /* * main.c file */#include "Expression.h"#include "Parser.h"#include "Lexer.h"#include <stdio.h>int yyparse(SExpression **expression, yyscan_t scanner);SExpression *getAST(const char *expr){    SExpression *expression;    yyscan_t scanner;    YY_BUFFER_STATE state;    if (yylex_init(&scanner)) {        /* could not initialize */        return NULL;    }    state = yy_scan_string(expr, scanner);    if (yyparse(&expression, scanner)) {        /* error parsing */        return NULL;    }    yy_delete_buffer(state, scanner);    yylex_destroy(scanner);    return expression;}int evaluate(SExpression *e){    switch (e->type) {        case eVALUE:            return e->value;        case eMULTIPLY:            return evaluate(e->left) * evaluate(e->right);        case eADD:            return evaluate(e->left) + evaluate(e->right);        default:            /* should not be here */            return 0;    }}int main(void){    char test[] = " 4 + 2*10 + 3*( 5 + 1 )";    SExpression *e = getAST(test);    int result = evaluate(e);    printf("Result of '%s' is %d\n", test, result);    deleteExpression(e);    return 0;} A simple makefile to build the project is the following. # MakefileFILES = Lexer.c Parser.c Expression.c main.cCC = g++CFLAGS = -g -ansitest: $(FILES)	$(CC) $(CFLAGS) $(FILES) -o testLexer.c: Lexer.l	flex Lexer.lParser.c: Parser.y Lexer.c	bison Parser.yclean:	rm -f *.o *~ Lexer.c Lexer.h Parser.c Parser.h test See also[edit] Free and open-source software portal Berkeley Yacc (byacc) – another free software Yacc replacement sharing the same author as GNU Bison References[edit] ^ a b Corbett, Robert Paul (June 1985). Static Semantics and Compiler Error Recovery (Ph.D.). University of California, Berkeley. DTIC ADA611756. ^ "Bison 3.7.2 released [stable]". ^ Bison Manual: Introduction. ^ Levine, John (August 2009). flex & bison. O'Reilly Media. ISBN 978-0-596-15597-1. ^ "AUTHORS". bison.git. GNU Savannah. Retrieved 2017-08-26. ^ Bison Manual: A Pure (Reentrant) Parser ^ Bison Manual: Bison Declaration Summary ^ https://savannah.gnu.org/forum/forum.php?forum_id=9639 Bison 3.5 released ^ Bison Manual: Conditions for Using Bison ^ A source code file, parse-gram.c, which includes the exception ^ "parse-gram.y". bison.git. GNU Savannah. Retrieved 2020-07-29. ^ GCC 3.4 Release Series Changes, New Features, and Fixes ^ GCC 4.1 Release Series Changes, New Features, and Fixes ^ Golang grammar definition ^ http://www.postgresql.org/docs/9.0/static/parser-stage.html ^ https://www.safaribooksonline.com/library/view/flex-bison/9780596805418/ch04.html ^ http://octave.org/doxygen/4.0/d5/d60/oct-parse_8cc_source.html ^ http://perldoc.perl.org/perl5100delta.html ^ a b Flex Manual: C Scanners with Bison Parsers Archived 2010-12-17 at the Wayback Machine ^ Bison Manual: Calling Conventions for Pure Parsers Further reading[edit] Levine, John (August 2009). flex & bison. O'Reilly Media. ISBN 978-0-596-15597-1. External links[edit] Website in the GNU Project Manual Bison project at GNU Savannah Entry in the Free Software Directory Internals of C parsers generated by GNU Bison How to download and install Bison (GNU Parser Generator) on Linux Win32 binaries by GnuWin32 (version 2.4.1) v t e GNU Project History GNU Manifesto Free Software Foundation Europe India Latin America History of free software Licenses GNU General Public License linking exception font exception GNU Lesser General Public License GNU Affero General Public License GNU Free Documentation License Software GNU (variants) Hurd Linux-libre glibc Bash coreutils findutils Build System GCC binutils GDB GRUB GNOME GNUstep GIMP Jami GNU Emacs GNU TeXmacs GNU Octave GNU Taler GNU R GSL GMP GNU Electric GNU Archimedes GNUnet GNU Privacy Guard Gnuzilla (IceCat) GNU Health GNUmed GNU LilyPond GNU Go GNU Chess Gnash Guix more... Public speakers Alexandre Oliva Benjamin Mako Hill Bradley M. Kuhn Federico Heinz Frédéric Couchet Georg C. F. Greve John Sullivan José E. Marchesi Joshua Gay Kefah T. Issa Loïc Dachary Nagarjuna G. Peter Heath Richard M. Stallman Other topics GNU/Linux naming controversy Revolution OS Free Software Foundation anti-Windows campaigns Defective by Design Retrieved from "https://en.wikipedia.org/w/index.php?title=GNU_Bison&oldid=988316988" Categories: GNU Project software Compiling tools Parser generators Cross-platform software Hidden categories: Webarchive template wayback links Articles with short description Short description is different from Wikidata Wikipedia articles with style issues from September 2016 All articles with style issues Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages Català Čeština Dansk Deutsch Español فارسی Français 한국어 Italiano עברית 日本語 Norsk bokmål Polski Português Русский Српски / srpski Українська 中文 Edit links This page was last edited on 12 November 2020, at 12:51 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement