Microsequencer - Wikipedia Microsequencer From Wikipedia, the free encyclopedia Jump to navigation Jump to search In computer architecture and engineering, a sequencer or microsequencer generates the addresses used to step through the microprogram of a control store. It is used as a part of the control unit of a CPU or as a stand-alone generator for address ranges. Usually the addresses are generated by some combination of a counter, a field from a microinstruction, and some subset of the instruction register. A counter is used for the typical case, that the next microinstruction is the one to execute. A field from the microinstruction is used for jumps, or other logic. Since CPUs implement an instruction set, it's very useful to be able to decode the instruction's bits directly into the sequencer, to select a set of microinstructions to perform a CPU's instructions. Most modern CISC processors use a combination of pipelined logic to process lower complexity opcodes which can be completed in one clock cycle, and microcode to implement ones that take multiple clock cycles to complete. One of the first integrated microcoded processors was the IBM PALM Processor, which emulated all of the processor's instruction in microcode and was used on the IBM 5100, one of the first personal computers. Recent examples of similar microsequencer-based processors are the MicroCore Labs MCL86, MCL51 , and MCL65 cores which emulate the Intel 8086/8088, 8051 and MOS 6502 instruction sets entirely in microcode. Contents 1 Simple example 2 Complex example 2.1 Functional branch format 2.2 CD = 0, 1, 3 format 2.3 CD = 2 format 2.4 Simplification 3 References Simple example[edit] The Digital Scientific Corp. Meta 4 Series 16 computer system was a user-microprogrammable system first available in 1970. Branches in the microcode sequence occur inone of three ways.[1] A branch microinstruction specifies the address of the next instruction, either conditionally or unconditionally. The logical index (IX) option causes the 16-bit Link register to be logical ORed into the branch address, thus providing a simple indexed branch capability. All the arithmetic/logical instructions allow the jump (J) modifier, which redirects execution to the microinstruction addressed by the Link register. All the arithmetic/logical instructions allow both the decrement counter (D) and jump (J) modifiers. In this case, the 8-bit loop counter register is decremented. If it is then not zero, a branch is taken to the contents of the Link register. If it is zero, execution continues with the next instruction. One more sequencing option allowed on a branch instruction is the execute (XQ) option. When specified, the single instruction at the branch address is executed, but then execution continues after the original branch instruction. The IX option can be used with the XQ option. Complex example[edit] The IBM System/360 was a series of compatible computers introduced in 1964, many of which were microprogrammed.[2] The System/360 Model 40 is a good example of a microprogrammed machine with complex microsequencing.[3] The microstore consists of 4,096 56-bit microinstructions that operate ina horizontal microprogramming style. The store is addressed by the 12-bitread-only address register (ROAR). Unlike most registers in theS/360 architecture, bits in the ROAR are numbered from bit 0 on the rightto bit 11 on the left.   +------------+  |    ROAR    |  +------------+  11          0 The model 40 performs no sequential execution of microinstructions andtherefore the microsequencer doesn't really branch in the conventionalsense. Instead, each microinstruction specifies the address of the next oneto be executed. Four fields in the microinstruction contribute to the newaddress. CA, 4 bits: Part of the next address, depending on the other fields. CB, 4 bits: Determines bit 1 of the next address. CC, 4 bits: Determines bit 0 of the next address. CD, 2 bits: Controls how the next address is assembled (except when the CB field contains 15). There are essentially three combinations or formats of these fields. Functional branch format[edit] When the CB field contains 15, a functional branch occurs. The bits ofthe new microstore address in the ROAR are determined as follows. bits 11–10: CD field bits 9–6: CA field bit 5: always 0 bits 4–1: high-order 4 bits of the Q register, which is the right input to the 8-bit ALU bit 0: result of the test specified by the CC field The CC field can specify various tests of the state of the machine. It canalso specify a constant 0 or 1 for an unconditional bit. This format alters the flow of control to 1 of 16 instruction pairswithin the low 32 words of a 64-word block of microstore (because bit 5 isalways 0). The CC field then determines which instruction of the pairreceives control. CD = 0, 1, 3 format[edit] When the CD field is 0, 1, or 3, flow of control is directed to aninstruction within the current 64-word block. The bits of the new microstoreaddress are determined as follows. bits 11–6: remain the same bits 5–2: CA field bit 1: if CD = 0, result of the test specified by the CB field; otherwise 0 bit 0: result of the test specified by the CC field The CA field selects 1 of 16 4-word groups within the current 64-word block.The CB and CC fields then determine which instruction of the 4 receivescontrol. CD = 2 format[edit] When the CD field is 2, flow of control is directed in a nonobvious manner. Thebits of the new microstore address are determined as follows: bits 11–10: remain the same bits 9–6: CA field bits 5–2: remain the same bit 1: result of the test specified by the CB field bit 0: result of the test specified by the CC field The next instruction is in the same 1K-word region as the currentinstruction, because bits 11–10 remain the same. The CA field determinesthe 64-word block within the region. The instruction is in the same 4-wordgroup within the new block as the current instruction is within the currentblock, because bits 5–2 remain the same.The CB and CC fields then determine which instruction of the 4 receivescontrol. Simplification[edit] This description has been simplified. It ignores the following features. The model 40 can run in CPU mode or channel mode. The description addresses only CPU mode. If the microinstruction is not in functional branch format and the CD field is 1 or 3, bit 1 of the next address is always 0. In this case, the values of the CD and CB fields determine one of a set of control lines to raise. References[edit] ^ Digital Scientific Meta 4 Series 16 Computer System Reference Manual (PDF). Digital Scientific Corporation. May 1971. 7032MO. ^ IBM System/360 Principles of Operation (PDF). International Business Machines Corp. September 1968. A22-6821-7. ^ System/360 Model 40 Functional Units (PDF). International Business Machines Corp. March 1970. SY22-2843-1. v t e Processor technologies Models Turing machine Universal Post–Turing Quantum Belt machine Stack machine Finite-state machine with datapath Hierarchical Queue automaton Register machines Counter Pointer Random-access Random-access stored program Architecture Microarchitecture Von Neumann Harvard modified Dataflow Transport-triggered Cellular Endianness Memory access NUMA HUMA Load/store Register/memory Cache hierarchy Memory hierarchy Virtual memory Secondary storage Heterogeneous Fabric Multiprocessing Cognitive Neuromorphic Instruction set architectures Types CISC RISC Application-specific EDGE TRIPS VLIW EPIC MISC OISC NISC ZISC Comparison Addressing modes Instruction sets x86 ARM MIPS Power ISA SPARC Itanium Unicore MicroBlaze RISC-V LMC Others Execution Instruction pipelining Pipeline stall Operand forwarding Classic RISC pipeline Hazards Data dependency Structural Control False sharing Out-of-order Tomasulo algorithm Reservation station Re-order buffer Register renaming Speculative Branch prediction Memory dependence prediction Parallelism Level Bit Bit-serial Word Instruction Pipelining Scalar Superscalar Task Thread Process Data Vector Memory Distributed Multithreading Temporal Simultaneous Hyperthreading Speculative Preemptive Cooperative Flynn's taxonomy SISD SIMD SWAR SIMT MISD MIMD SPMD Processor performance Transistor count Instructions per cycle (IPC) Cycles per instruction (CPI) Instructions per second (IPS) Floating-point operations per second (FLOPS) Transactions per second (TPS) Synaptic updates per second (SUPS) Performance per watt (PPW) Cache performance metrics Computer performance by orders of magnitude Types Central processing unit (CPU) Graphics processing unit (GPU) GPGPU Vector Barrel Stream Coprocessor ASIC FPGA CPLD Multi-chip module (MCM) System in package (SiP) By application Microprocessor Microcontroller Mobile Notebook Ultra-low-voltage ASIP Systems on chip System on a chip (SoC) Multiprocessor (MPSoC) Programmable (PSoC) Network on a chip (NoC) Hardware accelerators AI accelerator Vision processing unit (VPU) Physics processing unit (PPU) Digital signal processor (DSP) Tensor processing unit (TPU) Secure cryptoprocessor Network processor Baseband processor Word size 1-bit 4-bit 8-bit 12-bit 15-bit 16-bit 24-bit 32-bit 48-bit 64-bit 128-bit 256-bit 512-bit bit slicing others variable Core count Single-core Multi-core Manycore Heterogeneous architecture Components Core Cache CPU cache replacement policies coherence Bus Clock rate Clock signal FIFO Functional units Arithmetic logic unit (ALU) Address generation unit (AGU) Floating-point unit (FPU) Memory management unit (MMU) Load–store unit Translation lookaside buffer (TLB) Integrated memory controller (IMC) Logic Combinational Sequential Glue Logic gate Quantum Array Registers Processor register Status register Stack register Register file Memory buffer Program counter Control unit Instruction unit Data buffer Write buffer Microcode ROM Counter Datapath Multiplexer Demultiplexer Adder Multiplier CPU Binary decoder Address decoder Sum addressed decoder Barrel shifter Circuitry Integrated circuit 3D Mixed-signal Power management Boolean Digital Analog Quantum Switch Power management PMU APM ACPI Dynamic frequency scaling Dynamic voltage scaling Clock gating Performance per watt (PPW) Race to sleep Related History of general-purpose CPUs Microprocessor chronology Processor design Digital electronics Hardware security module Semiconductor device fabrication Tick–tock model Retrieved from "https://en.wikipedia.org/w/index.php?title=Microsequencer&oldid=979937117" Categories: Central processing unit Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages العربية 日本語 Edit links This page was last edited on 23 September 2020, at 16:54 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement