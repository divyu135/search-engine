Symbolic link - Wikipedia Symbolic link From Wikipedia, the free encyclopedia (Redirected from Symlink) Jump to navigation Jump to search For the Microsoft data exchange format, see SYmbolic LinK (SYLK). In computing, a symbolic link (also symlink or soft link) is a term for any file that contains a reference to another file or directory in the form of an absolute or relative path and that affects pathname resolution.[1] Symbolic links were already present by 1978 in minicomputer operating systems from DEC and Data General's RDOS. Today they are supported by the POSIX operating system standard, most Unix-like operating systems such as FreeBSD, Linux, and macOS. Limited support also exists in Windows operating systems such as Windows Vista, Windows 7 and to some degree in Windows 2000 and Windows XP in the form of shortcut files. Contents 1 Overview 2 POSIX and Unix-like operating systems 2.1 Storage of symbolic links 2.2 Mac OS aliases 3 Microsoft Windows 3.1 NTFS symbolic link 3.1.1 Examples 3.2 NTFS junction points 3.3 Shortcuts 3.3.1 Folder shortcuts 3.4 Shell objects 3.5 Cygwin symbolic links 4 Summary 5 Legacy systems 5.1 Amiga 5.2 OS/2 6 Variable symbolic links 7 See also 8 References 9 External links Overview[edit] A symbolic link contains a text string that is automatically interpreted and followed by the operating system as a path to another file or directory. This other file or directory is called the "target". The symbolic link is a second file that exists independently of its target. If a symbolic link is deleted, its target remains unaffected. If a symbolic link points to a target, and sometime later that target is moved, renamed or deleted, the symbolic link is not automatically updated or deleted, but continues to exist and still points to the old target, now a non-existing location or file. Symbolic links pointing to moved or non-existing targets are sometimes called broken, orphaned, dead, or dangling. Symbolic links are different from hard links. Hard links do not link paths on different volumes or file systems, whereas symbolic links may point to any file or directory irrespective of the volumes on which the link and target reside.Hard links always refer to an existing file, whereas symbolic links may contain an arbitrary path that does not point to anything. Symbolic links operate transparently for many operations: programs that read or write to files named by a symbolic link will behave as if operating directly on the target file. However, they have the effect of changing an otherwise hierarchic filesystem from a tree into a directed graph, which can have consequences for such simple operations as determining the current directory of a process. Even the Unix standard for navigating to a directory's parent directory no longer works reliably in the face of symlinks. Some shells heuristically try to uphold the illusion of a tree-shaped hierarchy, but when they do, this causes them to produce different results from other programs that manipulate pathnames without such heuristic, relying on the operating system instead.[2]Programs that need to handle symbolic links specially (e.g., shells and backup utilities) thus need to identify and manipulate them directly. Some Unix as well as Linux distributions use symbolic links extensively in an effort to reorder the file system hierarchy. This is accomplished with several mechanisms, such as variant, context-dependent symbolic links. This offers the opportunity to create a more intuitive or application-specific directory tree and to reorganize the system without having to redesign the core set of system functions and utilities. POSIX and Unix-like operating systems[edit] In POSIX-compliant operating systems, symbolic links are created with the symlink[3] system call. The ln shell command normally uses the link[4] system call, which creates a hard link. When the ln -s flag is specified, the symlink() system call is used instead, creating a symbolic link. Symlinks were introduced in 4.2BSD Unix from U.C. Berkeley. The following command creates a symbolic link at the command-line interface (shell):  ln -s target_path link_path target_path is the relative or absolute path to which the symbolic link should point. Usually the target will exist, although symbolic links may be created to non-existent targets. link_path is the path of the symbolic link. After creating the symbolic link, it may generally be treated as an alias for the target. Any file system management commands (e.g., cp, rm) may be used on the symbolic link. Commands which read or write file contents will access the contents of the target file. The rm (delete file) command, however, removes the link itself, not the target file. Likewise, the mv command moves or renames the link, not the target. The POSIX directory listing application, ls, denotes symbolic links with an arrow after the name, pointing to the name of the target file (see following example), when the long directory list is requested (-l option). When a directory listing of a symbolic link that points to a directory is requested, only the link itself will be displayed. In order to obtain a listing of the linked directory, the path must include a trailing directory separator character ('/', slash). Note: In the example below do not create "three" directory before creation of link in /tmp directory. $ mkdir -p /tmp/one/two$ echo "test_a" >/tmp/one/two/a$ echo "test_b" >/tmp/one/two/b$ cd /tmp/one/two$ ls -l-rw-r--r-- 1 user group 7 Jan 01 10:01 a-rw-r--r-- 1 user group 7 Jan 01 10:01 b$ cd /tmp$ ln -s /tmp/one/two three$ ls -l threelrwxrwxrwx 1 user group 12 Jul 22 10:02 /tmp/three -> /tmp/one/two$ ls -l three/-rw-r--r-- 1 user group 7 Jan 01 10:01 a-rw-r--r-- 1 user group 7 Jan 01 10:01 b$ cd three$ ls -l-rw-r--r-- 1 user group 7 Jan 01 10:01 a-rw-r--r-- 1 user group 7 Jan 01 10:01 b$ cat atest_a$ cat /tmp/one/two/atest_a$ echo "test_c" >/tmp/one/two/a$ cat /tmp/one/two/atest_c$ cat atest_c Storage of symbolic links[edit] Early implementations of symbolic links stored the symbolic link information as data in regular files. The file contained the textual reference to the link's target, and the file mode bits indicated that the type of the file is a symbolic link. This method was slow and an inefficient use of disk-space on small systems. An improvement, called fast symlinks, allowed storage of the target path within the data structures used for storing file information on disk (inodes). This space normally stores a list of disk block addresses allocated to a file. Thus, symlinks with short target paths are accessed quickly. Systems with fast symlinks often fall back to using the original method if the target path exceeds the available inode space. The original style is retroactively termed a slow symlink. It is also used for disk compatibility with other or older versions of operating systems. Although storing the link value inside the inode saves a disk block and a disk read, the operating system still needs to parse the path name in the link, which always requires reading additional inodes and generally requires reading other, and potentially many, directories, processing both the list of files and the inodes of each of them until it finds a match with the link's path components. Only when a link points to a file in the same directory do "fast symlinks" provide significantly better performance than other symlinks. The vast majority of POSIX-compliant implementations use fast symlinks. However, the POSIX standard does not require the entire set of file status information common to regular files to be implemented for symlinks. This allows implementations to use other solutions, such as storing symlink data in directory entries. The file system permissions of a symbolic link are not used; the access modes of the target file are controlled by the target file's own permissions. Some operating systems, such as FreeBSD, offer the ability to modify file permissions and filesystem attributes of a symbolic link, through lchmod[5] and lchflags[6] system calls respectively. The reported size of a symlink is the number of characters in the path it points to. Mac OS aliases[edit] Main article: Alias (Mac OS) In Mac OS, applications or users can also employ aliases, which have the added feature of following the target, even if it is moved to another location on the same volume. This is not to be confused with the shell command alias. Microsoft Windows[edit] NTFS symbolic link[edit] Main article: NTFS symbolic link NTFS 3.1 introduced support for symbolic links for any type of file. It was included with Windows XP, but was only enabled by default for kernel mode programs; Windows Vista and later versions of Windows enabled support for symbolic links to user mode applications, as well, and supplied the command line utility mklink for creating them. Third-party drivers are required to enable support for NTFS symbolic links in Windows XP.[7] Unlike junction points, a symbolic link can also point to a file or remote Server Message Block (SMB) network path. Additionally, the NTFS symbolic link implementation provides full support for cross-filesystem links. However, the functionality enabling cross-host symbolic links requires that the remote system also support them. Symbolic links are designed to aid in migration and application compatibility with POSIX operating systems. Microsoft aimed for Windows Vista's symbolic links to "function just like UNIX links".[8] However, the implementation varies from Unix symbolic links in several ways. For example, Windows Vista users must manually indicate when creating a symbolic link whether it is a file or a directory.[9] Windows 7 and Vista support a maximum of 31 reparse points (and therefore symbolic links) for a given path (i.e. any given path can have at most 31 indirections before Windows gives up).[10] Only users with the new Create Symbolic Link privilege, which only administrators have by default, can create symbolic links.[11] If this is not the desired behavior, it must be changed in the Local Security Policy management console. Additionally, NTFS symbolic links to files are distinct from NTFS symbolic links to directories and therefore cannot be used interchangeably, unlike on POSIX where the same symbolic link can refer to either files or directories. In Windows Vista and later, when the working directory path ends with a symbolic link, the current parent path reference, .., will refer to the parent directory of the symbolic link rather than that of its target. This behaviour is also found at the shell level in at least some POSIX systems, including Linux, but never in accessing files and directories through operating system calls. For instance, bash builtin commands pwd and cd operate on the current logical directory. pwd is often used in scripts to determine the actual current working directory. When any path is used with a system call, any use of .. will use the actual filesystem parent of the directory containing the .. pseudo-directory entry. So, cd ..; cat something and cat ../something may return completely different results. Examples[edit] PS > mklink /D "$env:LOCALAPPDATA\Plex Media Server" "G:\Plex Media Server" PS > New-Item -Path C:\TargetPath -ItemType SymbolicLink -Value F:\SourcePath NTFS junction points[edit] Main article: NTFS junction point The Windows 2000 version of NTFS introduced reparse points, which enabled, among other things, the use of Volume Mount Points and junction points. Junction points are for directories only, and moreover, local directories only; junction points to remote shares are unsupported.[12] The Windows 2000 and XP Resource Kits include a program called linkd to create junction points; a more powerful one named Junction was distributed by Sysinternals' Mark Russinovich. Not all standard applications support reparse points. Most noticeably, Backup suffers from this problem and will issue an error message 0x80070003[13] when the folders to be backed up contain a reparse point. Shortcuts[edit] Shortcuts, which are supported by the graphical file browsers of some operating systems, may resemble symbolic links but differ in a number of important ways. One difference is what type of software is able to follow them: Symbolic links are automatically resolved by the file system. Any software program, upon accessing a symbolic link, will see the target instead, whether the program is aware of symbolic links or not. Shortcuts are treated like ordinary files by the file system and by software programs that are not aware of them. Only software programs that understand shortcuts (such as the Windows shell and file browsers) treat them as references to other files. Another difference are the capabilities of the mechanism: Microsoft Windows shortcuts normally refer to a destination by an absolute path (starting from the root directory), whereas POSIX symbolic links can refer to destinations via either an absolute or a relative path. The latter is useful if both the location and destination of the symbolic link share a common path prefix[clarification needed], but that prefix is not yet known when the symbolic link is created (e.g., in an archive file that can be unpacked anywhere). Microsoft Windows application shortcuts contain additional metadata that can be associated with the destination, whereas POSIX symbolic links are just strings that will be interpreted as absolute or relative pathnames. Unlike symbolic links, Windows shortcuts maintain their references to their targets even when the target is moved or renamed. Windows domain clients may subscribe to a Windows service called Distributed Link Tracking to track the changes in files and folders to which they are interested. The service maintains the integrity of shortcuts, even when files and folders are moved across the network.[14] Additionally, in Windows 9x and later, Windows shell tries to find the target of a broken shortcut before proposing to delete it. Folder shortcuts[edit] Almost like shortcuts, but transparent to the Windows shell.[15]They are implemented as ordinary folders (which need to have the read only and/or system attribute[16]) containing a shortcut named target.lnk which refers to the target and a (hidden) desktop.ini with (at least) the following contents:  [.ShellClassInfo] CLSID2={0AFACED1-E828-11D1-9187-B532F1E9575D} Folder shortcuts are created and used from the Windows shell in the network neighborhood for example. Shell objects[edit] The shell objects[17] or shell folders are defined in the Windows registry and can be used to implement a sort of symbolic link too. Like folder shortcuts, they are transparent to the Windows shell. A minimal implementation is (the CLSID {00000000-0000-0000-0000-000000000000} is used as a placeholder):  [HKEY_CLASSES_ROOT\CLSID\{00000000-0000-0000-0000-000000000000}] @="display name" [HKEY_CLASSES_ROOT\CLSID\{00000000-0000-0000-0000-000000000000}\DefaultIcon] @="..." ; path to icon [HKEY_CLASSES_ROOT\CLSID\{00000000-0000-0000-0000-000000000000}\InProcServer32] @="%SystemRoot%\\System32\\ShDocVw.Dll" "ThreadingModel"="Apartment" [HKEY_CLASSES_ROOT\CLSID\{00000000-0000-0000-0000-000000000000}\Instance] "CLSID"="{0AFACED1-E828-11D1-9187-B532F1E9575D}" [HKEY_CLASSES_ROOT\CLSID\{00000000-0000-0000-0000-000000000000}\Instance\InitPropertyBag] "Attributes"=hex:15,00,00,00 "Target"="..." ; absolute (WITHOUT "TargetKnownFolder" or "TargetSpecialFolder" only)                ; or relative path to target "TargetKnownFolder"="{guidguid-guid-guid-guid-guidguidguid}" ; GUID of target folder, Windows Vista and later "TargetSpecialFolder"="0x00xy" ; CSIDL of target [HKEY_CLASSES_ROOT\CLSID\{00000000-0000-0000-0000-000000000000}\ShellFolder] "Attributes"=hex:00,00,00,00 The My Documents folder on the Desktop as well as the Fonts and the Administrative Tools folders in the Control Panel are examples of shell objects redirected to file-system folders. Cygwin symbolic links[edit] Cygwin simulates POSIX-compliant symbolic links in the Microsoft Windows file system. It uses identical programming and user utility interfaces as Unix (see above), but creates Windows shortcuts (.lnk files) with additional information used by Cygwin at the time of symlink resolution. Cygwin symlinks are compliant with the POSIX standard in terms of how they are resolved, and with Windows standards in terms of their on-disk representation. Additionally, Cygwin can be set up to support native Windows symbolic links which can be used out of Cygwin without restrictions.[18] This requires: Changing the CYGWIN environment variable to contain winsymlinks:native; Running the Cygwin with elevated rights because Windows restricts the creation of symbolic links to privileged users Some differences exist, however. Cygwin has no way to specify shortcut-related information – such as working directory or icon – as there is no place for such parameters in ln -s command. To create standard Microsoft .lnk files Cygwin provides the mkshortcut and readshortcut utilities.[19] The Cygwin User's Guide has more information on this topic.[18] MSYS2, which is based on Cygwin, has a similar set of winsymlinks settings but defaults to copying the files.[20] Summary[edit] Property/Action Symbolic link Junction Hard link When the link is deleted Target remains unchanged Target is deleted (except when using special tools) Reference counter is decremented; when it reaches 0, the target is deleted When target is moved Symbolic link becomes invalid Junction becomes invalid Hard link remains valid Relative path Allowed Not allowed (on saving, becomes an absolute path) N/A Crossing filesystem boundaries Supported Supported Not supported (target must be on same filesystem) Windows For files Windows Vista and later[21] (administrator rights required) No Yes For folders Yes No Unix For files Yes N/A Yes For directories Yes N/A Partial[22] Legacy systems[edit] Amiga[edit] The command creating symbolic links is makelink, which is also used for hard links. Internally the dos.library returns an error code indicating that a target is a soft link if you try to perform actions on it that are only legal for a file, and applications that wish to follow the symbolic link then needs to explicitly make a call to follow the link and retry the operation. The AmigaDOS shell will follow links automatically. OS/2[edit] In the OS/2 operating system, symbolic links somewhat resemble shadows in the graphical Workplace Shell. However, shadows, due to the fully object-oriented System Object Model, are considerably more powerful and robust than a simple link. For example, shadows do not lose their capabilities when renamed or when either the object or subject of the link is relocated.[citation needed] Variable symbolic links[edit] Symbolic links may be implemented in a context-dependent or variable fashion, such that the link points to varying targets depending on a configuration parameter, run-time parameter, or other instantaneous condition. A variable or variant symbolic link is a symbolic link that has a variable name embedded in it. This allows some flexibility in filesystem order that is not possible with a standard symbolic link. Variables embedded in a symbolic link may include user and environment specific information. Operating systems that make use of variant symbolic links include NetBSD, DragonFly BSD, Domain/OS.[23][24]Tru64 uses a context dependent symbolic link where the context is the cluster member number. Pyramid Technology's OSx Operating System implemented conditional symbolic links which pointed to different locations depending on which universe a program was running in. The universes supported were AT&T's SysV.3 and the Berkeley Software Distribution (BSD 4.3). For example: if the ps command was run in the att universe, then the symbolic link for the directory /bin would point to /.attbin and the program /.attbin/ps would be executed. Whereas if the ps command was run in the ucb universe, then /bin would point to /.ucbbin and /.ucbbin/ps would be executed. Similar Conditional Symbolic Links were also created for other directories such as /lib, /usr/lib, /usr/include.[25] See also[edit] Symlink race — a security-vulnerability caused by symbolic links freedup — generates links between identical data automatically References[edit] ^ Pathname resolution, POSIX. ^ Pike, Rob (2000). Lexical file names in Plan 9 or getting dot-dot right (PDF). Proc. USENIX Annual Tech. Conf. ^ symlink, symlinkat. IEEE Std 1003.1, 2013 Edition. ^ link, linkat. IEEE Std 1003.1, 2013 Edition. ^ "lchmod(2)". Manual pages for FreeBSD 11. ^ "lchflags(2)". Manual pages for FreeBSD 11. ^ "Link Shell Extension website". Link Shell Extension website. ^ Symbolic Links, MSDN Library, Win32 and COM Development, 2008-01-18 ^ CreateSymbolicLink Function, MSDN Library, Win32 and COM Development ^ Symbolic Link Programming Considerations, MSDN ^ Mark Russinovich: Inside the Windows Vista Kernel: Part 1 – File-based symbolic links, Microsoft Technet, February 2007. ^ "Sysinternals Junction documentation". microsoft.com. Retrieved 23 March 2018. ^ http://support.microsoft.com/kb/973455 ^ "Distributed Link Tracking and Object Identifiers". Microsoft Developers Network. Microsoft Corporation. 20 March 2011. Retrieved 30 June 2011. ^ "Specifying a Namespace Extension's Location". msdn.microsoft.com. Retrieved 23 March 2018. ^ [1] Unable to remove Read-Only attribute from folder ^ Creating Shell Extensions with Shell Instance Objects. msdn.microsoft.com ^ a b [2] Cygwin User's Guide, Cygwin. ^ [3] Microsoft .lnk files in Cygwin ^ "Coreutils: ln --symbolic creates hard links (MSYS2-packages #249)". GitHub. ^ The Windows implementation is not POSIX compliant ^ POSIX permits hard links on directories but does not require them. Modern file systems tend to not support it. ^ symlink(7) – NetBSD Miscellaneous Information Manual: magic symlinks. ^ Brooks Davis (2008). "Variant symbolic links for FreeBSD" (PDF). ^ Neil Brown (2016). "A case for variant symlinks". LWN. External links[edit] Wikibooks has a book on the topic of: Linux commands Q & A: The difference between hard and soft links as applied to Linux Junction: maintain NTFS junction points (for Windows 2000 and above) FSUtil Hardlink: Microsoft Technet page on using the command-line tool FSUtil to create hardlinks (for Windows 2000 and above) Link Shell Extension: Windows Explorer context menu, overlay icons and property sheet handler to maintain hardlinks, NTFS junction points, symbolic links etc. Symbolic Drivers for Windows XP (in Japanese): file system drivers to enables Symbolic Links for Windows XP (also mirrored on Link Shell Extension site). Sources available. This article is based on material taken from the Free On-line Dictionary of Computing prior to 1 November 2008 and incorporated under the "relicensing" terms of the GFDL, version 1.3 or later. v t e Computer files Types Binary file / text file File format List of file formats File signatures Magic number Metafile Sidecar file Sparse file Swap file System file Temporary file Zero-byte file Properties Filename 8.3 filename Long filename Filename mangling Filename extension List of filename extensions File attribute Extended file attributes File size Hidden file / Hidden directory Organisation Directory/folder NTFS links Temporary folder Directory structure File sequence File system Filesystem Hierarchy Standard Path Operations Open Close Read Write Linking Alias File descriptor Hard link Shadow Shortcut Symbolic link Management File comparison Data compression File manager Comparison of file managers File system permissions File transfer File sharing File verification Retrieved from "https://en.wikipedia.org/w/index.php?title=Symbolic_link&oldid=991137937" Categories: Computer file systems Hidden categories: Wikipedia articles needing clarification from September 2018 All articles with unsourced statements Articles with unsourced statements from April 2012 Articles with Japanese-language sources (ja) Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Current events Random article About Wikipedia Contact us Donate Contribute Help Learn to edit Community portal Recent changes Upload file Tools What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Print/export Download as PDF Printable version Languages العربية Čeština Deutsch Español فارسی Français 한국어 Bahasa Indonesia Italiano עברית Magyar 日本語 Norsk bokmål Polski Português Русский Svenska 中文 Edit links This page was last edited on 28 November 2020, at 13:28 (UTC). Text is available under the Creative Commons Attribution-ShareAlike License;additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization. Privacy policy About Wikipedia Disclaimers Contact Wikipedia Mobile view Developers Statistics Cookie statement